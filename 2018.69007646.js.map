{"mappings":"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,GAAO,CAAG,CAAE,CAAG,EAC3B,OAAO,GAAe,KAAK,CAAC,EAAK,EACrC,CAMA,GAAO,OAAO,CACV,GAAO,UAAU,CAAG,SAAU,CAAO,EAIjC,OAHA,GAAe,UAAU,CAAC,GAC1B,GAAO,QAAQ,CAAG,GAAe,QAAQ,CACzC,EAAe,GAAO,QAAQ,EACvB,EACf,EAIA,GAAO,WAAW,CAAG,EACrB,GAAO,QAAQ,CAAGgR,EAAAA,QAAS,CAI3B,GAAO,GAAG,CAAG,SAAU,GAAG,CAAI,EAI1B,OAHA,GAAe,GAAG,IAAI,GACtB,GAAO,QAAQ,CAAG,GAAe,QAAQ,CACzC,EAAe,GAAO,QAAQ,EACvB,EACX,EAIA,GAAO,UAAU,CAAG,SAAU,CAAM,CAAE,CAAQ,EAC1C,OAAO,GAAe,UAAU,CAAC,EAAQ,EAC7C,EAQA,GAAO,WAAW,CAAG,GAAe,WAAW,CAI/C,GAAO,MAAM,CAAG,GAChB,GAAO,MAAM,CAAG,GAAQ,KAAK,CAC7B,GAAO,QAAQ,CAAG,GAClB,GAAO,YAAY,CAAG,GACtB,GAAO,KAAK,CAAG,GACf,GAAO,KAAK,CAAG,GAAO,GAAG,CACzB,GAAO,SAAS,CAAG,EACnB,GAAO,KAAK,CAAG,GACf,GAAO,KAAK,CAAG,GACH,IAAC,GAAU,GAAO,OAAlB,CACC,GAAa,GAAO,UAArB,CACC,GAAM,GAAO,GAAd,CACC,GAAa,GAAO,UAArB,CACC,GAAc,GAAO,WAAtB,CAEC,GAAS,GAAQ,KAAlB,CACC,GAAQ,GAAO,GAAhB,A,C,E,K,C,G,E,K,C,G,E,M,C,G,E,M,C,G,E,Q,C,G,E,Y,C,G,E,S,C,E,E,W,C,E,E,K,C,G,E,M,C,G,E,O,C,G,E,K,CAFS,G,E,W,C,G,E,M,C,G,E,U,C,G,E,G,C,G,E,U,C,E,E,E,O,C,G,E,Q,S,C,C,C,E,E,E,O,C,Y,I,G,I,E,E,S,E,E,S,E,E,S,E,E,S,E,S,C,C,C,E,I,E,C,E,I,I,K,E,O,S,C,c,C,I,C,E,I,A,E,E,O,C,I,C,C,C,E,C,C,C,E,A,E,G,A,M,G,A,Y,O,O,qB,C,I,I,E,E,E,O,qB,C,G,E,E,M,C,I,E,E,O,C,C,C,E,G,O,S,C,oB,C,I,C,E,C,C,E,G,C,C,C,C,C,E,C,C,C,C,C,C,E,C,A,E,O,C,ECvDrB,IAAM,EAAqB,cAEd,EAAgC,AAAA,CAAA,EAAA,EAAA,QAAA,AAAA,EACzC,AAAC,IAAA,GAAA,CAAA,KAAE,EAAO,EAAE,CAAA,CAAA,EAAK,EAAI,EAAA,EAApB,CAAA,OAAsB,EAAK,MACxB,AAAA,CAAA,EAAA,EAAA,IAAA,AAAA,EAAC,EAAA,eAAA,CAAe,OAAA,MAAA,CAAA,CACZ,QAAQ,OACR,OAAO,KACP,OAAO,MACP,MACI,AAAA,CAAA,EAAA,EAAA,GAAA,AAAA,EAAA,IAAA,CAAG,UAAU,kCAAkC,KAAK,IAAG,SAClD,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAE,+BAA+B,EAClC,EAEJ,EAAI,CAAA,SAAA,CAEP,MAAA,EAAI,KAAA,EAAJ,EAAM,GAAG,CAAC,AAAC,IAAA,I,E,EAAA,CAAA,MAAE,CAAK,CAAA,KAAE,CAAI,CAAA,CAAA,EAAK,EAAa,EAAA,EAA/B,CAAA,QAAA,OAAiC,EAAK,MAC9C,AAAA,CAAA,EAAA,EAAA,GAAA,AAAA,EAAC,EAAA,OAAA,CAAO,OAAA,MAAA,CAAA,CACJ,UAAU,uCAAuC,EAC7C,EAAa,CACjB,KAAM,EAAmB,IAAI,CAAC,GAAQ,EAAO,CAAA,CAAA,EAAI,EAAI,CAAE,CACvD,OAAQ,AAAyB,OAAzB,CAAA,EAAA,AAAmB,OAAnB,CAAA,EAAA,WAAW,QAAA,AAAA,GAAQ,AAAA,KAAA,IAAA,EAAA,KAAA,EAAA,EAAE,IAAA,AAAA,GAAI,AAAA,KAAA,IAAA,EAAA,KAAA,EAAA,EAC3B,KAAK,CAAC,GACP,UAAU,CAAC,EAAO,IAAG,SAEzB,CAAK,GAEb,GACD,AAAA,CAAA,EAAA,EAAA,GAAA,AAAA,EAAA,SAAA,CACI,UAAU,8BACV,MAAO,AAAA,EAAA,IAAA,CAAK,eAAe,CAC3B,SAAU,CAAC,CAAA,cAAE,CAAa,CAAE,GACxB,AAAA,CAAA,EAAA,EAAA,IAAA,AAAA,EAAK,cAAc,CACd,EACI,KAAoC,EAC5C,SAGJ,OAAO,OAAO,CAAC,EAAA,YAAA,EAAc,GAAG,CAAC,CAAC,CAAC,EAAM,EAAK,GAC3C,AAAA,CAAA,EAAA,EAAA,GAAA,AAAA,EAAA,SAAA,CAAmB,MAAO,EAAI,SACzB,CAAI,EADI,GAGf,GACG,AAAA,GAEhB,E,G,E,Q,S,C,C,C,E,E,E,O,C,Q,I,G,E,E,O,C,W,I,G,E,E,O,C,Y,I,G,E,E,O,C,S,I,G,E,E,O,C,W,I,G,E,E,O,C,W,I,G,E,E,O,C,S,I,G,E,E,O,C,Q,I,G,E,E,O,C,W,I,G,E,E,O,C,W,I,G,E,E,O,C,Y,I,G,I,E,E,S,E,S,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,S,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,S,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,S,I,E,E,S,E,E,S,E,E,S,E,E,S,E,S,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,SCxBE,IAAM,EAAQ,IAAM,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAE,wCAEhB,EAAW,IAAM,CAC1B,CACI,MAAO,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAE,2BACT,KAAM,eACT,EACD,CACI,MAAO,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAE,mBACT,KAAM,WACT,EACD,CACI,MAAO,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAE,UACT,KAAM,QACT,EACD,CACI,MAAO,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAE,sBACT,KAAM,SACT,EACD,CACI,MAAO,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAE,2BACT,KAAM,aACT,EACD,CACI,MAAO,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAE,YACT,KAAM,WACT,EACD,CACI,MAAO,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAE,WACT,KAAM,UACT,EACD,CACI,MAAO,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAE,0BACT,KAAM,SACT,EACD,CACI,MAAO,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAE,cACT,KAAM,kDACT,EACD,CACI,MAAO,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EY,EAAW,CACpB,CACI,KAAM,OACN,KAAM,WAAA,EAAA,EAAA,GACN,IAAK,8BACR,EACD,CACI,KAAM,OACN,KAAM,EAAA,OAAA,CACN,IAAK,0BACR,EACD,CACI,KAAM,KACN,KAAM,WAAA,EAAA,EAAA,GACN,IAAK,0BACR,EACD,CACI,KAAM,QACN,KAAM,WAAA,EAAA,EAAA,GACN,IAAK,uBACR,EACD,CACI,KAAM,MACN,KAAM,WAAA,EAAA,EAAA,GACN,IAAK,4BACR,EACD,CACI,KAAM,OACN,KAAM,EAAA,MAAA,CACN,IAAK,4BACR,EACD,CACI,KAAM,OACN,KAAM,WAAA,EAAA,EAAA,GACN,IAAK,yBACR,EACD,CACI,KAAM,eACN,KAAM,WAAA,EAAA,EAAA,GACN,IAAK,2BACR,EACD,CACI,KAAM,SACN,KAAM,WAAA,EAAA,EAAA,GACN,IAAK,wBACR,EACJ,CAEY,EAAY,CACrB,MACA,OACA,OACA,KACA,MACA,UACA,eACA,OACA,MACA,KACA,KACA,OACA,OACA,OACA,KACA,MACA,KACA,OACA,OACA,MACA,MACA,KACA,MACA,YACA,OACA,OACA,WACA,OACA,OACA,KACA,OACA,MACA,OACA,MACA,KACA,MACA,OACA,OACH,A,G,E,Q,S,C,C,C,E,E,E,O,C,S,I,G,E,E,O,C,U,I,G,E,E,O,C,M,I,W,E,E,E,W,E,E,O,C,M,I,W,E,E,E,W,E,E,O,C,K,I,W,E,E,E,W,E,E,O,C,S,I,W,E,E,E,W,E,E,O,C,M,I,W,E,E,E,W,E,E,O,C,U,I,W,E,E,E,W,E,E,O,C,M,I,W,E,E,E,W,E,E,O,C,K,I,W,E,E,E,W,E,E,O,C,O,I,W,E,E,E,W,E,E,O,C,K,I,W,E,E,E,W,E,E,O,C,K,I,W,E,E,E,W,E,E,O,C,O,I,W,E,E,E,W,E,E,O,C,K,I,W,E,E,E,W,E,E,O,C,M,I,W,E,E,E,W,E,E,O,C,K,I,W,E,E,E,W,E,E,O,C,K,I,W,E,E,E,W,E,E,O,C,O,I,W,E,E,E,W,E,E,O,C,M,I,W,E,E,E,W,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,SCvcM,IAAM,EACT,4DACS,EACT,yD,G,E,Q,S,C,C,C,ECvBJ,EAAA,OAAA,CAAiB,IAAA,IAAoB,mCAAA,YAAA,GAAA,EAAoC,QAAQ,E,G,E,Q,S,C,C,C,ECAjF,EAAA,OAAA,CAAiB,IAAA,IAAoB,oCAAA,YAAA,GAAA,EAAqC,QAAQ,E,G,E,Q,S,C,C,C,ECAlF,EAAA,OAAA,CAAiB,IAAA,IAAoB,mCAAA,YAAA,GAAA,EAAoC,QAAQ,E,G,E,Q,S,C,C,C,ECAjF,EAAA,OAAA,CAAiB,IAAA,IAAoB,uCAAA,YAAA,GAAA,EAAwC,QAAQ,E,G,E,Q,S,C,C,C,ECArF,EAAA,OAAA,CAAiB,IAAA,IAAoB,oCAAA,YAAA,GAAA,EAAqC,QAAQ,E,G,E,Q,S,C,C,C,ECAlF,EAAA,OAAA,CAAiB,IAAA,IAAoB,wCAAA,YAAA,GAAA,EAAyC,QAAQ,E,G,E,Q,S,C,C,C,ECAtF,EAAA,OAAA,CAAiB,IAAA,IAAoB,oCAAA,YAAA,GAAA,EAAqC,QAAQ,E,G,E,Q,S,C,C,C,ECAlF,EAAA,OAAA,CAAiB,IAAA,IAAoB,mCAAA,YAAA,GAAA,EAAoC,QAAQ,E,G,E,Q,S,C,C,C,ECAjF,EAAA,OAAA,CAAiB,IAAA,IAAoB,qCAAA,YAAA,GAAA,EAAsC,QAAQ,E,G,E,Q,S,C,C,C,ECAnF,EAAA,OAAA,CAAiB,IAAA,IAAoB,mCAAA,YAAA,GAAA,EAAoC,QAAQ,E,G,E,Q,S,C,C,C,ECAjF,EAAA,OAAA,CAAiB,IAAA,IAAoB,mCAAA,YAAA,GAAA,EAAoC,QAAQ,E,G,E,Q,S,C,C,C,ECAjF,EAAA,OAAA,CAAiB,IAAA,IAAoB,mCAAA,YAAA,GAAA,EAAoC,QAAQ,E,G,E,Q,S,C,C,C,ECAjF,EAAA,OAAA,CAAiB,IAAA,IAAoB,qCAAA,YAAA,GAAA,EAAsC,QAAQ,E,G,E,Q,S,C,C,C,ECAnF,EAAA,OAAA,CAAiB,IAAA,IAAoB,mCAAA,YAAA,GAAA,EAAoC,QAAQ,E,G,E,Q,S,C,C,C,ECAjF,EAAA,OAAA,CAAiB,IAAA,IAAoB,oCAAA,YAAA,GAAA,EAAqC,QAAQ,E,G,E,Q,S,C,C,C,ECAlF,EAAA,OAAA,CAAiB,IAAA,IAAoB,mCAAA,YAAA,GAAA,EAAoC,QAAQ,E,G,E,Q,S,C,C,C,ECAjF,EAAA,OAAA,CAAiB,IAAA,IAAoB,mCAAA,YAAA,GAAA,EAAoC,QAAQ,E,G,E,Q,S,C,C,C,ECAjF,EAAA,OAAA,CAAiB,IAAA,IAAoB,qCAAA,YAAA,GAAA,EAAsC,QAAQ,E,G,E,Q,S,C,C,C,ECAnF,EAAA,OAAA,CAAiB,IAAA,IAAoB,oCAAA,YAAA,GAAA,EAAqC,QAAQ,E,G,E,Q,S,C,C,C,E,E,E,O,C,U,I,G,E,E,O,C,S,I,W,E,E,E,W,E,E,O,C,Y,I,W,E,E,E,W,E,E,O,C,Y,I,W,E,E,E,W,E,S,E,S,E,SCI3E,IAAM,EAAU,4C,G,E,Q,S,C,C,C,ECJvB,EAAA,OAAA,CAAiB,IAAA,IAAoB,uCAAA,YAAA,GAAA,EAAwC,QAAQ,E,G,E,Q,S,C,C,C,ECArF,EAAA,OAAA,CAAiB,IAAA,IAAoB,0CAAA,YAAA,GAAA,EAA2C,QAAQ,E,G,E,Q,S,C,C,C,ECAxF,EAAA,OAAA,CAAiB,IAAA,IAAoB,0CAAA,YAAA,GAAA,EAA2C,QAAQ,E,G,E,Q,S,C,C,C,E,E,E,O,C,a,I,W,E,E,E,W,E,E,O,C,c,I,W,E,E,E,W,E,E,O,C,W,I,W,E,E,E,W,E,E,O,C,gB,I,W,E,E,E,W,E,E,O,C,S,I,W,E,E,E,W,E,E,O,C,Y,I,W,E,E,E,W,E,E,O,C,S,I,W,E,E,E,W,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,Q,G,E,Q,S,C,C,C,EEAxF,EAAA,OAAA,CAAiB,IAAA,IAAoB,2CAAA,YAAA,GAAA,EAA4C,QAAQ,E,G,E,Q,S,C,C,C,ECAzF,EAAA,OAAA,CAAiB,IAAA,IAAoB,4CAAA,YAAA,GAAA,EAA6C,QAAQ,E,G,E,Q,S,C,C,C,ECA1F,EAAA,OAAA,CAAiB,IAAA,IAAoB,yCAAA,YAAA,GAAA,EAA0C,QAAQ,E,G,E,Q,S,C,C,C,ECAvF,EAAA,OAAA,CAAiB,IAAA,IAAoB,2CAAA,YAAA,GAAA,EAA4C,QAAQ,E,G,E,Q,S,C,C,C,ECAzF,EAAA,OAAA,CAAiB,IAAA,IAAoB,8CAAA,YAAA,GAAA,EAA+C,QAAQ,E,G,E,Q,S,C,C,C,ECA5F,EAAA,OAAA,CAAiB,IAAA,IAAoB,uCAAA,YAAA,GAAA,EAAwC,QAAQ,E,G,E,Q,S,C,C,C,ECArF,EAAA,OAAA,CAAiB,IAAA,IAAoB,0CAAA,YAAA,GAAA,EAA2C,QAAQ,E,G,E,Q,S,C,C,C,ECAxF,EAAA,OAAA,CAAiB,IAAA,IAAoB,uCAAA,YAAA,GAAA,EAAwC,QAAQ,E,G,E,Q,S,C,C,C,E,E,E,O,C,S,I,G,E,E,O,C,S,I,W,E,E,E,W,E,E,O,C,Y,I,W,E,E,E,W,E,E,O,C,U,I,W,E,E,E,W,E,E,O,C,Q,I,W,E,E,E,W,E,S,E,S,E,S,E,SCK9E,IAAM,EAAS,4C,G,E,Q,S,C,C,C,ECLtB,EAAA,OAAA,CAAiB,IAAA,IAAoB,uCAAA,YAAA,GAAA,EAAwC,QAAQ,E,G,E,Q,S,C,C,C,ECArF,EAAA,OAAA,CAAiB,IAAA,IAAoB,0CAAA,YAAA,GAAA,EAA2C,QAAQ,E,G,E,Q,S,C,C,C,ECAxF,EAAA,OAAA,CAAiB,IAAA,IAAoB,wCAAA,YAAA,GAAA,EAAyC,QAAQ,E,G,E,Q,S,C,C,C,ECAtF,EAAA,OAAA,CAAiB,IAAA,IAAoB,sCAAA,YAAA,GAAA,EAAuC,QAAQ,E,G,E,Q,S,C,C,C,E,E,E,O,C,Y,I,W,E,E,E,W,E,E,O,C,S,I,W,E,E,E,W,E,E,O,C,S,I,W,E,E,E,W,E,E,O,C,M,I,W,E,E,E,W,E,S,E,S,E,S,E,Q,G,E,Q,S,C,C,C,EEApF,EAAA,OAAA,CAAiB,IAAA,IAAoB,0CAAA,YAAA,GAAA,EAA2C,QAAQ,E,G,E,Q,S,C,C,C,ECAxF,EAAA,OAAA,CAAiB,IAAA,IAAoB,uCAAA,YAAA,GAAA,EAAwC,QAAQ,E,G,E,Q,S,C,C,C,ECArF,EAAA,OAAA,CAAiB,IAAA,IAAoB,uCAAA,YAAA,GAAA,EAAwC,QAAQ,E,G,E,Q,S,C,C,C,ECArF,EAAA,OAAA,CAAiB,IAAA,IAAoB,oCAAA,YAAA,GAAA,EAAqC,QAAQ,E,G,E,Q,S,C,C,C,E,E,E,O,C,S,I,W,E,E,E,W,E,E,O,C,mB,I,W,E,E,E,W,E,E,O,C,S,I,W,E,E,E,W,E,E,O,C,c,I,W,E,E,E,W,E,E,O,C,O,I,W,E,E,E,W,E,E,O,C,a,I,W,E,E,E,W,E,E,O,C,M,I,W,E,E,E,W,E,E,O,C,c,I,W,E,E,E,W,E,E,O,C,S,I,W,E,E,E,W,E,E,O,C,e,I,W,E,E,E,W,E,E,O,C,U,I,W,E,E,E,W,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,S,E,Q,G,E,Q,S,C,C,C,EEAlF,EAAA,OAAA,CAAiB,IAAA,IAAoB,uCAAA,YAAA,GAAA,EAAwC,QAAQ,E,G,E,Q,S,C,C,C,ECArF,EAAA,OAAA,CAAiB,IAAA,IAAoB,iDAAA,YAAA,GAAA,EAAkD,QAAQ,E,G,E,Q,S,C,C,C,ECA/F,EAAA,OAAA,CAAiB,IAAA,IAAoB,uCAAA,YAAA,GAAA,EAAwC,QAAQ,E,G,E,Q,S,C,C,C,ECArF,EAAA,OAAA,CAAiB,IAAA,IAAoB,4CAAA,YAAA,GAAA,EAA6C,QAAQ,E,G,E,Q,S,C,C,C,ECA1F,EAAA,OAAA,CAAiB,IAAA,IAAoB,qCAAA,YAAA,GAAA,EAAsC,QAAQ,E,G,E,Q,S,C,C,C,ECAnF,EAAA,OAAA,CAAiB,IAAA,IAAoB,2CAAA,YAAA,GAAA,EAA4C,QAAQ,E,G,E,Q,S,C,C,C,ECAzF,EAAA,OAAA,CAAiB,IAAA,IAAoB,oCAAA,YAAA,GAAA,EAAqC,QAAQ,E,G,E,Q,S,C,C,C,ECAlF,EAAA,OAAA,CAAiB,IAAA,IAAoB,4CAAA,YAAA,GAAA,EAA6C,QAAQ,E,G,E,Q,S,C,C,C,ECA1F,EAAA,OAAA,CAAiB,IAAA,IAAoB,uCAAA,YAAA,GAAA,EAAwC,QAAQ,E,G,E,Q,S,C,C,C,ECArF,EAAA,OAAA,CAAiB,IAAA,IAAoB,6CAAA,YAAA,GAAA,EAA8C,QAAQ,E,G,E,Q,S,C,C,C,ECA3F,EAAA,OAAA,CAAiB,IAAA,IAAoB,wCAAA,YAAA,GAAA,EAAyC,QAAQ,E,G,E,Q,S,C,C,C,E,E,E,O,C,U,I,G,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,SCUtF,EAAe,CAAC,WAAA,EAAA,EAAA,GAAI,WAAA,EAAA,EAAA,GAAI,WAAA,EAAA,EAAA,GAAI,WAAA,EAAA,EAAA,GAAI,WAAA,EAAA,EAAA,GAAI,WAAA,EAAA,EAAA,GAAI,WAAA,EAAA,EAAA,GAAI,WAAA,EAAA,EAAA,GAAI,WAAA,EAAA,EAAA,GAAG,A,G,E,Q,S,C,C,C,ECVnD,EAAA,OAAA,CAAiB,IAAA,IAAoB,kCAAA,YAAA,GAAA,EAAmC,QAAQ,E,G,E,Q,S,C,C,C,ECAhF,EAAA,OAAA,CAAiB,IAAA,IAAoB,kCAAA,YAAA,GAAA,EAAmC,QAAQ,E,G,E,Q,S,C,C,C,ECAhF,EAAA,OAAA,CAAiB,IAAA,IAAoB,kCAAA,YAAA,GAAA,EAAmC,QAAQ,E,G,E,Q,S,C,C,C,ECAhF,EAAA,OAAA,CAAiB,IAAA,IAAoB,kCAAA,YAAA,GAAA,EAAmC,QAAQ,E,G,E,Q,S,C,C,C,ECAhF,EAAA,OAAA,CAAiB,IAAA,IAAoB,kCAAA,YAAA,GAAA,EAAmC,QAAQ,E,G,E,Q,S,C,C,C,ECAhF,EAAA,OAAA,CAAiB,IAAA,IAAoB,kCAAA,YAAA,GAAA,EAAmC,QAAQ,E,G,E,Q,S,C,C,C,ECAhF,EAAA,OAAA,CAAiB,IAAA,IAAoB,kCAAA,YAAA,GAAA,EAAmC,QAAQ,E,G,E,Q,S,C,C,C,ECAhF,EAAA,OAAA,CAAiB,IAAA,IAAoB,kCAAA,YAAA,GAAA,EAAmC,QAAQ,E,G,E,Q,S,C,C,C,ECAhF,EAAA,OAAA,CAAiB,IAAA,IAAoB,kCAAA,YAAA,GAAA,EAAmC,QAAQ,E,G,E,Q,S,C,C,C,MCAhF,EAEA,EAMA,EACA,EACA,EACA,EAGA,EACA,EACA,EACA,E,E,E,O,C,O,I,E,A,G,E,G,E,E,O,C,S,I,E,A,G,E,G,E,E,O,C,S,I,E,A,G,E,G,E,E,O,C,Y,I,E,A,G,E,G,E,E,O,C,U,I,E,A,G,E,G,E,E,O,C,U,I,E,A,G,E,G,E,E,O,C,W,I,E,A,G,E,G,E,E,O,C,S,I,E,A,G,E,G,E,E,O,C,Y,I,E,A,G,E,G,E,E,O,C,mB,I,E,A,G,E,GAjBA,EAAyB,cAEzB,EAA2B,gBAM3B,EAA2B,gBAC3B,EAA8B,mBAC9B,EAA4B,iBAC5B,EAA4B,iBAG5B,EAA6B,kBAC7B,EAA2B,gBAC3B,EAA8B,mBAC9B,EAAqC,yB,G,E,Q,S,C,C,C,E,E,E,O,C,W,I,G,I,E,E,SCb9B,IAAM,EAAmC,CAAC,CAAA,OAAE,CAAM,CAAE,GACvD,AAAA,CAAA,EAAA,EAAA,GAAA,AAAA,EAAA,MAAA,CAAK,UAAU,+DAA8D,SACxE,EAAO,GAAG,CAAC,CAAC,CAAA,IAAE,CAAG,CAAA,KAAE,CAAI,CAAA,KAAE,CAAI,CAAE,GAC5B,AAAA,CAAA,EAAA,EAAA,GAAA,AAAA,EAAA,IAAA,CAAc,OAAO,SAAS,KAAM,EAAG,SACnC,AAAA,CAAA,EAAA,EAAA,GAAA,AAAA,EAAA,MAAA,CACI,UAAU,sCACV,MAAO,EACP,IAAK,EACL,MAAO,CAAE,MAAO,OAAO,CAAE,EAC3B,EANE,GAQV,E","sources":["<anon>","source/page/2018/index.tsx","node_modules/.pnpm/marked@14.1.4/node_modules/marked/lib/marked.umd.js","node_modules/.pnpm/marked@14.1.4/node_modules/marked/src/defaults.ts","node_modules/.pnpm/marked@14.1.4/node_modules/marked/src/helpers.ts","node_modules/.pnpm/marked@14.1.4/node_modules/marked/src/Tokenizer.ts","node_modules/.pnpm/marked@14.1.4/node_modules/marked/src/rules.ts","node_modules/.pnpm/marked@14.1.4/node_modules/marked/src/Lexer.ts","node_modules/.pnpm/marked@14.1.4/node_modules/marked/src/Renderer.ts","node_modules/.pnpm/marked@14.1.4/node_modules/marked/src/TextRenderer.ts","node_modules/.pnpm/marked@14.1.4/node_modules/marked/src/Parser.ts","node_modules/.pnpm/marked@14.1.4/node_modules/marked/src/Hooks.ts","node_modules/.pnpm/marked@14.1.4/node_modules/marked/src/Instance.ts","node_modules/.pnpm/marked@14.1.4/node_modules/marked/src/marked.ts","source/component/TopNavBar.tsx","source/page/2018/data.ts","source/page/2017/image/logos/index.ts","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-6393fca5a054dc59.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-009e677dec0fbe80.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-0dc0408d1d061440.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-6ead37d043faf4d7.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-5afc3dfc3b90d7a6.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-1740e845c5830afe.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-7d03d26c3e63d5df.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-77a22267d1a264d2.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-078f4882f66c5405.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-1234313ac27c8c30.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-0f00926df6e806d9.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-6539407f0afcff10.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-6f1d39c26cc480de.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-5c80febd9be818bd.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-3a7d9ca1ddb4c857.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-fad416bcc0a2e5cb.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-cb94f5be78fdb246.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-f76f501a4eca6cb2.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-b8103ee149f70f56.js","source/page/2018/image/index.ts","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-ee74f02a43ba344d.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-029d55d997c984cd.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-1a7fa7409a3302e4.js","source/page/2018/image/lecturer/index.ts","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-5660c7ee9793b4e8.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-5cc74063d508fafb.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-6d6f8186010bc3d7.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-b4a9f326c943fce9.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-7a39a5c50fffa247.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-b9e36cf44aabbc84.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-59ea2d36f40dc5f9.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-b42d386cb9540ca9.js","source/page/2018/image/logo/partner/index.ts","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-cd89d373644d7c2c.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-103ed9741e45a184.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-689a0b01cb4e6261.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-41432f2e2b921e5f.js","source/page/2018/image/logo/sponsor/index.ts","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-f0c117bf6a2b319e.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-40892cf36655921b.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-9fe82dddce453fec.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-e851696e0182fcd1.js","source/page/2018/image/project/index.ts","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-f5e2d82a930c7815.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-f78eeeda9383c26a.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-7db1f9eb1e671ff3.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-889b4de37c1d8cbf.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-ea05875dc7c74bbd.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-8b48062b8f6006ca.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-73350d55779622fc.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-a8117e1aadc689a1.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-702a274f6395a416.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-8c4e808ee4f0278d.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-7b0172dd06dcb7a6.js","source/page/2018/image/photos/index.ts","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-5762609b3353ab94.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-1719e646e2d33d47.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-aea376459071d3f6.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-8a7aeb08aa4d1bf1.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-dbf66ae2edf95c7b.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-f381fe350cf525da.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-24c352ad13654dfc.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-c4074f0acb9a8b4e.js","node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.13_/node_modules/@parcel/runtime-js/lib/runtime-984067fe68f00ce4.js","source/page/2018/index.module.less","source/page/2018/LogoList.tsx"],"sourcesContent":["\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true, configurable: true});\n}\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire2198\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"eTgug\", function(module, exports) {\n\n$parcel$defineInteropFlag(module.exports);\n\n$parcel$export(module.exports, \"default\", () => $ad72fdbf935866b0$export$2e2bcd8739ae039);\n\nvar $b603G = parcelRequire(\"b603G\");\n\nvar $fonQc = parcelRequire(\"fonQc\");\n\nvar $4eJD6 = parcelRequire(\"4eJD6\");\n\nvar $89MmN = parcelRequire(\"89MmN\");\n\nvar $6rYRn = parcelRequire(\"6rYRn\");\n\nvar $6T66T = parcelRequire(\"6T66T\");\n\nvar $3phDk = parcelRequire(\"3phDk\");\nparcelRequire(\"f6NIY\");\nvar $7dZa5 = parcelRequire(\"7dZa5\");\nvar $7qUFF = parcelRequire(\"7qUFF\");\nvar $5pWIJ = parcelRequire(\"5pWIJ\");\n\nvar $1PSFd = parcelRequire(\"1PSFd\");\n\nvar $h58g0 = parcelRequire(\"h58g0\");\n\nvar $g3Ku0 = parcelRequire(\"g3Ku0\");\nvar $ad72fdbf935866b0$export$2e2bcd8739ae039 = (0, $89MmN.observer)(()=>(0, $b603G.jsxs)(\"main\", {\n        className: $h58g0.root,\n        children: [\n            (0, $b603G.jsx)((0, $6rYRn.TopNavBar), {\n                brand: (0, $3phDk.title)(),\n                expand: \"lg\",\n                variant: \"light\",\n                menu: (0, $3phDk.sections)()\n            }),\n            (0, $b603G.jsx)(\"div\", {\n                className: $h58g0.poster,\n                children: (0, $b603G.jsx)((0, $fonQc.Image), {\n                    src: (0, (/*@__PURE__*/$parcel$interopDefault($7dZa5))),\n                    fluid: true\n                })\n            }),\n            (0, $b603G.jsxs)(\"section\", {\n                id: \"Introduction\",\n                children: [\n                    (0, $b603G.jsx)(\"h2\", {\n                        className: \"text-center mb-5\",\n                        children: (0, $6T66T.t)(\"conference_introduction\")\n                    }),\n                    (0, $b603G.jsx)((0, $fonQc.Container), {\n                        children: (0, $b603G.jsxs)(\"div\", {\n                            className: \"row\",\n                            children: [\n                                (0, $b603G.jsxs)(\"div\", {\n                                    className: \"col-md-7\",\n                                    children: [\n                                        (0, $b603G.jsx)(\"p\", {\n                                            children: (0, $6T66T.t)(\"conference_description\")\n                                        }),\n                                        (0, $b603G.jsx)(\"div\", {\n                                            className: \"p-4 text-center\",\n                                            children: (0, $b603G.jsx)((0, $fonQc.Button), {\n                                                variant: \"primary\",\n                                                size: \"lg\",\n                                                target: \"_blank\",\n                                                href: \"http://fcc-chengdu.mikecrm.com/tFM8Rk8\",\n                                                children: (0, $6T66T.t)(\"register_now\")\n                                            })\n                                        })\n                                    ]\n                                }),\n                                (0, $b603G.jsx)(\"div\", {\n                                    className: \"col-md-5\",\n                                    children: (0, $b603G.jsx)((0, $fonQc.Image), {\n                                        fluid: true,\n                                        src: (0, (/*@__PURE__*/$parcel$interopDefault($7qUFF)))\n                                    })\n                                })\n                            ]\n                        })\n                    })\n                ]\n            }),\n            (0, $b603G.jsxs)(\"section\", {\n                id: \"Lecturer\",\n                className: $h58g0.sparked,\n                children: [\n                    (0, $b603G.jsx)(\"h2\", {\n                        className: \"mb-5\",\n                        children: (0, $6T66T.t)(\"guest_lecturers\")\n                    }),\n                    (0, $b603G.jsx)((0, $fonQc.Container), {\n                        children: (0, $b603G.jsx)(\"div\", {\n                            className: \"row lecture-list\",\n                            children: (0, $3phDk.lecturers)().map(({ avatar: avatar, name: name, detail: detail })=>(0, $b603G.jsx)(\"div\", {\n                                    className: \"col-md-3 p-2\",\n                                    children: (0, $b603G.jsxs)(\"div\", {\n                                        className: $h58g0.lecture,\n                                        children: [\n                                            (0, $b603G.jsx)(\"img\", {\n                                                src: avatar,\n                                                className: $h58g0.avatar,\n                                                alt: name\n                                            }),\n                                            (0, $b603G.jsx)(\"p\", {\n                                                className: \"lecture-name\",\n                                                children: name\n                                            }),\n                                            (0, $b603G.jsx)(\"p\", {\n                                                className: \"lecture-intro text-left\",\n                                                innerHTML: (0, $4eJD6.marked)(detail)\n                                            })\n                                        ]\n                                    })\n                                }, name))\n                        })\n                    })\n                ]\n            }),\n            (0, $b603G.jsxs)(\"section\", {\n                id: \"Topic\",\n                children: [\n                    (0, $b603G.jsx)(\"h2\", {\n                        className: \"text-center mb-5\",\n                        children: (0, $6T66T.t)(\"topics\")\n                    }),\n                    (0, $b603G.jsx)((0, $fonQc.Container), {\n                        children: (0, $b603G.jsx)(\"ol\", {\n                            className: `${$h58g0.subjects} overflow-hidden list-unstyled position-relative`,\n                            children: (0, $3phDk.topics)().map(({ lecturer: lecturer, title: title, detail: detail })=>(0, $b603G.jsxs)(\"li\", {\n                                    className: title,\n                                    children: [\n                                        (0, $b603G.jsxs)(\"div\", {\n                                            className: \"text-center\",\n                                            children: [\n                                                (0, $b603G.jsx)(\"h6\", {\n                                                    children: lecturer.name\n                                                }),\n                                                (0, $b603G.jsx)(\"img\", {\n                                                    className: $h58g0[\"avatar-sm\"],\n                                                    src: lecturer.avatar\n                                                })\n                                            ]\n                                        }),\n                                        (0, $b603G.jsxs)(\"div\", {\n                                            children: [\n                                                (0, $b603G.jsx)(\"h5\", {\n                                                    children: title\n                                                }),\n                                                (0, $b603G.jsx)(\"p\", {\n                                                    innerHTML: (0, $4eJD6.marked)(detail)\n                                                })\n                                            ]\n                                        })\n                                    ]\n                                }, title))\n                        })\n                    })\n                ]\n            }),\n            (0, $b603G.jsx)(\"section\", {\n                className: $h58g0.sparked,\n                children: (0, $b603G.jsxs)((0, $fonQc.Container), {\n                    children: [\n                        (0, $b603G.jsxs)(\"div\", {\n                            id: \"Bazaar\",\n                            className: \"mb-4\",\n                            children: [\n                                (0, $b603G.jsx)(\"h2\", {\n                                    className: \"text-center mb-5\",\n                                    children: (0, $6T66T.t)(\"open_source_bazaar\")\n                                }),\n                                (0, $b603G.jsx)(\"div\", {\n                                    className: \"row row-cols-1 row-cols-md-3 g-3\",\n                                    children: (0, $3phDk.projects)().map(({ type: type, URL: URL, title: title, detail: detail, logo: logo })=>(0, $b603G.jsx)(\"div\", {\n                                            className: \"col\",\n                                            children: (0, $b603G.jsxs)((0, $fonQc.Card), {\n                                                className: \"overflow-hidden\",\n                                                children: [\n                                                    (0, $b603G.jsx)((0, $fonQc.CardImg), {\n                                                        src: logo\n                                                    }),\n                                                    (0, $b603G.jsxs)((0, $fonQc.CardBody), {\n                                                        children: [\n                                                            (0, $b603G.jsx)((0, $fonQc.CardTitle), {\n                                                                children: (0, $b603G.jsx)(\"a\", {\n                                                                    className: \"stretched-link text-primary\",\n                                                                    target: \"_blank\",\n                                                                    href: URL,\n                                                                    rel: \"noreferrer\",\n                                                                    children: title\n                                                                })\n                                                            }),\n                                                            (0, $b603G.jsx)(\"div\", {\n                                                                className: `cr cr-top cr-right cr-${type ? \"red\" : \"blue\"}`,\n                                                                children: type ? (0, $6T66T.t)(\"club\") : (0, $6T66T.t)(\"project\")\n                                                            }),\n                                                            detail\n                                                        ]\n                                                    })\n                                                ]\n                                            })\n                                        }, title))\n                                })\n                            ]\n                        }),\n                        (0, $b603G.jsxs)(\"div\", {\n                            id: \"Enterprise\",\n                            className: \"text-center\",\n                            children: [\n                                (0, $b603G.jsx)(\"h2\", {\n                                    className: \"text-center mb-5\",\n                                    children: (0, $6T66T.t)(\"participating_companies\")\n                                }),\n                                (0, $b603G.jsx)(\"p\", {\n                                    className: \"text-muted\",\n                                    children: (0, $6T66T.t)(\"enterprises_open_onsite_recruitment_welcome_talents\")\n                                }),\n                                (0, $b603G.jsx)(\"p\", {\n                                    className: \"text-muted\",\n                                    children: (0, $6T66T.t)(\"no_particular_order\")\n                                }),\n                                (0, $b603G.jsxs)(\"div\", {\n                                    className: \"row\",\n                                    children: [\n                                        (0, $b603G.jsx)(\"div\", {\n                                            className: \"col-md-7\",\n                                            children: (0, $b603G.jsx)(\"ul\", {\n                                                className: `${$h58g0.companies} list-inline`,\n                                                children: (0, $3phDk.companies).map((name)=>(0, $b603G.jsx)(\"li\", {\n                                                        className: \"list-inline-item py-1 px-3 m-1 bg-white rounded\",\n                                                        children: name\n                                                    }, name))\n                                            })\n                                        }),\n                                        (0, $b603G.jsx)(\"div\", {\n                                            className: \"col-md-5\",\n                                            children: (0, $b603G.jsx)((0, $fonQc.Image), {\n                                                fluid: true,\n                                                src: (0, (/*@__PURE__*/$parcel$interopDefault($5pWIJ)))\n                                            })\n                                        })\n                                    ]\n                                })\n                            ]\n                        })\n                    ]\n                })\n            }),\n            (0, $b603G.jsxs)(\"section\", {\n                id: \"Schedule\",\n                children: [\n                    (0, $b603G.jsx)(\"h2\", {\n                        className: \"text-center mb-5\",\n                        children: (0, $6T66T.t)(\"schedule\")\n                    }),\n                    (0, $b603G.jsx)((0, $fonQc.Container), {\n                        children: (0, $b603G.jsxs)((0, $fonQc.Table), {\n                            className: \"text-center\",\n                            striped: true,\n                            hover: true,\n                            children: [\n                                (0, $b603G.jsx)(\"thead\", {\n                                    children: (0, $b603G.jsxs)(\"tr\", {\n                                        children: [\n                                            (0, $b603G.jsx)(\"th\", {\n                                                scope: \"col\",\n                                                className: \"d-none d-md-block\",\n                                                children: \"#\"\n                                            }),\n                                            (0, $b603G.jsx)(\"th\", {\n                                                scope: \"col\",\n                                                children: (0, $6T66T.t)(\"time\")\n                                            }),\n                                            (0, $b603G.jsx)(\"th\", {\n                                                scope: \"col\",\n                                                children: (0, $6T66T.t)(\"event\")\n                                            }),\n                                            (0, $b603G.jsx)(\"th\", {\n                                                scope: \"col\",\n                                                children: (0, $6T66T.t)(\"main_guest\")\n                                            })\n                                        ]\n                                    })\n                                }),\n                                (0, $b603G.jsx)(\"tbody\", {\n                                    children: (0, $3phDk.schedule)().map(({ time: time, title: title, topic: topic })=>(0, $b603G.jsxs)(\"tr\", {\n                                            children: [\n                                                (0, $b603G.jsx)(\"td\", {\n                                                    className: \"d-none d-md-block\"\n                                                }),\n                                                (0, $b603G.jsx)(\"td\", {\n                                                    className: \"text-nowrap\",\n                                                    children: time\n                                                }),\n                                                (0, $b603G.jsx)(\"td\", {\n                                                    children: title || `\\u{300A}${topic === null || topic === void 0 ? void 0 : topic.title}\\u{300B}`\n                                                }),\n                                                (0, $b603G.jsx)(\"td\", {\n                                                    children: topic === null || topic === void 0 ? void 0 : topic.lecturer.name\n                                                })\n                                            ]\n                                        }, time))\n                                })\n                            ]\n                        })\n                    })\n                ]\n            }),\n            (0, $b603G.jsxs)(\"section\", {\n                id: \"Review\",\n                className: $h58g0.sparked,\n                children: [\n                    (0, $b603G.jsx)(\"h2\", {\n                        className: \"text-center mb-5\",\n                        children: (0, $6T66T.t)(\"past_highlights_review\")\n                    }),\n                    (0, $b603G.jsx)((0, $fonQc.Container), {\n                        children: (0, $b603G.jsx)(\"div\", {\n                            className: `row ${$h58g0.photos}`,\n                            children: (0, $3phDk.review).map(({ title: title }, index)=>(0, $b603G.jsx)(\"div\", {\n                                    className: \"col-md-4\",\n                                    children: (0, $b603G.jsx)((0, $fonQc.Image), {\n                                        fluid: true,\n                                        title: title,\n                                        src: (0, $1PSFd.default)[index]\n                                    })\n                                }, title))\n                        })\n                    })\n                ]\n            }),\n            (0, $b603G.jsxs)(\"section\", {\n                id: \"Address\",\n                className: \"text-center\",\n                children: [\n                    (0, $b603G.jsx)(\"h2\", {\n                        className: \"text-center mb-5\",\n                        children: (0, $6T66T.t)(\"address\")\n                    }),\n                    (0, $b603G.jsxs)((0, $fonQc.Container), {\n                        children: [\n                            (0, $b603G.jsx)(\"p\", {\n                                className: \"text-muted\",\n                                children: (0, $6T66T.t)(\"tianfu_ifc_building4_conference_room\")\n                            }),\n                            (0, $b603G.jsx)((0, $fonQc.Ratio), {\n                                aspectRatio: \"21x9\",\n                                children: (0, $b603G.jsx)(\"iframe\", {\n                                    loading: \"lazy\",\n                                    src: `//uri.amap.com/marker?src=fcc-cdc&callnative=1&position=104.065789,30.582013&name=${(0, $3phDk.title)()}`\n                                })\n                            })\n                        ]\n                    })\n                ]\n            }),\n            (0, $b603G.jsxs)(\"section\", {\n                id: \"Contributor\",\n                className: \"text-center\",\n                children: [\n                    (0, $b603G.jsx)(\"h2\", {\n                        children: (0, $6T66T.t)(\"co_creation_partners\")\n                    }),\n                    (0, $b603G.jsx)((0, $fonQc.Container), {\n                        children: (0, $3phDk.hosts)().map(({ title: title, member: member })=>(0, $b603G.jsxs)(\"div\", {\n                                className: `${$h58g0.contributorGroup} my-4`,\n                                children: [\n                                    (0, $b603G.jsxs)(\"h5\", {\n                                        className: \"py-3\",\n                                        children: [\n                                            title,\n                                            (0, $6T66T.t)(\"organizer\")\n                                        ]\n                                    }),\n                                    (0, $b603G.jsx)((0, $g3Ku0.LogoList), {\n                                        member: member\n                                    })\n                                ]\n                            }, title))\n                    }),\n                    (0, $b603G.jsx)((0, $fonQc.Container), {\n                        children: (0, $b603G.jsx)(\"div\", {\n                            className: `${$h58g0.contributorGroup} my-4`,\n                            children: (0, $3phDk.sponsors)().map(({ title: title, member: member })=>(0, $b603G.jsxs)(\"section\", {\n                                    children: [\n                                        (0, $b603G.jsxs)(\"h5\", {\n                                            className: \"py-3\",\n                                            children: [\n                                                title,\n                                                (0, $6T66T.t)(\"sponsor\")\n                                            ]\n                                        }),\n                                        (0, $b603G.jsx)((0, $g3Ku0.LogoList), {\n                                            member: member\n                                        })\n                                    ]\n                                }, title))\n                        })\n                    }),\n                    (0, $b603G.jsx)((0, $fonQc.Container), {\n                        children: (0, $b603G.jsxs)(\"div\", {\n                            className: `${$h58g0.contributorGroup} my-4`,\n                            children: [\n                                (0, $b603G.jsx)(\"h5\", {\n                                    className: \"py-3\",\n                                    children: (0, $6T66T.t)(\"business_partner\")\n                                }),\n                                (0, $b603G.jsx)((0, $g3Ku0.LogoList), {\n                                    member: (0, $3phDk.partners)\n                                })\n                            ]\n                        })\n                    })\n                ]\n            }),\n            (0, $b603G.jsx)(\"section\", {\n                id: \"CallInAction\",\n                className: $h58g0.sparked,\n                children: (0, $b603G.jsx)((0, $fonQc.Container), {\n                    className: \"text-center\",\n                    children: (0, $b603G.jsx)((0, $fonQc.Button), {\n                        variant: \"primary\",\n                        size: \"lg\",\n                        target: \"_blank\",\n                        href: \"http://fcc-chengdu.mikecrm.com/tFM8Rk8\",\n                        children: (0, $6T66T.t)(\"register_now\")\n                    })\n                })\n            }),\n            (0, $b603G.jsx)(\"footer\", {\n                className: \"pt-4 pb-3 clearfix\",\n                children: (0, $b603G.jsx)((0, $fonQc.Container), {\n                    children: (0, $b603G.jsx)(\"div\", {\n                        className: \"d-none d-md-block\",\n                        children: (0, $b603G.jsx)((0, $fonQc.Nav), {\n                            children: (0, $3phDk.sections)().map(({ href: href, title: title })=>(0, $b603G.jsx)((0, $fonQc.NavLink), {\n                                    href: href,\n                                    children: title\n                                }, title))\n                        })\n                    })\n                })\n            })\n        ]\n    }));\n\n});\nparcelRegister(\"4eJD6\", function(module, exports) {\n/**\n * marked v14.1.4 - a markdown parser\n * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */ /**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */ (function(global, factory) {\n    factory(module.exports);\n})(module.exports, function(exports1) {\n    \"use strict\";\n    /**\n     * Gets the original marked default options.\n     */ function _getDefaults() {\n        return {\n            async: false,\n            breaks: false,\n            extensions: null,\n            gfm: true,\n            hooks: null,\n            pedantic: false,\n            renderer: null,\n            silent: false,\n            tokenizer: null,\n            walkTokens: null\n        };\n    }\n    exports1.defaults = _getDefaults();\n    function changeDefaults(newDefaults) {\n        exports1.defaults = newDefaults;\n    }\n    /**\n     * Helpers\n     */ const escapeTest = /[&<>\"']/;\n    const escapeReplace = new RegExp(escapeTest.source, \"g\");\n    const escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\n    const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, \"g\");\n    const escapeReplacements = {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        '\"': \"&quot;\",\n        \"'\": \"&#39;\"\n    };\n    const getEscapeReplacement = (ch)=>escapeReplacements[ch];\n    function escape$1(html, encode) {\n        if (encode) {\n            if (escapeTest.test(html)) return html.replace(escapeReplace, getEscapeReplacement);\n        } else {\n            if (escapeTestNoEncode.test(html)) return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n        }\n        return html;\n    }\n    const caret = /(^|[^\\[])\\^/g;\n    function edit(regex, opt) {\n        let source = typeof regex === \"string\" ? regex : regex.source;\n        opt = opt || \"\";\n        const obj = {\n            replace: (name, val)=>{\n                let valSource = typeof val === \"string\" ? val : val.source;\n                valSource = valSource.replace(caret, \"$1\");\n                source = source.replace(name, valSource);\n                return obj;\n            },\n            getRegex: ()=>{\n                return new RegExp(source, opt);\n            }\n        };\n        return obj;\n    }\n    function cleanUrl(href) {\n        try {\n            href = encodeURI(href).replace(/%25/g, \"%\");\n        } catch  {\n            return null;\n        }\n        return href;\n    }\n    const noopTest = {\n        exec: ()=>null\n    };\n    function splitCells(tableRow, count) {\n        // ensure that every cell-delimiting pipe has a space\n        // before it to distinguish it from an escaped pipe\n        const row = tableRow.replace(/\\|/g, (match, offset, str)=>{\n            let escaped = false;\n            let curr = offset;\n            while(--curr >= 0 && str[curr] === \"\\\\\")escaped = !escaped;\n            if (escaped) // odd number of slashes means | is escaped\n            // so we leave it alone\n            return \"|\";\n            else // add space before unescaped |\n            return \" |\";\n        }), cells = row.split(/ \\|/);\n        let i = 0;\n        // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n        if (!cells[0].trim()) cells.shift();\n        if (cells.length > 0 && !cells[cells.length - 1].trim()) cells.pop();\n        if (count) {\n            if (cells.length > count) cells.splice(count);\n            else while(cells.length < count)cells.push(\"\");\n        }\n        for(; i < cells.length; i++)// leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(/\\\\\\|/g, \"|\");\n        return cells;\n    }\n    /**\n     * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n     * /c*$/ is vulnerable to REDOS.\n     *\n     * @param str\n     * @param c\n     * @param invert Remove suffix of non-c chars instead. Default falsey.\n     */ function rtrim(str, c, invert) {\n        const l = str.length;\n        if (l === 0) return \"\";\n        // Length of suffix matching the invert condition.\n        let suffLen = 0;\n        // Step left until we fail to match the invert condition.\n        while(suffLen < l){\n            const currChar = str.charAt(l - suffLen - 1);\n            if (currChar === c && !invert) suffLen++;\n            else if (currChar !== c && invert) suffLen++;\n            else break;\n        }\n        return str.slice(0, l - suffLen);\n    }\n    function findClosingBracket(str, b) {\n        if (str.indexOf(b[1]) === -1) return -1;\n        let level = 0;\n        for(let i = 0; i < str.length; i++){\n            if (str[i] === \"\\\\\") i++;\n            else if (str[i] === b[0]) level++;\n            else if (str[i] === b[1]) {\n                level--;\n                if (level < 0) return i;\n            }\n        }\n        return -1;\n    }\n    function outputLink(cap, link, raw, lexer) {\n        const href = link.href;\n        const title = link.title ? escape$1(link.title) : null;\n        const text = cap[1].replace(/\\\\([\\[\\]])/g, \"$1\");\n        if (cap[0].charAt(0) !== \"!\") {\n            lexer.state.inLink = true;\n            const token = {\n                type: \"link\",\n                raw: raw,\n                href: href,\n                title: title,\n                text: text,\n                tokens: lexer.inlineTokens(text)\n            };\n            lexer.state.inLink = false;\n            return token;\n        }\n        return {\n            type: \"image\",\n            raw: raw,\n            href: href,\n            title: title,\n            text: escape$1(text)\n        };\n    }\n    function indentCodeCompensation(raw, text) {\n        const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n        if (matchIndentToCode === null) return text;\n        const indentToCode = matchIndentToCode[1];\n        return text.split(\"\\n\").map((node)=>{\n            const matchIndentInNode = node.match(/^\\s+/);\n            if (matchIndentInNode === null) return node;\n            const [indentInNode] = matchIndentInNode;\n            if (indentInNode.length >= indentToCode.length) return node.slice(indentToCode.length);\n            return node;\n        }).join(\"\\n\");\n    }\n    /**\n     * Tokenizer\n     */ class _Tokenizer {\n        options;\n        rules;\n        lexer;\n        constructor(options){\n            this.options = options || exports1.defaults;\n        }\n        space(src) {\n            const cap = this.rules.block.newline.exec(src);\n            if (cap && cap[0].length > 0) return {\n                type: \"space\",\n                raw: cap[0]\n            };\n        }\n        code(src) {\n            const cap = this.rules.block.code.exec(src);\n            if (cap) {\n                const text = cap[0].replace(/^(?: {1,4}| {0,3}\\t)/gm, \"\");\n                return {\n                    type: \"code\",\n                    raw: cap[0],\n                    codeBlockStyle: \"indented\",\n                    text: !this.options.pedantic ? rtrim(text, \"\\n\") : text\n                };\n            }\n        }\n        fences(src) {\n            const cap = this.rules.block.fences.exec(src);\n            if (cap) {\n                const raw = cap[0];\n                const text = indentCodeCompensation(raw, cap[3] || \"\");\n                return {\n                    type: \"code\",\n                    raw: raw,\n                    lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, \"$1\") : cap[2],\n                    text: text\n                };\n            }\n        }\n        heading(src) {\n            const cap = this.rules.block.heading.exec(src);\n            if (cap) {\n                let text = cap[2].trim();\n                // remove trailing #s\n                if (/#$/.test(text)) {\n                    const trimmed = rtrim(text, \"#\");\n                    if (this.options.pedantic) text = trimmed.trim();\n                    else if (!trimmed || / $/.test(trimmed)) // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n                return {\n                    type: \"heading\",\n                    raw: cap[0],\n                    depth: cap[1].length,\n                    text: text,\n                    tokens: this.lexer.inline(text)\n                };\n            }\n        }\n        hr(src) {\n            const cap = this.rules.block.hr.exec(src);\n            if (cap) return {\n                type: \"hr\",\n                raw: rtrim(cap[0], \"\\n\")\n            };\n        }\n        blockquote(src) {\n            const cap = this.rules.block.blockquote.exec(src);\n            if (cap) {\n                let lines = rtrim(cap[0], \"\\n\").split(\"\\n\");\n                let raw = \"\";\n                let text = \"\";\n                const tokens = [];\n                while(lines.length > 0){\n                    let inBlockquote = false;\n                    const currentLines = [];\n                    let i;\n                    for(i = 0; i < lines.length; i++){\n                        // get lines up to a continuation\n                        if (/^ {0,3}>/.test(lines[i])) {\n                            currentLines.push(lines[i]);\n                            inBlockquote = true;\n                        } else if (!inBlockquote) currentLines.push(lines[i]);\n                        else break;\n                    }\n                    lines = lines.slice(i);\n                    const currentRaw = currentLines.join(\"\\n\");\n                    const currentText = currentRaw// precede setext continuation with 4 spaces so it isn't a setext\n                    .replace(/\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g, \"\\n    $1\").replace(/^ {0,3}>[ \\t]?/gm, \"\");\n                    raw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n                    text = text ? `${text}\\n${currentText}` : currentText;\n                    // parse blockquote lines as top level tokens\n                    // merge paragraphs if this is a continuation\n                    const top = this.lexer.state.top;\n                    this.lexer.state.top = true;\n                    this.lexer.blockTokens(currentText, tokens, true);\n                    this.lexer.state.top = top;\n                    // if there is no continuation then we are done\n                    if (lines.length === 0) break;\n                    const lastToken = tokens[tokens.length - 1];\n                    if (lastToken?.type === \"code\") break;\n                    else if (lastToken?.type === \"blockquote\") {\n                        // include continuation in nested blockquote\n                        const oldToken = lastToken;\n                        const newText = oldToken.raw + \"\\n\" + lines.join(\"\\n\");\n                        const newToken = this.blockquote(newText);\n                        tokens[tokens.length - 1] = newToken;\n                        raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n                        text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n                        break;\n                    } else if (lastToken?.type === \"list\") {\n                        // include continuation in nested list\n                        const oldToken = lastToken;\n                        const newText = oldToken.raw + \"\\n\" + lines.join(\"\\n\");\n                        const newToken = this.list(newText);\n                        tokens[tokens.length - 1] = newToken;\n                        raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n                        text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n                        lines = newText.substring(tokens[tokens.length - 1].raw.length).split(\"\\n\");\n                        continue;\n                    }\n                }\n                return {\n                    type: \"blockquote\",\n                    raw: raw,\n                    tokens: tokens,\n                    text: text\n                };\n            }\n        }\n        list(src) {\n            let cap = this.rules.block.list.exec(src);\n            if (cap) {\n                let bull = cap[1].trim();\n                const isordered = bull.length > 1;\n                const list = {\n                    type: \"list\",\n                    raw: \"\",\n                    ordered: isordered,\n                    start: isordered ? +bull.slice(0, -1) : \"\",\n                    loose: false,\n                    items: []\n                };\n                bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n                if (this.options.pedantic) bull = isordered ? bull : \"[*+-]\";\n                // Get next list item\n                const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n                let endsWithBlankLine = false;\n                // Check if current bullet point can start a new List Item\n                while(src){\n                    let endEarly = false;\n                    let raw = \"\";\n                    let itemContents = \"\";\n                    if (!(cap = itemRegex.exec(src))) break;\n                    if (this.rules.block.hr.test(src)) break;\n                    raw = cap[0];\n                    src = src.substring(raw.length);\n                    let line = cap[2].split(\"\\n\", 1)[0].replace(/^\\t+/, (t)=>\" \".repeat(3 * t.length));\n                    let nextLine = src.split(\"\\n\", 1)[0];\n                    let blankLine = !line.trim();\n                    let indent = 0;\n                    if (this.options.pedantic) {\n                        indent = 2;\n                        itemContents = line.trimStart();\n                    } else if (blankLine) indent = cap[1].length + 1;\n                    else {\n                        indent = cap[2].search(/[^ ]/); // Find first non-space char\n                        indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                        itemContents = line.slice(indent);\n                        indent += cap[1].length;\n                    }\n                    if (blankLine && /^[ \\t]*$/.test(nextLine)) {\n                        raw += nextLine + \"\\n\";\n                        src = src.substring(nextLine.length + 1);\n                        endEarly = true;\n                    }\n                    if (!endEarly) {\n                        const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n                        const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                        const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                        const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n                        const htmlBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, \"i\");\n                        // Check if following lines should be included in List Item\n                        while(src){\n                            const rawLine = src.split(\"\\n\", 1)[0];\n                            let nextLineWithoutTabs;\n                            nextLine = rawLine;\n                            // Re-align to follow commonmark nesting rules\n                            if (this.options.pedantic) {\n                                nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, \"  \");\n                                nextLineWithoutTabs = nextLine;\n                            } else nextLineWithoutTabs = nextLine.replace(/\\t/g, \"    \");\n                            // End list item if found code fences\n                            if (fencesBeginRegex.test(nextLine)) break;\n                            // End list item if found start of new heading\n                            if (headingBeginRegex.test(nextLine)) break;\n                            // End list item if found start of html block\n                            if (htmlBeginRegex.test(nextLine)) break;\n                            // End list item if found start of new bullet\n                            if (nextBulletRegex.test(nextLine)) break;\n                            // Horizontal rule found\n                            if (hrRegex.test(nextLine)) break;\n                            if (nextLineWithoutTabs.search(/[^ ]/) >= indent || !nextLine.trim()) itemContents += \"\\n\" + nextLineWithoutTabs.slice(indent);\n                            else {\n                                // not enough indentation\n                                if (blankLine) break;\n                                // paragraph continuation unless last line was a different block level element\n                                if (line.replace(/\\t/g, \"    \").search(/[^ ]/) >= 4) break;\n                                if (fencesBeginRegex.test(line)) break;\n                                if (headingBeginRegex.test(line)) break;\n                                if (hrRegex.test(line)) break;\n                                itemContents += \"\\n\" + nextLine;\n                            }\n                            if (!blankLine && !nextLine.trim()) blankLine = true;\n                            raw += rawLine + \"\\n\";\n                            src = src.substring(rawLine.length + 1);\n                            line = nextLineWithoutTabs.slice(indent);\n                        }\n                    }\n                    if (!list.loose) {\n                        // If the previous item ended with a blank line, the list is loose\n                        if (endsWithBlankLine) list.loose = true;\n                        else if (/\\n[ \\t]*\\n[ \\t]*$/.test(raw)) endsWithBlankLine = true;\n                    }\n                    let istask = null;\n                    let ischecked;\n                    // Check for task list items\n                    if (this.options.gfm) {\n                        istask = /^\\[[ xX]\\] /.exec(itemContents);\n                        if (istask) {\n                            ischecked = istask[0] !== \"[ ] \";\n                            itemContents = itemContents.replace(/^\\[[ xX]\\] +/, \"\");\n                        }\n                    }\n                    list.items.push({\n                        type: \"list_item\",\n                        raw: raw,\n                        task: !!istask,\n                        checked: ischecked,\n                        loose: false,\n                        text: itemContents,\n                        tokens: []\n                    });\n                    list.raw += raw;\n                }\n                // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n                list.items[list.items.length - 1].raw = list.items[list.items.length - 1].raw.trimEnd();\n                list.items[list.items.length - 1].text = list.items[list.items.length - 1].text.trimEnd();\n                list.raw = list.raw.trimEnd();\n                // Item child tokens handled here at end because we needed to have the final item to trim it first\n                for(let i = 0; i < list.items.length; i++){\n                    this.lexer.state.top = false;\n                    list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                    if (!list.loose) {\n                        // Check if list should be loose\n                        const spacers = list.items[i].tokens.filter((t)=>t.type === \"space\");\n                        const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t)=>/\\n.*\\n/.test(t.raw));\n                        list.loose = hasMultipleLineBreaks;\n                    }\n                }\n                // Set all items to loose if list is loose\n                if (list.loose) for(let i = 0; i < list.items.length; i++)list.items[i].loose = true;\n                return list;\n            }\n        }\n        html(src) {\n            const cap = this.rules.block.html.exec(src);\n            if (cap) {\n                const token = {\n                    type: \"html\",\n                    block: true,\n                    raw: cap[0],\n                    pre: cap[1] === \"pre\" || cap[1] === \"script\" || cap[1] === \"style\",\n                    text: cap[0]\n                };\n                return token;\n            }\n        }\n        def(src) {\n            const cap = this.rules.block.def.exec(src);\n            if (cap) {\n                const tag = cap[1].toLowerCase().replace(/\\s+/g, \" \");\n                const href = cap[2] ? cap[2].replace(/^<(.*)>$/, \"$1\").replace(this.rules.inline.anyPunctuation, \"$1\") : \"\";\n                const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, \"$1\") : cap[3];\n                return {\n                    type: \"def\",\n                    tag: tag,\n                    raw: cap[0],\n                    href: href,\n                    title: title\n                };\n            }\n        }\n        table(src) {\n            const cap = this.rules.block.table.exec(src);\n            if (!cap) return;\n            if (!/[:|]/.test(cap[2])) // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n            return;\n            const headers = splitCells(cap[1]);\n            const aligns = cap[2].replace(/^\\||\\| *$/g, \"\").split(\"|\");\n            const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, \"\").split(\"\\n\") : [];\n            const item = {\n                type: \"table\",\n                raw: cap[0],\n                header: [],\n                align: [],\n                rows: []\n            };\n            if (headers.length !== aligns.length) // header and align columns must be equal, rows can be different.\n            return;\n            for (const align of aligns){\n                if (/^ *-+: *$/.test(align)) item.align.push(\"right\");\n                else if (/^ *:-+: *$/.test(align)) item.align.push(\"center\");\n                else if (/^ *:-+ *$/.test(align)) item.align.push(\"left\");\n                else item.align.push(null);\n            }\n            for(let i = 0; i < headers.length; i++)item.header.push({\n                text: headers[i],\n                tokens: this.lexer.inline(headers[i]),\n                header: true,\n                align: item.align[i]\n            });\n            for (const row of rows)item.rows.push(splitCells(row, item.header.length).map((cell, i)=>{\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell),\n                    header: false,\n                    align: item.align[i]\n                };\n            }));\n            return item;\n        }\n        lheading(src) {\n            const cap = this.rules.block.lheading.exec(src);\n            if (cap) return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[2].charAt(0) === \"=\" ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1])\n            };\n        }\n        paragraph(src) {\n            const cap = this.rules.block.paragraph.exec(src);\n            if (cap) {\n                const text = cap[1].charAt(cap[1].length - 1) === \"\\n\" ? cap[1].slice(0, -1) : cap[1];\n                return {\n                    type: \"paragraph\",\n                    raw: cap[0],\n                    text: text,\n                    tokens: this.lexer.inline(text)\n                };\n            }\n        }\n        text(src) {\n            const cap = this.rules.block.text.exec(src);\n            if (cap) return {\n                type: \"text\",\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0])\n            };\n        }\n        escape(src) {\n            const cap = this.rules.inline.escape.exec(src);\n            if (cap) return {\n                type: \"escape\",\n                raw: cap[0],\n                text: escape$1(cap[1])\n            };\n        }\n        tag(src) {\n            const cap = this.rules.inline.tag.exec(src);\n            if (cap) {\n                if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) this.lexer.state.inLink = true;\n                else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) this.lexer.state.inLink = false;\n                if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) this.lexer.state.inRawBlock = true;\n                else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) this.lexer.state.inRawBlock = false;\n                return {\n                    type: \"html\",\n                    raw: cap[0],\n                    inLink: this.lexer.state.inLink,\n                    inRawBlock: this.lexer.state.inRawBlock,\n                    block: false,\n                    text: cap[0]\n                };\n            }\n        }\n        link(src) {\n            const cap = this.rules.inline.link.exec(src);\n            if (cap) {\n                const trimmedUrl = cap[2].trim();\n                if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                    // commonmark requires matching angle brackets\n                    if (!/>$/.test(trimmedUrl)) return;\n                    // ending angle bracket cannot be escaped\n                    const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), \"\\\\\");\n                    if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) return;\n                } else {\n                    // find closing parenthesis\n                    const lastParenIndex = findClosingBracket(cap[2], \"()\");\n                    if (lastParenIndex > -1) {\n                        const start = cap[0].indexOf(\"!\") === 0 ? 5 : 4;\n                        const linkLen = start + cap[1].length + lastParenIndex;\n                        cap[2] = cap[2].substring(0, lastParenIndex);\n                        cap[0] = cap[0].substring(0, linkLen).trim();\n                        cap[3] = \"\";\n                    }\n                }\n                let href = cap[2];\n                let title = \"\";\n                if (this.options.pedantic) {\n                    // split pedantic href and title\n                    const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n                    if (link) {\n                        href = link[1];\n                        title = link[3];\n                    }\n                } else title = cap[3] ? cap[3].slice(1, -1) : \"\";\n                href = href.trim();\n                if (/^</.test(href)) {\n                    if (this.options.pedantic && !/>$/.test(trimmedUrl)) // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                    else href = href.slice(1, -1);\n                }\n                return outputLink(cap, {\n                    href: href ? href.replace(this.rules.inline.anyPunctuation, \"$1\") : href,\n                    title: title ? title.replace(this.rules.inline.anyPunctuation, \"$1\") : title\n                }, cap[0], this.lexer);\n            }\n        }\n        reflink(src, links) {\n            let cap;\n            if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n                const linkString = (cap[2] || cap[1]).replace(/\\s+/g, \" \");\n                const link = links[linkString.toLowerCase()];\n                if (!link) {\n                    const text = cap[0].charAt(0);\n                    return {\n                        type: \"text\",\n                        raw: text,\n                        text: text\n                    };\n                }\n                return outputLink(cap, link, cap[0], this.lexer);\n            }\n        }\n        emStrong(src, maskedSrc, prevChar = \"\") {\n            let match = this.rules.inline.emStrongLDelim.exec(src);\n            if (!match) return;\n            // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n            if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u)) return;\n            const nextChar = match[1] || match[2] || \"\";\n            if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n                // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n                const lLength = [\n                    ...match[0]\n                ].length - 1;\n                let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n                const endReg = match[0][0] === \"*\" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n                endReg.lastIndex = 0;\n                // Clip maskedSrc to same section of string as src (move to lexer?)\n                maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n                while((match = endReg.exec(maskedSrc)) != null){\n                    rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                    if (!rDelim) continue; // skip single * in __abc*abc__\n                    rLength = [\n                        ...rDelim\n                    ].length;\n                    if (match[3] || match[4]) {\n                        delimTotal += rLength;\n                        continue;\n                    } else if (match[5] || match[6]) {\n                        if (lLength % 3 && !((lLength + rLength) % 3)) {\n                            midDelimTotal += rLength;\n                            continue; // CommonMark Emphasis Rules 9-10\n                        }\n                    }\n                    delimTotal -= rLength;\n                    if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n                    // Remove extra characters. *a*** -> *a*\n                    rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                    // char length can be >1 for unicode characters;\n                    const lastCharLength = [\n                        ...match[0]\n                    ][0].length;\n                    const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                    // Create `em` if smallest delimiter has odd char count. *a***\n                    if (Math.min(lLength, rLength) % 2) {\n                        const text = raw.slice(1, -1);\n                        return {\n                            type: \"em\",\n                            raw: raw,\n                            text: text,\n                            tokens: this.lexer.inlineTokens(text)\n                        };\n                    }\n                    // Create 'strong' if smallest delimiter has even char count. **a***\n                    const text = raw.slice(2, -2);\n                    return {\n                        type: \"strong\",\n                        raw: raw,\n                        text: text,\n                        tokens: this.lexer.inlineTokens(text)\n                    };\n                }\n            }\n        }\n        codespan(src) {\n            const cap = this.rules.inline.code.exec(src);\n            if (cap) {\n                let text = cap[2].replace(/\\n/g, \" \");\n                const hasNonSpaceChars = /[^ ]/.test(text);\n                const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n                if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) text = text.substring(1, text.length - 1);\n                text = escape$1(text, true);\n                return {\n                    type: \"codespan\",\n                    raw: cap[0],\n                    text: text\n                };\n            }\n        }\n        br(src) {\n            const cap = this.rules.inline.br.exec(src);\n            if (cap) return {\n                type: \"br\",\n                raw: cap[0]\n            };\n        }\n        del(src) {\n            const cap = this.rules.inline.del.exec(src);\n            if (cap) return {\n                type: \"del\",\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2])\n            };\n        }\n        autolink(src) {\n            const cap = this.rules.inline.autolink.exec(src);\n            if (cap) {\n                let text, href;\n                if (cap[2] === \"@\") {\n                    text = escape$1(cap[1]);\n                    href = \"mailto:\" + text;\n                } else {\n                    text = escape$1(cap[1]);\n                    href = text;\n                }\n                return {\n                    type: \"link\",\n                    raw: cap[0],\n                    text: text,\n                    href: href,\n                    tokens: [\n                        {\n                            type: \"text\",\n                            raw: text,\n                            text: text\n                        }\n                    ]\n                };\n            }\n        }\n        url(src) {\n            let cap;\n            if (cap = this.rules.inline.url.exec(src)) {\n                let text, href;\n                if (cap[2] === \"@\") {\n                    text = escape$1(cap[0]);\n                    href = \"mailto:\" + text;\n                } else {\n                    // do extended autolink path validation\n                    let prevCapZero;\n                    do {\n                        prevCapZero = cap[0];\n                        cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? \"\";\n                    }while (prevCapZero !== cap[0]);\n                    text = escape$1(cap[0]);\n                    if (cap[1] === \"www.\") href = \"http://\" + cap[0];\n                    else href = cap[0];\n                }\n                return {\n                    type: \"link\",\n                    raw: cap[0],\n                    text: text,\n                    href: href,\n                    tokens: [\n                        {\n                            type: \"text\",\n                            raw: text,\n                            text: text\n                        }\n                    ]\n                };\n            }\n        }\n        inlineText(src) {\n            const cap = this.rules.inline.text.exec(src);\n            if (cap) {\n                let text;\n                if (this.lexer.state.inRawBlock) text = cap[0];\n                else text = escape$1(cap[0]);\n                return {\n                    type: \"text\",\n                    raw: cap[0],\n                    text: text\n                };\n            }\n        }\n    }\n    /**\n     * Block-Level Grammar\n     */ const newline = /^(?:[ \\t]*(?:\\n|$))+/;\n    const blockCode = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/;\n    const fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\n    const hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\n    const heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\n    const bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n    const lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/).replace(/bull/g, bullet) // lists can interrupt\n    .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n    .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n    .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n    .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n    .getRegex();\n    const _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\n    const blockText = /^[^\\n]+/;\n    const _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\n    const def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/).replace(\"label\", _blockLabel).replace(\"title\", /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/).getRegex();\n    const list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/).replace(/bull/g, bullet).getRegex();\n    const _tag = \"address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul\";\n    const _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\n    const html = edit(\"^ {0,3}(?:<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)|comment[^\\\\n]*(\\\\n+|$)|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$)|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$)|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$))\", \"i\").replace(\"comment\", _comment).replace(\"tag\", _tag).replace(\"attribute\", / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\n    const paragraph = edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\") // setext headings don't interrupt commonmark paragraphs\n    .replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n    .replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex();\n    const blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/).replace(\"paragraph\", paragraph).getRegex();\n    /**\n     * Normal Block Grammar\n     */ const blockNormal = {\n        blockquote: blockquote,\n        code: blockCode,\n        def: def,\n        fences: fences,\n        heading: heading,\n        hr: hr,\n        html: html,\n        lheading: lheading,\n        list: list,\n        newline: newline,\n        paragraph: paragraph,\n        table: noopTest,\n        text: blockText\n    };\n    /**\n     * GFM Block Grammar\n     */ const gfmTable = edit(\"^ *([^\\\\n ].*)\\\\n {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)\") // Cells\n    .replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"blockquote\", \" {0,3}>\").replace(\"code\", \"(?: {4}| {0,3}\t)[^\\\\n]\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n    .replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // tables can be interrupted by type (6) html blocks\n    .getRegex();\n    const blockGfm = {\n        ...blockNormal,\n        table: gfmTable,\n        paragraph: edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\") // setext headings don't interrupt commonmark paragraphs\n        .replace(\"table\", gfmTable) // interrupt paragraphs with table\n        .replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n        .replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // pars can be interrupted by type (6) html blocks\n        .getRegex()\n    };\n    /**\n     * Pedantic grammar (original John Gruber's loose markdown specification)\n     */ const blockPedantic = {\n        ...blockNormal,\n        html: edit(\"^ *(?:comment *(?:\\\\n|\\\\s*$)|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)|<tag(?:\\\"[^\\\"]*\\\"|'[^']*'|\\\\s[^'\\\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))\").replace(\"comment\", _comment).replace(/tag/g, \"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b\").getRegex(),\n        def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n        heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n        fences: noopTest,\n        lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n        paragraph: edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" *#{1,6} *[^\\n]\").replace(\"lheading\", lheading).replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"|fences\", \"\").replace(\"|list\", \"\").replace(\"|html\", \"\").replace(\"|tag\", \"\").getRegex()\n    };\n    /**\n     * Inline-Level Grammar\n     */ const escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\n    const inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\n    const br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\n    const inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n    // list of unicode punctuation marks, plus any missing characters from CommonMark spec\n    const _punctuation = \"\\\\p{P}\\\\p{S}\";\n    const punctuation = edit(/^((?![*_])[\\spunctuation])/, \"u\").replace(/punctuation/g, _punctuation).getRegex();\n    // sequences em should skip over [title](link), `code`, <html>\n    const blockSkip = /\\[[^[\\]]*?\\]\\((?:\\\\.|[^\\\\\\(\\)]|\\((?:\\\\.|[^\\\\\\(\\)])*\\))*\\)|`[^`]*?`|<[^<>]*?>/g;\n    const emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, \"u\").replace(/punct/g, _punctuation).getRegex();\n    const emStrongRDelimAst = edit(\"^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])\", \"gu\") // (6) a***a can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation).getRegex();\n    // (6) Not allowed for _\n    const emStrongRDelimUnd = edit(\"^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\\\s]|$)|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])|[\\\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])\", \"gu\") // (5) #___# can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation).getRegex();\n    const anyPunctuation = edit(/\\\\([punct])/, \"gu\").replace(/punct/g, _punctuation).getRegex();\n    const autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/).replace(\"scheme\", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace(\"email\", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();\n    const _inlineComment = edit(_comment).replace(\"(?:-->|$)\", \"-->\").getRegex();\n    const tag = edit(\"^comment|^</[a-zA-Z][\\\\w:-]*\\\\s*>|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>|^<\\\\?[\\\\s\\\\S]*?\\\\?>|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\") // CDATA section\n    .replace(\"comment\", _inlineComment).replace(\"attribute\", /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/).getRegex();\n    const _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n    const link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/).replace(\"label\", _inlineLabel).replace(\"href\", /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/).replace(\"title\", /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/).getRegex();\n    const reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/).replace(\"label\", _inlineLabel).replace(\"ref\", _blockLabel).getRegex();\n    const nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/).replace(\"ref\", _blockLabel).getRegex();\n    const reflinkSearch = edit(\"reflink|nolink(?!\\\\()\", \"g\").replace(\"reflink\", reflink).replace(\"nolink\", nolink).getRegex();\n    /**\n     * Normal Inline Grammar\n     */ const inlineNormal = {\n        _backpedal: noopTest,\n        anyPunctuation: anyPunctuation,\n        autolink: autolink,\n        blockSkip: blockSkip,\n        br: br,\n        code: inlineCode,\n        del: noopTest,\n        emStrongLDelim: emStrongLDelim,\n        emStrongRDelimAst: emStrongRDelimAst,\n        emStrongRDelimUnd: emStrongRDelimUnd,\n        escape: escape,\n        link: link,\n        nolink: nolink,\n        punctuation: punctuation,\n        reflink: reflink,\n        reflinkSearch: reflinkSearch,\n        tag: tag,\n        text: inlineText,\n        url: noopTest\n    };\n    /**\n     * Pedantic Inline Grammar\n     */ const inlinePedantic = {\n        ...inlineNormal,\n        link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace(\"label\", _inlineLabel).getRegex(),\n        reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace(\"label\", _inlineLabel).getRegex()\n    };\n    /**\n     * GFM Inline Grammar\n     */ const inlineGfm = {\n        ...inlineNormal,\n        escape: edit(escape).replace(\"])\", \"~|])\").getRegex(),\n        url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, \"i\").replace(\"email\", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),\n        _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n        del: /^(~~?)(?=[^\\s~])((?:\\\\.|[^\\\\])*?(?:\\\\.|[^\\s~\\\\]))\\1(?=[^~]|$)/,\n        text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n    };\n    /**\n     * GFM + Line Breaks Inline Grammar\n     */ const inlineBreaks = {\n        ...inlineGfm,\n        br: edit(br).replace(\"{2,}\", \"*\").getRegex(),\n        text: edit(inlineGfm.text).replace(\"\\\\b_\", \"\\\\b_| {2,}\\\\n\").replace(/\\{2,\\}/g, \"*\").getRegex()\n    };\n    /**\n     * exports\n     */ const block = {\n        normal: blockNormal,\n        gfm: blockGfm,\n        pedantic: blockPedantic\n    };\n    const inline = {\n        normal: inlineNormal,\n        gfm: inlineGfm,\n        breaks: inlineBreaks,\n        pedantic: inlinePedantic\n    };\n    /**\n     * Block Lexer\n     */ class _Lexer {\n        tokens;\n        options;\n        state;\n        tokenizer;\n        inlineQueue;\n        constructor(options){\n            // TokenList cannot be created in one go\n            this.tokens = [];\n            this.tokens.links = Object.create(null);\n            this.options = options || exports1.defaults;\n            this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n            this.tokenizer = this.options.tokenizer;\n            this.tokenizer.options = this.options;\n            this.tokenizer.lexer = this;\n            this.inlineQueue = [];\n            this.state = {\n                inLink: false,\n                inRawBlock: false,\n                top: true\n            };\n            const rules = {\n                block: block.normal,\n                inline: inline.normal\n            };\n            if (this.options.pedantic) {\n                rules.block = block.pedantic;\n                rules.inline = inline.pedantic;\n            } else if (this.options.gfm) {\n                rules.block = block.gfm;\n                if (this.options.breaks) rules.inline = inline.breaks;\n                else rules.inline = inline.gfm;\n            }\n            this.tokenizer.rules = rules;\n        }\n        /**\n         * Expose Rules\n         */ static get rules() {\n            return {\n                block: block,\n                inline: inline\n            };\n        }\n        /**\n         * Static Lex Method\n         */ static lex(src, options) {\n            const lexer = new _Lexer(options);\n            return lexer.lex(src);\n        }\n        /**\n         * Static Lex Inline Method\n         */ static lexInline(src, options) {\n            const lexer = new _Lexer(options);\n            return lexer.inlineTokens(src);\n        }\n        /**\n         * Preprocessing\n         */ lex(src) {\n            src = src.replace(/\\r\\n|\\r/g, \"\\n\");\n            this.blockTokens(src, this.tokens);\n            for(let i = 0; i < this.inlineQueue.length; i++){\n                const next = this.inlineQueue[i];\n                this.inlineTokens(next.src, next.tokens);\n            }\n            this.inlineQueue = [];\n            return this.tokens;\n        }\n        blockTokens(src, tokens = [], lastParagraphClipped = false) {\n            if (this.options.pedantic) src = src.replace(/\\t/g, \"    \").replace(/^ +$/gm, \"\");\n            let token;\n            let lastToken;\n            let cutSrc;\n            while(src){\n                if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer)=>{\n                    if (token = extTokenizer.call({\n                        lexer: this\n                    }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) continue;\n                // newline\n                if (token = this.tokenizer.space(src)) {\n                    src = src.substring(token.raw.length);\n                    if (token.raw.length === 1 && tokens.length > 0) // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    tokens[tokens.length - 1].raw += \"\\n\";\n                    else tokens.push(token);\n                    continue;\n                }\n                // code\n                if (token = this.tokenizer.code(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    // An indented code block cannot interrupt a paragraph.\n                    if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                        lastToken.raw += \"\\n\" + token.raw;\n                        lastToken.text += \"\\n\" + token.text;\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    } else tokens.push(token);\n                    continue;\n                }\n                // fences\n                if (token = this.tokenizer.fences(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // heading\n                if (token = this.tokenizer.heading(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // hr\n                if (token = this.tokenizer.hr(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // blockquote\n                if (token = this.tokenizer.blockquote(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // list\n                if (token = this.tokenizer.list(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // html\n                if (token = this.tokenizer.html(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // def\n                if (token = this.tokenizer.def(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                        lastToken.raw += \"\\n\" + token.raw;\n                        lastToken.text += \"\\n\" + token.raw;\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    } else if (!this.tokens.links[token.tag]) this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title\n                    };\n                    continue;\n                }\n                // table (gfm)\n                if (token = this.tokenizer.table(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // lheading\n                if (token = this.tokenizer.lheading(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // top-level paragraph\n                // prevent paragraph consuming extensions by clipping 'src' to extension start\n                cutSrc = src;\n                if (this.options.extensions && this.options.extensions.startBlock) {\n                    let startIndex = Infinity;\n                    const tempSrc = src.slice(1);\n                    let tempStart;\n                    this.options.extensions.startBlock.forEach((getStartIndex)=>{\n                        tempStart = getStartIndex.call({\n                            lexer: this\n                        }, tempSrc);\n                        if (typeof tempStart === \"number\" && tempStart >= 0) startIndex = Math.min(startIndex, tempStart);\n                    });\n                    if (startIndex < Infinity && startIndex >= 0) cutSrc = src.substring(0, startIndex + 1);\n                }\n                if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastParagraphClipped && lastToken?.type === \"paragraph\") {\n                        lastToken.raw += \"\\n\" + token.raw;\n                        lastToken.text += \"\\n\" + token.text;\n                        this.inlineQueue.pop();\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    } else tokens.push(token);\n                    lastParagraphClipped = cutSrc.length !== src.length;\n                    src = src.substring(token.raw.length);\n                    continue;\n                }\n                // text\n                if (token = this.tokenizer.text(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && lastToken.type === \"text\") {\n                        lastToken.raw += \"\\n\" + token.raw;\n                        lastToken.text += \"\\n\" + token.text;\n                        this.inlineQueue.pop();\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    } else tokens.push(token);\n                    continue;\n                }\n                if (src) {\n                    const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        break;\n                    } else throw new Error(errMsg);\n                }\n            }\n            this.state.top = true;\n            return tokens;\n        }\n        inline(src, tokens = []) {\n            this.inlineQueue.push({\n                src: src,\n                tokens: tokens\n            });\n            return tokens;\n        }\n        /**\n         * Lexing/Compiling\n         */ inlineTokens(src, tokens = []) {\n            let token, lastToken, cutSrc;\n            // String with links masked to avoid interference with em and strong\n            let maskedSrc = src;\n            let match;\n            let keepPrevChar, prevChar;\n            // Mask out reflinks\n            if (this.tokens.links) {\n                const links = Object.keys(this.tokens.links);\n                if (links.length > 0) {\n                    while((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null)if (links.includes(match[0].slice(match[0].lastIndexOf(\"[\") + 1, -1))) maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                }\n            }\n            // Mask out other blocks\n            while((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null)maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n            // Mask out escaped characters\n            while((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null)maskedSrc = maskedSrc.slice(0, match.index) + \"++\" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n            while(src){\n                if (!keepPrevChar) prevChar = \"\";\n                keepPrevChar = false;\n                // extensions\n                if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer)=>{\n                    if (token = extTokenizer.call({\n                        lexer: this\n                    }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) continue;\n                // escape\n                if (token = this.tokenizer.escape(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // tag\n                if (token = this.tokenizer.tag(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    } else tokens.push(token);\n                    continue;\n                }\n                // link\n                if (token = this.tokenizer.link(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // reflink, nolink\n                if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    } else tokens.push(token);\n                    continue;\n                }\n                // em & strong\n                if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // code\n                if (token = this.tokenizer.codespan(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // br\n                if (token = this.tokenizer.br(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // del (gfm)\n                if (token = this.tokenizer.del(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // autolink\n                if (token = this.tokenizer.autolink(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // url (gfm)\n                if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // text\n                // prevent inlineText consuming extensions by clipping 'src' to extension start\n                cutSrc = src;\n                if (this.options.extensions && this.options.extensions.startInline) {\n                    let startIndex = Infinity;\n                    const tempSrc = src.slice(1);\n                    let tempStart;\n                    this.options.extensions.startInline.forEach((getStartIndex)=>{\n                        tempStart = getStartIndex.call({\n                            lexer: this\n                        }, tempSrc);\n                        if (typeof tempStart === \"number\" && tempStart >= 0) startIndex = Math.min(startIndex, tempStart);\n                    });\n                    if (startIndex < Infinity && startIndex >= 0) cutSrc = src.substring(0, startIndex + 1);\n                }\n                if (token = this.tokenizer.inlineText(cutSrc)) {\n                    src = src.substring(token.raw.length);\n                    if (token.raw.slice(-1) !== \"_\") prevChar = token.raw.slice(-1);\n                    keepPrevChar = true;\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && lastToken.type === \"text\") {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    } else tokens.push(token);\n                    continue;\n                }\n                if (src) {\n                    const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        break;\n                    } else throw new Error(errMsg);\n                }\n            }\n            return tokens;\n        }\n    }\n    /**\n     * Renderer\n     */ class _Renderer {\n        options;\n        parser;\n        constructor(options){\n            this.options = options || exports1.defaults;\n        }\n        space(token) {\n            return \"\";\n        }\n        code({ text: text, lang: lang, escaped: escaped }) {\n            const langString = (lang || \"\").match(/^\\S*/)?.[0];\n            const code = text.replace(/\\n$/, \"\") + \"\\n\";\n            if (!langString) return \"<pre><code>\" + (escaped ? code : escape$1(code, true)) + \"</code></pre>\\n\";\n            return '<pre><code class=\"language-' + escape$1(langString) + '\">' + (escaped ? code : escape$1(code, true)) + \"</code></pre>\\n\";\n        }\n        blockquote({ tokens: tokens }) {\n            const body = this.parser.parse(tokens);\n            return `<blockquote>\\n${body}</blockquote>\\n`;\n        }\n        html({ text: text }) {\n            return text;\n        }\n        heading({ tokens: tokens, depth: depth }) {\n            return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n`;\n        }\n        hr(token) {\n            return \"<hr>\\n\";\n        }\n        list(token) {\n            const ordered = token.ordered;\n            const start = token.start;\n            let body = \"\";\n            for(let j = 0; j < token.items.length; j++){\n                const item = token.items[j];\n                body += this.listitem(item);\n            }\n            const type = ordered ? \"ol\" : \"ul\";\n            const startAttr = ordered && start !== 1 ? ' start=\"' + start + '\"' : \"\";\n            return \"<\" + type + startAttr + \">\\n\" + body + \"</\" + type + \">\\n\";\n        }\n        listitem(item) {\n            let itemBody = \"\";\n            if (item.task) {\n                const checkbox = this.checkbox({\n                    checked: !!item.checked\n                });\n                if (item.loose) {\n                    if (item.tokens.length > 0 && item.tokens[0].type === \"paragraph\") {\n                        item.tokens[0].text = checkbox + \" \" + item.tokens[0].text;\n                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === \"text\") item.tokens[0].tokens[0].text = checkbox + \" \" + item.tokens[0].tokens[0].text;\n                    } else item.tokens.unshift({\n                        type: \"text\",\n                        raw: checkbox + \" \",\n                        text: checkbox + \" \"\n                    });\n                } else itemBody += checkbox + \" \";\n            }\n            itemBody += this.parser.parse(item.tokens, !!item.loose);\n            return `<li>${itemBody}</li>\\n`;\n        }\n        checkbox({ checked: checked }) {\n            return \"<input \" + (checked ? 'checked=\"\" ' : \"\") + 'disabled=\"\" type=\"checkbox\">';\n        }\n        paragraph({ tokens: tokens }) {\n            return `<p>${this.parser.parseInline(tokens)}</p>\\n`;\n        }\n        table(token) {\n            let header = \"\";\n            // header\n            let cell = \"\";\n            for(let j = 0; j < token.header.length; j++)cell += this.tablecell(token.header[j]);\n            header += this.tablerow({\n                text: cell\n            });\n            let body = \"\";\n            for(let j = 0; j < token.rows.length; j++){\n                const row = token.rows[j];\n                cell = \"\";\n                for(let k = 0; k < row.length; k++)cell += this.tablecell(row[k]);\n                body += this.tablerow({\n                    text: cell\n                });\n            }\n            if (body) body = `<tbody>${body}</tbody>`;\n            return \"<table>\\n<thead>\\n\" + header + \"</thead>\\n\" + body + \"</table>\\n\";\n        }\n        tablerow({ text: text }) {\n            return `<tr>\\n${text}</tr>\\n`;\n        }\n        tablecell(token) {\n            const content = this.parser.parseInline(token.tokens);\n            const type = token.header ? \"th\" : \"td\";\n            const tag = token.align ? `<${type} align=\"${token.align}\">` : `<${type}>`;\n            return tag + content + `</${type}>\\n`;\n        }\n        /**\n         * span level renderer\n         */ strong({ tokens: tokens }) {\n            return `<strong>${this.parser.parseInline(tokens)}</strong>`;\n        }\n        em({ tokens: tokens }) {\n            return `<em>${this.parser.parseInline(tokens)}</em>`;\n        }\n        codespan({ text: text }) {\n            return `<code>${text}</code>`;\n        }\n        br(token) {\n            return \"<br>\";\n        }\n        del({ tokens: tokens }) {\n            return `<del>${this.parser.parseInline(tokens)}</del>`;\n        }\n        link({ href: href, title: title, tokens: tokens }) {\n            const text = this.parser.parseInline(tokens);\n            const cleanHref = cleanUrl(href);\n            if (cleanHref === null) return text;\n            href = cleanHref;\n            let out = '<a href=\"' + href + '\"';\n            if (title) out += ' title=\"' + title + '\"';\n            out += \">\" + text + \"</a>\";\n            return out;\n        }\n        image({ href: href, title: title, text: text }) {\n            const cleanHref = cleanUrl(href);\n            if (cleanHref === null) return text;\n            href = cleanHref;\n            let out = `<img src=\"${href}\" alt=\"${text}\"`;\n            if (title) out += ` title=\"${title}\"`;\n            out += \">\";\n            return out;\n        }\n        text(token) {\n            return \"tokens\" in token && token.tokens ? this.parser.parseInline(token.tokens) : token.text;\n        }\n    }\n    /**\n     * TextRenderer\n     * returns only the textual part of the token\n     */ class _TextRenderer {\n        // no need for block level renderers\n        strong({ text: text }) {\n            return text;\n        }\n        em({ text: text }) {\n            return text;\n        }\n        codespan({ text: text }) {\n            return text;\n        }\n        del({ text: text }) {\n            return text;\n        }\n        html({ text: text }) {\n            return text;\n        }\n        text({ text: text }) {\n            return text;\n        }\n        link({ text: text }) {\n            return \"\" + text;\n        }\n        image({ text: text }) {\n            return \"\" + text;\n        }\n        br() {\n            return \"\";\n        }\n    }\n    /**\n     * Parsing & Compiling\n     */ class _Parser {\n        options;\n        renderer;\n        textRenderer;\n        constructor(options){\n            this.options = options || exports1.defaults;\n            this.options.renderer = this.options.renderer || new _Renderer();\n            this.renderer = this.options.renderer;\n            this.renderer.options = this.options;\n            this.renderer.parser = this;\n            this.textRenderer = new _TextRenderer();\n        }\n        /**\n         * Static Parse Method\n         */ static parse(tokens, options) {\n            const parser = new _Parser(options);\n            return parser.parse(tokens);\n        }\n        /**\n         * Static Parse Inline Method\n         */ static parseInline(tokens, options) {\n            const parser = new _Parser(options);\n            return parser.parseInline(tokens);\n        }\n        /**\n         * Parse Loop\n         */ parse(tokens, top = true) {\n            let out = \"\";\n            for(let i = 0; i < tokens.length; i++){\n                const anyToken = tokens[i];\n                // Run any renderer extensions\n                if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {\n                    const genericToken = anyToken;\n                    const ret = this.options.extensions.renderers[genericToken.type].call({\n                        parser: this\n                    }, genericToken);\n                    if (ret !== false || ![\n                        \"space\",\n                        \"hr\",\n                        \"heading\",\n                        \"code\",\n                        \"table\",\n                        \"blockquote\",\n                        \"list\",\n                        \"html\",\n                        \"paragraph\",\n                        \"text\"\n                    ].includes(genericToken.type)) {\n                        out += ret || \"\";\n                        continue;\n                    }\n                }\n                const token = anyToken;\n                switch(token.type){\n                    case \"space\":\n                        out += this.renderer.space(token);\n                        continue;\n                    case \"hr\":\n                        out += this.renderer.hr(token);\n                        continue;\n                    case \"heading\":\n                        out += this.renderer.heading(token);\n                        continue;\n                    case \"code\":\n                        out += this.renderer.code(token);\n                        continue;\n                    case \"table\":\n                        out += this.renderer.table(token);\n                        continue;\n                    case \"blockquote\":\n                        out += this.renderer.blockquote(token);\n                        continue;\n                    case \"list\":\n                        out += this.renderer.list(token);\n                        continue;\n                    case \"html\":\n                        out += this.renderer.html(token);\n                        continue;\n                    case \"paragraph\":\n                        out += this.renderer.paragraph(token);\n                        continue;\n                    case \"text\":\n                        {\n                            let textToken = token;\n                            let body = this.renderer.text(textToken);\n                            while(i + 1 < tokens.length && tokens[i + 1].type === \"text\"){\n                                textToken = tokens[++i];\n                                body += \"\\n\" + this.renderer.text(textToken);\n                            }\n                            if (top) out += this.renderer.paragraph({\n                                type: \"paragraph\",\n                                raw: body,\n                                text: body,\n                                tokens: [\n                                    {\n                                        type: \"text\",\n                                        raw: body,\n                                        text: body\n                                    }\n                                ]\n                            });\n                            else out += body;\n                            continue;\n                        }\n                    default:\n                        {\n                            const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                            if (this.options.silent) {\n                                console.error(errMsg);\n                                return \"\";\n                            } else throw new Error(errMsg);\n                        }\n                }\n            }\n            return out;\n        }\n        /**\n         * Parse Inline Tokens\n         */ parseInline(tokens, renderer) {\n            renderer = renderer || this.renderer;\n            let out = \"\";\n            for(let i = 0; i < tokens.length; i++){\n                const anyToken = tokens[i];\n                // Run any renderer extensions\n                if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {\n                    const ret = this.options.extensions.renderers[anyToken.type].call({\n                        parser: this\n                    }, anyToken);\n                    if (ret !== false || ![\n                        \"escape\",\n                        \"html\",\n                        \"link\",\n                        \"image\",\n                        \"strong\",\n                        \"em\",\n                        \"codespan\",\n                        \"br\",\n                        \"del\",\n                        \"text\"\n                    ].includes(anyToken.type)) {\n                        out += ret || \"\";\n                        continue;\n                    }\n                }\n                const token = anyToken;\n                switch(token.type){\n                    case \"escape\":\n                        out += renderer.text(token);\n                        break;\n                    case \"html\":\n                        out += renderer.html(token);\n                        break;\n                    case \"link\":\n                        out += renderer.link(token);\n                        break;\n                    case \"image\":\n                        out += renderer.image(token);\n                        break;\n                    case \"strong\":\n                        out += renderer.strong(token);\n                        break;\n                    case \"em\":\n                        out += renderer.em(token);\n                        break;\n                    case \"codespan\":\n                        out += renderer.codespan(token);\n                        break;\n                    case \"br\":\n                        out += renderer.br(token);\n                        break;\n                    case \"del\":\n                        out += renderer.del(token);\n                        break;\n                    case \"text\":\n                        out += renderer.text(token);\n                        break;\n                    default:\n                        {\n                            const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                            if (this.options.silent) {\n                                console.error(errMsg);\n                                return \"\";\n                            } else throw new Error(errMsg);\n                        }\n                }\n            }\n            return out;\n        }\n    }\n    class _Hooks {\n        options;\n        block;\n        constructor(options){\n            this.options = options || exports1.defaults;\n        }\n        static passThroughHooks = new Set([\n            \"preprocess\",\n            \"postprocess\",\n            \"processAllTokens\"\n        ]);\n        /**\n         * Process markdown before marked\n         */ preprocess(markdown) {\n            return markdown;\n        }\n        /**\n         * Process HTML after marked is finished\n         */ postprocess(html) {\n            return html;\n        }\n        /**\n         * Process all tokens before walk tokens\n         */ processAllTokens(tokens) {\n            return tokens;\n        }\n        /**\n         * Provide function to tokenize markdown\n         */ provideLexer() {\n            return this.block ? _Lexer.lex : _Lexer.lexInline;\n        }\n        /**\n         * Provide function to parse tokens\n         */ provideParser() {\n            return this.block ? _Parser.parse : _Parser.parseInline;\n        }\n    }\n    class Marked {\n        defaults = _getDefaults();\n        options = this.setOptions;\n        parse = this.parseMarkdown(true);\n        parseInline = this.parseMarkdown(false);\n        Parser = _Parser;\n        Renderer = _Renderer;\n        TextRenderer = _TextRenderer;\n        Lexer = _Lexer;\n        Tokenizer = _Tokenizer;\n        Hooks = _Hooks;\n        constructor(...args){\n            this.use(...args);\n        }\n        /**\n         * Run callback for every token\n         */ walkTokens(tokens, callback) {\n            let values = [];\n            for (const token of tokens){\n                values = values.concat(callback.call(this, token));\n                switch(token.type){\n                    case \"table\":\n                        {\n                            const tableToken = token;\n                            for (const cell of tableToken.header)values = values.concat(this.walkTokens(cell.tokens, callback));\n                            for (const row of tableToken.rows)for (const cell of row)values = values.concat(this.walkTokens(cell.tokens, callback));\n                            break;\n                        }\n                    case \"list\":\n                        {\n                            const listToken = token;\n                            values = values.concat(this.walkTokens(listToken.items, callback));\n                            break;\n                        }\n                    default:\n                        {\n                            const genericToken = token;\n                            if (this.defaults.extensions?.childTokens?.[genericToken.type]) this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens)=>{\n                                const tokens = genericToken[childTokens].flat(Infinity);\n                                values = values.concat(this.walkTokens(tokens, callback));\n                            });\n                            else if (genericToken.tokens) values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                        }\n                }\n            }\n            return values;\n        }\n        use(...args) {\n            const extensions = this.defaults.extensions || {\n                renderers: {},\n                childTokens: {}\n            };\n            args.forEach((pack)=>{\n                // copy options to new object\n                const opts = {\n                    ...pack\n                };\n                // set async to true if it was set to true before\n                opts.async = this.defaults.async || opts.async || false;\n                // ==-- Parse \"addon\" extensions --== //\n                if (pack.extensions) {\n                    pack.extensions.forEach((ext)=>{\n                        if (!ext.name) throw new Error(\"extension name required\");\n                        if (\"renderer\" in ext) {\n                            const prevRenderer = extensions.renderers[ext.name];\n                            if (prevRenderer) // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function(...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) ret = prevRenderer.apply(this, args);\n                                return ret;\n                            };\n                            else extensions.renderers[ext.name] = ext.renderer;\n                        }\n                        if (\"tokenizer\" in ext) {\n                            if (!ext.level || ext.level !== \"block\" && ext.level !== \"inline\") throw new Error(\"extension level must be 'block' or 'inline'\");\n                            const extLevel = extensions[ext.level];\n                            if (extLevel) extLevel.unshift(ext.tokenizer);\n                            else extensions[ext.level] = [\n                                ext.tokenizer\n                            ];\n                            if (ext.start) {\n                                if (ext.level === \"block\") {\n                                    if (extensions.startBlock) extensions.startBlock.push(ext.start);\n                                    else extensions.startBlock = [\n                                        ext.start\n                                    ];\n                                } else if (ext.level === \"inline\") {\n                                    if (extensions.startInline) extensions.startInline.push(ext.start);\n                                    else extensions.startInline = [\n                                        ext.start\n                                    ];\n                                }\n                            }\n                        }\n                        if (\"childTokens\" in ext && ext.childTokens) extensions.childTokens[ext.name] = ext.childTokens;\n                    });\n                    opts.extensions = extensions;\n                }\n                // ==-- Parse \"overwrite\" extensions --== //\n                if (pack.renderer) {\n                    const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                    for(const prop in pack.renderer){\n                        if (!(prop in renderer)) throw new Error(`renderer '${prop}' does not exist`);\n                        if ([\n                            \"options\",\n                            \"parser\"\n                        ].includes(prop)) continue;\n                        const rendererProp = prop;\n                        const rendererFunc = pack.renderer[rendererProp];\n                        const prevRenderer = renderer[rendererProp];\n                        // Replace renderer with func to run extension, but fall back if false\n                        renderer[rendererProp] = (...args)=>{\n                            let ret = rendererFunc.apply(renderer, args);\n                            if (ret === false) ret = prevRenderer.apply(renderer, args);\n                            return ret || \"\";\n                        };\n                    }\n                    opts.renderer = renderer;\n                }\n                if (pack.tokenizer) {\n                    const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                    for(const prop in pack.tokenizer){\n                        if (!(prop in tokenizer)) throw new Error(`tokenizer '${prop}' does not exist`);\n                        if ([\n                            \"options\",\n                            \"rules\",\n                            \"lexer\"\n                        ].includes(prop)) continue;\n                        const tokenizerProp = prop;\n                        const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                        const prevTokenizer = tokenizer[tokenizerProp];\n                        // Replace tokenizer with func to run extension, but fall back if false\n                        // @ts-expect-error cannot type tokenizer function dynamically\n                        tokenizer[tokenizerProp] = (...args)=>{\n                            let ret = tokenizerFunc.apply(tokenizer, args);\n                            if (ret === false) ret = prevTokenizer.apply(tokenizer, args);\n                            return ret;\n                        };\n                    }\n                    opts.tokenizer = tokenizer;\n                }\n                // ==-- Parse Hooks extensions --== //\n                if (pack.hooks) {\n                    const hooks = this.defaults.hooks || new _Hooks();\n                    for(const prop in pack.hooks){\n                        if (!(prop in hooks)) throw new Error(`hook '${prop}' does not exist`);\n                        if ([\n                            \"options\",\n                            \"block\"\n                        ].includes(prop)) continue;\n                        const hooksProp = prop;\n                        const hooksFunc = pack.hooks[hooksProp];\n                        const prevHook = hooks[hooksProp];\n                        if (_Hooks.passThroughHooks.has(prop)) // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (arg)=>{\n                            if (this.defaults.async) return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret)=>{\n                                return prevHook.call(hooks, ret);\n                            });\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                        else // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (...args)=>{\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) ret = prevHook.apply(hooks, args);\n                            return ret;\n                        };\n                    }\n                    opts.hooks = hooks;\n                }\n                // ==-- Parse WalkTokens extensions --== //\n                if (pack.walkTokens) {\n                    const walkTokens = this.defaults.walkTokens;\n                    const packWalktokens = pack.walkTokens;\n                    opts.walkTokens = function(token) {\n                        let values = [];\n                        values.push(packWalktokens.call(this, token));\n                        if (walkTokens) values = values.concat(walkTokens.call(this, token));\n                        return values;\n                    };\n                }\n                this.defaults = {\n                    ...this.defaults,\n                    ...opts\n                };\n            });\n            return this;\n        }\n        setOptions(opt) {\n            this.defaults = {\n                ...this.defaults,\n                ...opt\n            };\n            return this;\n        }\n        lexer(src, options) {\n            return _Lexer.lex(src, options ?? this.defaults);\n        }\n        parser(tokens, options) {\n            return _Parser.parse(tokens, options ?? this.defaults);\n        }\n        parseMarkdown(blockType) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const parse = (src, options)=>{\n                const origOpt = {\n                    ...options\n                };\n                const opt = {\n                    ...this.defaults,\n                    ...origOpt\n                };\n                const throwError = this.onError(!!opt.silent, !!opt.async);\n                // throw error if an extension set async to true but parse was called with async: false\n                if (this.defaults.async === true && origOpt.async === false) return throwError(new Error(\"marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.\"));\n                // throw error in case of non string input\n                if (typeof src === \"undefined\" || src === null) return throwError(new Error(\"marked(): input parameter is undefined or null\"));\n                if (typeof src !== \"string\") return throwError(new Error(\"marked(): input parameter is of type \" + Object.prototype.toString.call(src) + \", string expected\"));\n                if (opt.hooks) {\n                    opt.hooks.options = opt;\n                    opt.hooks.block = blockType;\n                }\n                const lexer = opt.hooks ? opt.hooks.provideLexer() : blockType ? _Lexer.lex : _Lexer.lexInline;\n                const parser = opt.hooks ? opt.hooks.provideParser() : blockType ? _Parser.parse : _Parser.parseInline;\n                if (opt.async) return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src)=>lexer(src, opt)).then((tokens)=>opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens)=>opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(()=>tokens) : tokens).then((tokens)=>parser(tokens, opt)).then((html)=>opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);\n                try {\n                    if (opt.hooks) src = opt.hooks.preprocess(src);\n                    let tokens = lexer(src, opt);\n                    if (opt.hooks) tokens = opt.hooks.processAllTokens(tokens);\n                    if (opt.walkTokens) this.walkTokens(tokens, opt.walkTokens);\n                    let html = parser(tokens, opt);\n                    if (opt.hooks) html = opt.hooks.postprocess(html);\n                    return html;\n                } catch (e) {\n                    return throwError(e);\n                }\n            };\n            return parse;\n        }\n        onError(silent, async) {\n            return (e)=>{\n                e.message += \"\\nPlease report this to https://github.com/markedjs/marked.\";\n                if (silent) {\n                    const msg = \"<p>An error occurred:</p><pre>\" + escape$1(e.message + \"\", true) + \"</pre>\";\n                    if (async) return Promise.resolve(msg);\n                    return msg;\n                }\n                if (async) return Promise.reject(e);\n                throw e;\n            };\n        }\n    }\n    const markedInstance = new Marked();\n    function marked(src, opt) {\n        return markedInstance.parse(src, opt);\n    }\n    /**\n     * Sets the default options.\n     *\n     * @param options Hash of options\n     */ marked.options = marked.setOptions = function(options) {\n        markedInstance.setOptions(options);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n    /**\n     * Gets the original marked default options.\n     */ marked.getDefaults = _getDefaults;\n    marked.defaults = exports1.defaults;\n    /**\n     * Use Extension\n     */ marked.use = function(...args) {\n        markedInstance.use(...args);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n    /**\n     * Run callback for every token\n     */ marked.walkTokens = function(tokens, callback) {\n        return markedInstance.walkTokens(tokens, callback);\n    };\n    /**\n     * Compiles markdown to HTML without enclosing `p` tag.\n     *\n     * @param src String of markdown source to be compiled\n     * @param options Hash of options\n     * @return String of compiled HTML\n     */ marked.parseInline = markedInstance.parseInline;\n    /**\n     * Expose\n     */ marked.Parser = _Parser;\n    marked.parser = _Parser.parse;\n    marked.Renderer = _Renderer;\n    marked.TextRenderer = _TextRenderer;\n    marked.Lexer = _Lexer;\n    marked.lexer = _Lexer.lex;\n    marked.Tokenizer = _Tokenizer;\n    marked.Hooks = _Hooks;\n    marked.parse = marked;\n    const options = marked.options;\n    const setOptions = marked.setOptions;\n    const use = marked.use;\n    const walkTokens = marked.walkTokens;\n    const parseInline = marked.parseInline;\n    const parse = marked;\n    const parser = _Parser.parse;\n    const lexer = _Lexer.lex;\n    exports1.Hooks = _Hooks;\n    exports1.Lexer = _Lexer;\n    exports1.Marked = Marked;\n    exports1.Parser = _Parser;\n    exports1.Renderer = _Renderer;\n    exports1.TextRenderer = _TextRenderer;\n    exports1.Tokenizer = _Tokenizer;\n    exports1.getDefaults = _getDefaults;\n    exports1.lexer = lexer;\n    exports1.marked = marked;\n    exports1.options = options;\n    exports1.parse = parse;\n    exports1.parseInline = parseInline;\n    exports1.parser = parser;\n    exports1.setOptions = setOptions;\n    exports1.use = use;\n    exports1.walkTokens = walkTokens;\n});\n\n});\n\nparcelRegister(\"6rYRn\", function(module, exports) {\n\n$parcel$export(module.exports, \"TopNavBar\", () => $4b24793a4b0f2663$export$febf71ca481883cc);\n\nvar $b603G = parcelRequire(\"b603G\");\n\nvar $fonQc = parcelRequire(\"fonQc\");\n\nvar $89MmN = parcelRequire(\"89MmN\");\n\nvar $6T66T = parcelRequire(\"6T66T\");\nvar $4b24793a4b0f2663$var$__rest = undefined && undefined.__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") {\n        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\nconst $4b24793a4b0f2663$var$OriginalURLPattern = /^(https?|#)/;\nconst $4b24793a4b0f2663$export$febf71ca481883cc = (0, $89MmN.observer)((_a)=>{\n    var { menu: menu = [] } = _a, rest = $4b24793a4b0f2663$var$__rest(_a, [\n        \"menu\"\n    ]);\n    return (0, $b603G.jsxs)((0, $fonQc.OffcanvasNavbar), Object.assign({\n        variant: \"dark\",\n        expand: \"md\",\n        sticky: \"top\",\n        brand: (0, $b603G.jsx)(\"a\", {\n            className: \"text-light text-decoration-none\",\n            href: \"#\",\n            children: (0, $6T66T.t)(\"chengdu_web_developer_summit\")\n        })\n    }, rest, {\n        children: [\n            menu === null || menu === void 0 ? void 0 : menu.map((_a)=>{\n                var _b, _c;\n                var { title: title, href: href } = _a, restLinkProps = $4b24793a4b0f2663$var$__rest(_a, [\n                    \"title\",\n                    \"href\"\n                ]);\n                return (0, $b603G.jsx)((0, $fonQc.NavLink), Object.assign({\n                    className: \"m-3 my-md-0 mx-md-3 align-self-center\"\n                }, restLinkProps, {\n                    href: $4b24793a4b0f2663$var$OriginalURLPattern.test(href) ? href : `#${href}`,\n                    active: (_c = (_b = globalThis.location) === null || _b === void 0 ? void 0 : _b.hash) === null || _c === void 0 ? void 0 : _c.slice(1).startsWith(href + \"\"),\n                    children: title\n                }));\n            }),\n            (0, $b603G.jsx)(\"select\", {\n                className: \"form-control w-auto ms-auto\",\n                value: (0, $6T66T.i18n).currentLanguage,\n                onChange: ({ currentTarget: currentTarget })=>(0, $6T66T.i18n).changeLanguage(currentTarget.value),\n                children: Object.entries((0, $6T66T.LanguageName)).map(([code, name])=>(0, $b603G.jsx)(\"option\", {\n                        value: code,\n                        children: name\n                    }, code))\n            })\n        ]\n    }));\n});\n\n});\n\nparcelRegister(\"3phDk\", function(module, exports) {\n\n$parcel$export(module.exports, \"title\", () => $27b1627f4ff99c0e$export$fb184b623420d9be);\n$parcel$export(module.exports, \"sections\", () => $27b1627f4ff99c0e$export$5a1dbaa3e4449344);\n$parcel$export(module.exports, \"lecturers\", () => $27b1627f4ff99c0e$export$31da89627f5e6e8b);\n$parcel$export(module.exports, \"topics\", () => $27b1627f4ff99c0e$export$31978e77bf6e08fb);\n$parcel$export(module.exports, \"schedule\", () => $27b1627f4ff99c0e$export$60974f670aa8d75e);\n$parcel$export(module.exports, \"projects\", () => $27b1627f4ff99c0e$export$39babdfab504f3da);\n$parcel$export(module.exports, \"review\", () => $27b1627f4ff99c0e$export$95794f71fd1fcea8);\n$parcel$export(module.exports, \"hosts\", () => $27b1627f4ff99c0e$export$95d17814281fb808);\n$parcel$export(module.exports, \"sponsors\", () => $27b1627f4ff99c0e$export$14e304d9e12f4092);\n$parcel$export(module.exports, \"partners\", () => $27b1627f4ff99c0e$export$dbe41a478099b642);\n$parcel$export(module.exports, \"companies\", () => $27b1627f4ff99c0e$export$d9f4fb13de619c2b);\n\nvar $6T66T = parcelRequire(\"6T66T\");\nparcelRequire(\"gHgq0\");\nvar $jo7kd = parcelRequire(\"jo7kd\");\nvar $gHgq0 = parcelRequire(\"gHgq0\");\nvar $5MUyt = parcelRequire(\"5MUyt\");\nvar $bIu6S = parcelRequire(\"bIu6S\");\n\nvar $f6NIY = parcelRequire(\"f6NIY\");\nparcelRequire(\"ihx4u\");\nvar $blYYo = parcelRequire(\"blYYo\");\nvar $8d2Jc = parcelRequire(\"8d2Jc\");\nvar $3GzEr = parcelRequire(\"3GzEr\");\nvar $inOb0 = parcelRequire(\"inOb0\");\nvar $cf13Y = parcelRequire(\"cf13Y\");\nvar $7koFK = parcelRequire(\"7koFK\");\nvar $7Xxj5 = parcelRequire(\"7Xxj5\");\nparcelRequire(\"gF6G2\");\nvar $6vgs4 = parcelRequire(\"6vgs4\");\nvar $8MbJ8 = parcelRequire(\"8MbJ8\");\nvar $hb62k = parcelRequire(\"hb62k\");\nvar $gF6G2 = parcelRequire(\"gF6G2\");\nvar $6R7SA = parcelRequire(\"6R7SA\");\nparcelRequire(\"gDwL4\");\nvar $jZtYj = parcelRequire(\"jZtYj\");\nvar $8rFS0 = parcelRequire(\"8rFS0\");\nvar $dJG7Y = parcelRequire(\"dJG7Y\");\nvar $3bQxZ = parcelRequire(\"3bQxZ\");\nparcelRequire(\"dDfpG\");\nvar $1vYb3 = parcelRequire(\"1vYb3\");\nvar $6FCPq = parcelRequire(\"6FCPq\");\nvar $63fF8 = parcelRequire(\"63fF8\");\nvar $6zQdD = parcelRequire(\"6zQdD\");\nvar $gUMbH = parcelRequire(\"gUMbH\");\nvar $8Os7Q = parcelRequire(\"8Os7Q\");\nvar $lK3VL = parcelRequire(\"lK3VL\");\nvar $aS2H3 = parcelRequire(\"aS2H3\");\nvar $30Oft = parcelRequire(\"30Oft\");\nvar $gdBbN = parcelRequire(\"gdBbN\");\nvar $dm065 = parcelRequire(\"dm065\");\nconst $27b1627f4ff99c0e$export$fb184b623420d9be = ()=>(0, $6T66T.t)(\"chengdu_web_frontend_conference_2018\");\nconst $27b1627f4ff99c0e$export$5a1dbaa3e4449344 = ()=>[\n        {\n            title: (0, $6T66T.t)(\"conference_introduction\"),\n            href: \"#Introduction\"\n        },\n        {\n            title: (0, $6T66T.t)(\"guest_lecturers\"),\n            href: \"#Lecturer\"\n        },\n        {\n            title: (0, $6T66T.t)(\"topics\"),\n            href: \"#Topic\"\n        },\n        {\n            title: (0, $6T66T.t)(\"open_source_bazaar\"),\n            href: \"#Bazaar\"\n        },\n        {\n            title: (0, $6T66T.t)(\"participating_companies\"),\n            href: \"#Enterprise\"\n        },\n        {\n            title: (0, $6T66T.t)(\"schedule\"),\n            href: \"#Schedule\"\n        },\n        {\n            title: (0, $6T66T.t)(\"address\"),\n            href: \"#Address\"\n        },\n        {\n            title: (0, $6T66T.t)(\"past_highlights_review\"),\n            href: \"#Review\"\n        },\n        {\n            title: (0, $6T66T.t)(\"photo_live\"),\n            href: \"http://www.pailixiang.com/album_ia172238913.html\"\n        },\n        {\n            title: (0, $6T66T.t)(\"co_creation_partners\"),\n            href: \"#Contributor\"\n        }\n    ];\nconst $27b1627f4ff99c0e$export$31da89627f5e6e8b = ()=>[\n        {\n            name: (0, $6T66T.t)(\"quincy_larson\"),\n            avatar: (0, (/*@__PURE__*/$parcel$interopDefault($inOb0))),\n            detail: (0, $6T66T.t)(\"quincy_larson_freecodecamp_founder\")\n        },\n        {\n            name: (0, $6T66T.t)(\"xiong_jie\"),\n            avatar: (0, (/*@__PURE__*/$parcel$interopDefault($7koFK))),\n            detail: (0, $6T66T.t)(\"xiong_jie_introduce\")\n        },\n        {\n            name: (0, $6T66T.t)(\"huang_yi\"),\n            avatar: (0, (/*@__PURE__*/$parcel$interopDefault($3GzEr))),\n            detail: (0, $6T66T.t)(\"huang_yi_introduce\")\n        },\n        {\n            name: (0, $6T66T.t)(\"si_yue\"),\n            avatar: (0, (/*@__PURE__*/$parcel$interopDefault($cf13Y))),\n            detail: (0, $6T66T.t)(\"si_yue_introduce\")\n        },\n        {\n            name: (0, $6T66T.t)(\"yu_che\"),\n            avatar: (0, (/*@__PURE__*/$parcel$interopDefault($7Xxj5))),\n            detail: (0, $6T66T.t)(\"yu_che_introduce\")\n        },\n        {\n            name: (0, $6T66T.t)(\"guo_lin_shuo\"),\n            avatar: (0, (/*@__PURE__*/$parcel$interopDefault($8d2Jc))),\n            detail: (0, $6T66T.t)(\"guo_linshuo_introduce\")\n        },\n        {\n            name: (0, $6T66T.t)(\"guo_da_feng\"),\n            avatar: (0, (/*@__PURE__*/$parcel$interopDefault($blYYo))),\n            detail: (0, $6T66T.t)(\"guo_dafeng_introduce\")\n        }\n    ];\nconst $27b1627f4ff99c0e$export$31978e77bf6e08fb = ()=>[\n        {\n            title: (0, $6T66T.t)(\"freecodecamp_from_0_to_290k_stars\"),\n            lecturer: $27b1627f4ff99c0e$export$31da89627f5e6e8b()[0],\n            detail: (0, $6T66T.t)(\"quincy_larson_career_journey\")\n        },\n        {\n            title: (0, $6T66T.t)(\"empower_nodejs_with_cpp_wings\"),\n            lecturer: $27b1627f4ff99c0e$export$31da89627f5e6e8b()[3],\n            detail: (0, $6T66T.t)(\"nodejs_cpp_usage_topic\")\n        },\n        {\n            title: (0, $6T66T.t)(\"open_source_project_maintenance\"),\n            lecturer: $27b1627f4ff99c0e$export$31da89627f5e6e8b()[4],\n            detail: (0, $6T66T.t)(\"open_source_guide\")\n        },\n        {\n            title: (0, $6T66T.t)(\"history_of_agile_in_china\"),\n            lecturer: $27b1627f4ff99c0e$export$31da89627f5e6e8b()[1],\n            detail: (0, $6T66T.t)(\"history_of_agile_in_china_detail\")\n        },\n        {\n            title: (0, $6T66T.t)(\"efficient_h5_animation_development_method\"),\n            lecturer: $27b1627f4ff99c0e$export$31da89627f5e6e8b()[5],\n            detail: (0, $6T66T.t)(\"efficient_h5_animation_development_method_detail\")\n        },\n        {\n            title: (0, $6T66T.t)(\"highly_available_react_server_side_rendering\"),\n            lecturer: $27b1627f4ff99c0e$export$31da89627f5e6e8b()[6],\n            detail: (0, $6T66T.t)(\"highly_available_react_ssr_enterprise_application_practice\")\n        },\n        {\n            title: (0, $6T66T.t)(\"building_vue_component_library\"),\n            lecturer: $27b1627f4ff99c0e$export$31da89627f5e6e8b()[2],\n            detail: (0, $6T66T.t)(\"building_vue_component_library_detail\")\n        }\n    ];\nconst $27b1627f4ff99c0e$export$60974f670aa8d75e = ()=>[\n        {\n            title: (0, $6T66T.t)(\"check_in_and_visit_bazaar\"),\n            time: \"09:00 ~ 09:30\"\n        },\n        {\n            topic: $27b1627f4ff99c0e$export$31978e77bf6e08fb()[0],\n            time: \"09:30 ~ 10:20\"\n        },\n        {\n            topic: $27b1627f4ff99c0e$export$31978e77bf6e08fb()[1],\n            time: \"10:20 ~ 11:10\"\n        },\n        {\n            topic: $27b1627f4ff99c0e$export$31978e77bf6e08fb()[2],\n            time: \"11:10 ~ 12:00\"\n        },\n        {\n            title: (0, $6T66T.t)(\"lunch_and_visit_bazaar\"),\n            time: \"12:00 ~ 13:55\"\n        },\n        {\n            title: (0, $6T66T.t)(\"lucky_draw_session\"),\n            time: \"13:55 ~ 14:00\"\n        },\n        {\n            topic: $27b1627f4ff99c0e$export$31978e77bf6e08fb()[3],\n            time: \"14:00 ~ 14:50\"\n        },\n        {\n            topic: $27b1627f4ff99c0e$export$31978e77bf6e08fb()[4],\n            time: \"14:50 ~ 15:40\"\n        },\n        {\n            title: (0, $6T66T.t)(\"tea_break_visit_bazaar_fun_programming_contest\"),\n            time: \"15:40 ~ 16:10\"\n        },\n        {\n            topic: $27b1627f4ff99c0e$export$31978e77bf6e08fb()[5],\n            time: \"16:10 ~ 17:00\"\n        },\n        {\n            topic: $27b1627f4ff99c0e$export$31978e77bf6e08fb()[6],\n            time: \"17:00 ~ 17:50\"\n        },\n        {\n            title: (0, $6T66T.t)(\"lucky_draw_session\"),\n            time: \"17:50 ~ 17:55\"\n        }\n    ];\nconst $27b1627f4ff99c0e$export$39babdfab504f3da = ()=>[\n        {\n            title: \"\\u6DF1\\u5EA6\\u64CD\\u4F5C\\u7CFB\\u7EDF\",\n            name: \"Deepin\",\n            type: 0,\n            URL: \"https://www.deepin.org\",\n            detail: (0, $6T66T.t)(\"global_influence_chinese_linux_distribution\"),\n            logo: (0, (/*@__PURE__*/$parcel$interopDefault($63fF8)))\n        },\n        {\n            title: \"WebCell\",\n            name: \"WebCell\",\n            type: 0,\n            URL: \"https://web-cell.dev/\",\n            detail: (0, $6T66T.t)(\"lightweight_web_componentization_engine_detail\"),\n            logo: (0, (/*@__PURE__*/$parcel$interopDefault($dm065)))\n        },\n        {\n            title: \"HTML 5 design software\",\n            name: \"H5DS\",\n            type: 0,\n            URL: \"http://www.h5ds.com\",\n            detail: (0, $6T66T.t)(\"h5ds_html5_design_software_detail\"),\n            logo: (0, (/*@__PURE__*/$parcel$interopDefault($gUMbH)))\n        },\n        {\n            title: \"Fun loading\",\n            name: \"Fun loading\",\n            type: 0,\n            URL: \"https://fanerge.github.io/fun-loading/dist/\",\n            detail: (0, $6T66T.t)(\"react_loading_component_library\"),\n            logo: (0, (/*@__PURE__*/$parcel$interopDefault($6zQdD)))\n        },\n        {\n            title: \"Ubuntu Kylin\",\n            name: \"UKylin\",\n            type: 0,\n            URL: \"http://www.ubuntukylin.com\",\n            detail: (0, $6T66T.t)(\"ubuntu_kylin_detail\"),\n            logo: (0, (/*@__PURE__*/$parcel$interopDefault($30Oft)))\n        },\n        {\n            title: \"Covariant Script\",\n            name: \"Covariant Script\",\n            type: 0,\n            URL: \"http://covscript.org\",\n            detail: (0, $6T66T.t)(\"covariant_script_detail\"),\n            logo: (0, (/*@__PURE__*/$parcel$interopDefault($6FCPq)))\n        },\n        {\n            title: \"PI6\",\n            name: \"PI6\",\n            type: 0,\n            URL: \"http://github.com/visi-pivi-sivi/PI6\",\n            detail: \"PI6 is a bash shell based framework, allow author to add comments in the script, and provides a good interactive experience for user, who needs to know what will be done in the next, while running the script in step by step mode.\",\n            logo: (0, (/*@__PURE__*/$parcel$interopDefault($lK3VL)))\n        },\n        {\n            title: \"React Admin\",\n            name: \"React Admin\",\n            type: 0,\n            URL: \"https://github.com/yezihaohao/react-admin\",\n            detail: (0, $6T66T.t)(\"react_antd_backend_management_solution\"),\n            logo: (0, (/*@__PURE__*/$parcel$interopDefault($aS2H3)))\n        },\n        {\n            title: \"\\u5F00\\u6E90\\u793E\",\n            name: \"KaiYuanShe\",\n            type: 1,\n            URL: \"http://www.kaiyuanshe.cn/\",\n            detail: (0, $6T66T.t)(\"kaiyuanshe_open_source_alliance_description\"),\n            logo: (0, (/*@__PURE__*/$parcel$interopDefault($8Os7Q)))\n        },\n        {\n            title: \"\\u6D1B\\u4E66\\u534F\\u8BAE\",\n            name: \"Vena Network\",\n            type: 0,\n            URL: \"https://github.com/venanetwork\",\n            detail: (0, $6T66T.t)(\"luoshu_protocol_asset_securitization_tokenization\"),\n            logo: (0, (/*@__PURE__*/$parcel$interopDefault($gdBbN)))\n        },\n        {\n            title: \"\\u6210\\u90FD Linux \\u7528\\u6237\\u7EC4\",\n            name: \"CD-LUG\",\n            type: 1,\n            URL: \"https://cdlug.org/\",\n            detail: (0, $6T66T.t)(\"chengdu_gnu_linux_community_description\"),\n            logo: (0, (/*@__PURE__*/$parcel$interopDefault($1vYb3)))\n        }\n    ];\nconst $27b1627f4ff99c0e$export$95794f71fd1fcea8 = [\n    {\n        title: \"React \\u6280\\u672F\\u6F14\\u8BB2\"\n    },\n    {\n        title: \"React \\u6280\\u672F\\u63D0\\u95EE\"\n    },\n    {\n        title: \"React \\u6280\\u672F\\u8BB2\\u5E08\"\n    },\n    {\n        title: \"React \\u5927\\u4F1A\\u89C2\\u4F17\"\n    },\n    {\n        title: \"React \\u5927\\u4F1A\\u62DB\\u8058\"\n    },\n    {\n        title: \"Code for City \\u9ED1\\u5BA2\\u677E\\u8336\\u6B47\"\n    },\n    {\n        title: \"Code for City \\u9ED1\\u5BA2\\u677E FCC \\u5408\\u5F71\"\n    },\n    {\n        title: \"\\u8336\\u6B47\\u4E00\\u89C8\"\n    },\n    {\n        title: \"React \\u5927\\u4F1A\\u62DB\\u8058\"\n    }\n];\nconst $27b1627f4ff99c0e$export$95d17814281fb808 = ()=>[\n        {\n            title: (0, $6T66T.t)(\"principal\"),\n            member: [\n                {\n                    name: \"FCC \\u6210\\u90FD\",\n                    path: (0, $f6NIY.FCC_CDC),\n                    URL: \"https://freecodecamp-chengdu.github.io/\"\n                }\n            ]\n        },\n        {\n            title: (0, $6T66T.t)(\"supporting\"),\n            member: [\n                {\n                    name: \" \\u6398\\u91D1\",\n                    path: (0, $gHgq0.JueJin),\n                    URL: \"https://juejin.im/\"\n                }\n            ]\n        }\n    ];\nconst $27b1627f4ff99c0e$export$14e304d9e12f4092 = ()=>[\n        {\n            title: (0, $6T66T.t)(\"gold\"),\n            member: [\n                {\n                    name: \"\\u4E0A\\u7EBF\\u4E86\",\n                    path: (0, (/*@__PURE__*/$parcel$interopDefault($3bQxZ))),\n                    URL: \"https://www.sxl.cn/\"\n                }\n            ]\n        },\n        {\n            title: (0, $6T66T.t)(\"silver\"),\n            member: [\n                {\n                    name: \"\\u5B9D\\u5C0A\\u7535\\u5546\",\n                    path: (0, (/*@__PURE__*/$parcel$interopDefault($8rFS0))),\n                    URL: \"https://www.baozun.com/cn/\"\n                }\n            ]\n        },\n        {\n            title: (0, $6T66T.t)(\"bronze\"),\n            member: [\n                {\n                    name: \"\\u53EF\\u597D\\u73A9\\u4E50\",\n                    path: (0, (/*@__PURE__*/$parcel$interopDefault($dJG7Y))),\n                    URL: \"https://cocoet.cn/\"\n                },\n                {\n                    name: \"\\u767E\\u8BCD\\u65A9\",\n                    path: (0, (/*@__PURE__*/$parcel$interopDefault($jZtYj))),\n                    URL: \"http://www.baicizhan.com/\"\n                }\n            ]\n        }\n    ];\nconst $27b1627f4ff99c0e$export$dbe41a478099b642 = [\n    {\n        name: \"\\u535A\\u6587\\u89C6\\u70B9\",\n        path: (0, (/*@__PURE__*/$parcel$interopDefault($jo7kd))),\n        URL: \"http://www.broadview.com.cn/\"\n    },\n    {\n        name: \"\\u5F00\\u6E90\\u4E2D\\u56FD\",\n        path: (0, $gHgq0.OSChina),\n        URL: \"https://www.oschina.net/\"\n    },\n    {\n        name: \"\\u9EA6\\u514B\",\n        path: (0, (/*@__PURE__*/$parcel$interopDefault($hb62k))),\n        URL: \"https://www.mikecrm.com/\"\n    },\n    {\n        name: \"\\u524D\\u7AEF\\u65E9\\u8BFB\\u8BFE\",\n        path: (0, (/*@__PURE__*/$parcel$interopDefault($8MbJ8))),\n        URL: \"https://zdk.f2er.net/\"\n    },\n    {\n        name: \"\\u5B9E\\u9A8C\\u697C\",\n        path: (0, (/*@__PURE__*/$parcel$interopDefault($bIu6S))),\n        URL: \"https://www.shiyanlou.com/\"\n    },\n    {\n        name: \"\\u56FE\\u7075\\u793E\\u533A\",\n        path: (0, $gF6G2.turing),\n        URL: \"http://www.ituring.com.cn/\"\n    },\n    {\n        name: \"\\u5F02\\u6B65\\u793E\\u533A\",\n        path: (0, (/*@__PURE__*/$parcel$interopDefault($6vgs4))),\n        URL: \"https://www.epubit.com/\"\n    },\n    {\n        name: \"SegmentFault\",\n        path: (0, (/*@__PURE__*/$parcel$interopDefault($5MUyt))),\n        URL: \"https://segmentfault.com/\"\n    },\n    {\n        name: \"\\u5C0F\\u6837\\u9752\\u5E74\\u793E\\u533A\",\n        path: (0, (/*@__PURE__*/$parcel$interopDefault($6R7SA))),\n        URL: \"http://www.xypark.com/\"\n    }\n];\nconst $27b1627f4ff99c0e$export$d9f4fb13de619c2b = [\n    \"\\u4E0A\\u7EBF\\u4E86\",\n    \"\\u5B9D\\u5C0A\\u7535\\u5546\",\n    \"\\u4F01\\u9E45\\u533B\\u751F\",\n    \"\\u65B0\\u86CB\",\n    \"\\u4E50\\u8F66\\u90A6\",\n    \"tap4fun\",\n    \"ThoughtWorks\",\n    \"\\u9EA6\\u9EA6\\u517B\\u8001\",\n    \"BBD\",\n    \"\\u7F8E\\u56E2\",\n    \"\\u817E\\u8BAF\",\n    \"\\u77E5\\u9053\\u521B\\u5B87\",\n    \"\\u964C\\u964C\\u6210\\u90FD\",\n    \"\\u5B54\\u660E\\u79D1\\u6280\",\n    \"\\u77E5\\u4E4E\",\n    \"\\u53BB\\u54EA\\u513F\",\n    \"\\u533B\\u8054\",\n    \"\\u6781\\u7C73\\u79D1\\u6280\",\n    \"\\u4ECA\\u65E5\\u5934\\u6761\",\n    \"\\u70B9\\u878D\\u7F51\",\n    \"\\u5BA2\\u5982\\u4E91\",\n    \"\\u8857\\u7535\",\n    \"\\u534E\\u4E3A\\u4E91\",\n    \"Camera360\",\n    \"\\u9C7C\\u8BF4\\u79D1\\u6280\",\n    \"\\u6298800\",\n    \"TestBird\",\n    \"\\u6C47\\u901A\\u5929\\u4E0B\",\n    \"\\u79D1\\u5927\\u8BAF\\u98DE\",\n    \"\\u5495\\u549A\",\n    \"\\u897F\\u74DC\\u521B\\u5BA2\",\n    \"\\u5B9E\\u9A8C\\u697C\",\n    \"\\u56DB\\u65B9\\u4F1F\\u4E1A\",\n    \"\\u732A\\u516B\\u6212\",\n    \"\\u964C\\u964C\",\n    \"\\u8D27\\u8F66\\u90A6\",\n    \"\\u6D3B\\u8DC3\\u7F51\\u7EDC\",\n    \"\\u8682\\u8681\\u91D1\\u670D\"\n];\n\n});\nparcelRegister(\"gHgq0\", function(module, exports) {\n\n$parcel$export(module.exports, \"JueJin\", () => $c27d65df7592ab6e$export$bb383df5b32c05b7);\n$parcel$export(module.exports, \"OSChina\", () => $c27d65df7592ab6e$export$7f92890d073cca8c);\n$parcel$export(module.exports, \"_3W\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"a6GD7\")))));\n$parcel$export(module.exports, \"BBD\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"kNPMK\")))));\n$parcel$export(module.exports, \"BW\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"jo7kd\")))));\n$parcel$export(module.exports, \"DevEco\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"2MzDe\")))));\n$parcel$export(module.exports, \"DKS\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"gSR75\")))));\n$parcel$export(module.exports, \"FCC_CDG\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"1nkOI\")))));\n$parcel$export(module.exports, \"GDG\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"jX8RL\")))));\n$parcel$export(module.exports, \"GT\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"gV4Pq\")))));\n$parcel$export(module.exports, \"HCXY\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"jsxvS\")))));\n$parcel$export(module.exports, \"MZ\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"eOHmK\")))));\n$parcel$export(module.exports, \"QE\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"jUdbG\")))));\n$parcel$export(module.exports, \"QRGJ\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"dNOtA\")))));\n$parcel$export(module.exports, \"SF\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"5MUyt\")))));\n$parcel$export(module.exports, \"SYL\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"bIu6S\")))));\n$parcel$export(module.exports, \"TH\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"fTVmu\")))));\n$parcel$export(module.exports, \"TW\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"4OSKi\")))));\n$parcel$export(module.exports, \"WORK\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"cqarv\")))));\n$parcel$export(module.exports, \"ZDK\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"fXOGy\")))));\n\nvar $a6GD7 = parcelRequire(\"a6GD7\");\n\nvar $kNPMK = parcelRequire(\"kNPMK\");\n\nvar $jo7kd = parcelRequire(\"jo7kd\");\n\nvar $2MzDe = parcelRequire(\"2MzDe\");\n\nvar $gSR75 = parcelRequire(\"gSR75\");\n\nvar $1nkOI = parcelRequire(\"1nkOI\");\n\nvar $jX8RL = parcelRequire(\"jX8RL\");\n\nvar $gV4Pq = parcelRequire(\"gV4Pq\");\n\nvar $jsxvS = parcelRequire(\"jsxvS\");\n\nvar $eOHmK = parcelRequire(\"eOHmK\");\n\nvar $64Ku8 = parcelRequire(\"64Ku8\");\n\nvar $jUdbG = parcelRequire(\"jUdbG\");\n\nvar $dNOtA = parcelRequire(\"dNOtA\");\n\nvar $5MUyt = parcelRequire(\"5MUyt\");\n\nvar $bIu6S = parcelRequire(\"bIu6S\");\n\nvar $fTVmu = parcelRequire(\"fTVmu\");\n\nvar $4OSKi = parcelRequire(\"4OSKi\");\n\nvar $cqarv = parcelRequire(\"cqarv\");\n\nvar $fXOGy = parcelRequire(\"fXOGy\");\nconst $c27d65df7592ab6e$export$bb383df5b32c05b7 = \"https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg\";\nconst $c27d65df7592ab6e$export$7f92890d073cca8c = \"https://static.oschina.net/new-osc/img/logo_osc_new.svg\";\n\n});\nparcelRegister(\"a6GD7\", function(module, exports) {\nmodule.exports = new URL(\"3W.343e9c06.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"kNPMK\", function(module, exports) {\nmodule.exports = new URL(\"BBD.ed89ee43.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"jo7kd\", function(module, exports) {\nmodule.exports = new URL(\"BW.0f2c33fb.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"2MzDe\", function(module, exports) {\nmodule.exports = new URL(\"DevEco.5b51c8ac.jpg\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"gSR75\", function(module, exports) {\nmodule.exports = new URL(\"DKS.1c567b7f.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"1nkOI\", function(module, exports) {\nmodule.exports = new URL(\"FCC-CDG.bf36daee.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"jX8RL\", function(module, exports) {\nmodule.exports = new URL(\"GDG.ca994c53.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"gV4Pq\", function(module, exports) {\nmodule.exports = new URL(\"GT.27a90685.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"jsxvS\", function(module, exports) {\nmodule.exports = new URL(\"HCXY.6f490d1a.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"eOHmK\", function(module, exports) {\nmodule.exports = new URL(\"MZ.d0765924.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"64Ku8\", function(module, exports) {\nmodule.exports = new URL(\"OS.58b63fb9.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"jUdbG\", function(module, exports) {\nmodule.exports = new URL(\"QE.be8c3b0d.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"dNOtA\", function(module, exports) {\nmodule.exports = new URL(\"QRGJ.14ffed50.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"5MUyt\", function(module, exports) {\nmodule.exports = new URL(\"SF.c6f8e6e7.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"bIu6S\", function(module, exports) {\nmodule.exports = new URL(\"SYL.da34d90b.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"fTVmu\", function(module, exports) {\nmodule.exports = new URL(\"TH.1178f233.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"4OSKi\", function(module, exports) {\nmodule.exports = new URL(\"TW.0498d9bc.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"cqarv\", function(module, exports) {\nmodule.exports = new URL(\"WORK.90e8ce09.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"fXOGy\", function(module, exports) {\nmodule.exports = new URL(\"ZDK.fb7a5ccd.png\", import.meta.url).toString();\n\n});\n\n\nparcelRegister(\"f6NIY\", function(module, exports) {\n\n$parcel$export(module.exports, \"FCC_CDC\", () => $affdfcc70845640a$export$e5c5c7a5558278fe);\n$parcel$export(module.exports, \"poster\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"7dZa5\")))));\n$parcel$export(module.exports, \"undraw_01\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"7qUFF\")))));\n$parcel$export(module.exports, \"undraw_04\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"5pWIJ\")))));\n\nvar $7dZa5 = parcelRequire(\"7dZa5\");\n\nvar $7qUFF = parcelRequire(\"7qUFF\");\n\nvar $5pWIJ = parcelRequire(\"5pWIJ\");\nconst $affdfcc70845640a$export$e5c5c7a5558278fe = \"https://fcc-cd.dev/images/FCC-CDC-v1-0.png\";\n\n});\nparcelRegister(\"7dZa5\", function(module, exports) {\nmodule.exports = new URL(\"poster.367bcd76.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"7qUFF\", function(module, exports) {\nmodule.exports = new URL(\"undraw_01.18599e8b.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"5pWIJ\", function(module, exports) {\nmodule.exports = new URL(\"undraw_04.d9b38312.png\", import.meta.url).toString();\n\n});\n\n\nparcelRegister(\"ihx4u\", function(module, exports) {\n\n$parcel$export(module.exports, \"Guo_DaFeng\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"blYYo\")))));\n$parcel$export(module.exports, \"Guo_LinShuo\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"8d2Jc\")))));\n$parcel$export(module.exports, \"Huang_Yi\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"3GzEr\")))));\n$parcel$export(module.exports, \"Quincy_Larson\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"inOb0\")))));\n$parcel$export(module.exports, \"Si_Yue\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"cf13Y\")))));\n$parcel$export(module.exports, \"Xiong_Jie\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"7koFK\")))));\n$parcel$export(module.exports, \"Yu_Che\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"7Xxj5\")))));\n\nvar $blYYo = parcelRequire(\"blYYo\");\n\nvar $8d2Jc = parcelRequire(\"8d2Jc\");\n\nvar $3GzEr = parcelRequire(\"3GzEr\");\n\nvar $dB5Vl = parcelRequire(\"dB5Vl\");\n\nvar $inOb0 = parcelRequire(\"inOb0\");\n\nvar $cf13Y = parcelRequire(\"cf13Y\");\n\nvar $7koFK = parcelRequire(\"7koFK\");\n\nvar $7Xxj5 = parcelRequire(\"7Xxj5\");\n\n});\nparcelRegister(\"blYYo\", function(module, exports) {\nmodule.exports = new URL(\"Guo DaFeng.6d7546f5.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"8d2Jc\", function(module, exports) {\nmodule.exports = new URL(\"Guo LinShuo.12cd3b39.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"3GzEr\", function(module, exports) {\nmodule.exports = new URL(\"Huang Yi.a58655d7.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"dB5Vl\", function(module, exports) {\nmodule.exports = new URL(\"OpenSource.1df18182.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"inOb0\", function(module, exports) {\nmodule.exports = new URL(\"Quincy Larson.caaecba1.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"cf13Y\", function(module, exports) {\nmodule.exports = new URL(\"Si Yue.fba3c144.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"7koFK\", function(module, exports) {\nmodule.exports = new URL(\"Xiong Jie.6367f3c4.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"7Xxj5\", function(module, exports) {\nmodule.exports = new URL(\"Yu Che.f3526e5b.png\", import.meta.url).toString();\n\n});\n\n\nparcelRegister(\"gF6G2\", function(module, exports) {\n\n$parcel$export(module.exports, \"turing\", () => $c215a794ceb2758a$export$24f9481c6fe98ef7);\n$parcel$export(module.exports, \"epubit\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"6vgs4\")))));\n$parcel$export(module.exports, \"fezaoduke\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"8MbJ8\")))));\n$parcel$export(module.exports, \"mikecrm\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"hb62k\")))));\n$parcel$export(module.exports, \"young\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"6R7SA\")))));\n\nvar $6vgs4 = parcelRequire(\"6vgs4\");\n\nvar $8MbJ8 = parcelRequire(\"8MbJ8\");\n\nvar $hb62k = parcelRequire(\"hb62k\");\n\nvar $6R7SA = parcelRequire(\"6R7SA\");\nconst $c215a794ceb2758a$export$24f9481c6fe98ef7 = \"http://tp1.sinaimg.cn/1752543513/180/1.jpg\";\n\n});\nparcelRegister(\"6vgs4\", function(module, exports) {\nmodule.exports = new URL(\"epubit.c1d8c5b0.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"8MbJ8\", function(module, exports) {\nmodule.exports = new URL(\"fezaoduke.fb7a5ccd.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"hb62k\", function(module, exports) {\nmodule.exports = new URL(\"mikecrm.0a457542.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"6R7SA\", function(module, exports) {\nmodule.exports = new URL(\"young.5f5cc2c5.png\", import.meta.url).toString();\n\n});\n\n\nparcelRegister(\"gDwL4\", function(module, exports) {\n\n$parcel$export(module.exports, \"BaiCiZhan\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"jZtYj\")))));\n$parcel$export(module.exports, \"baozun\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"8rFS0\")))));\n$parcel$export(module.exports, \"cocoet\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"dJG7Y\")))));\n$parcel$export(module.exports, \"sxl\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"3bQxZ\")))));\n\nvar $jZtYj = parcelRequire(\"jZtYj\");\n\nvar $8rFS0 = parcelRequire(\"8rFS0\");\n\nvar $dJG7Y = parcelRequire(\"dJG7Y\");\n\nvar $3bQxZ = parcelRequire(\"3bQxZ\");\n\n});\nparcelRegister(\"jZtYj\", function(module, exports) {\nmodule.exports = new URL(\"BaiCiZhan.259fa4d1.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"8rFS0\", function(module, exports) {\nmodule.exports = new URL(\"baozun.75f58188.jpg\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"dJG7Y\", function(module, exports) {\nmodule.exports = new URL(\"cocoet.da319e74.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"3bQxZ\", function(module, exports) {\nmodule.exports = new URL(\"sxl.dd9a9c0f.jpg\", import.meta.url).toString();\n\n});\n\n\nparcelRegister(\"dDfpG\", function(module, exports) {\n\n$parcel$export(module.exports, \"CD_LUG\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"1vYb3\")))));\n$parcel$export(module.exports, \"Covariant_Script\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"6FCPq\")))));\n$parcel$export(module.exports, \"Deepin\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"63fF8\")))));\n$parcel$export(module.exports, \"Fun_loading\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"6zQdD\")))));\n$parcel$export(module.exports, \"H5DS\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"gUMbH\")))));\n$parcel$export(module.exports, \"KaiYuanShe\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"8Os7Q\")))));\n$parcel$export(module.exports, \"PI6\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"lK3VL\")))));\n$parcel$export(module.exports, \"React_Admin\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"aS2H3\")))));\n$parcel$export(module.exports, \"UKylin\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"30Oft\")))));\n$parcel$export(module.exports, \"Vena_Network\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"gdBbN\")))));\n$parcel$export(module.exports, \"WebCell\", () => (/*@__PURE__*/$parcel$interopDefault((parcelRequire(\"dm065\")))));\n\nvar $1vYb3 = parcelRequire(\"1vYb3\");\n\nvar $6FCPq = parcelRequire(\"6FCPq\");\n\nvar $63fF8 = parcelRequire(\"63fF8\");\n\nvar $6zQdD = parcelRequire(\"6zQdD\");\n\nvar $gUMbH = parcelRequire(\"gUMbH\");\n\nvar $8Os7Q = parcelRequire(\"8Os7Q\");\n\nvar $lK3VL = parcelRequire(\"lK3VL\");\n\nvar $aS2H3 = parcelRequire(\"aS2H3\");\n\nvar $30Oft = parcelRequire(\"30Oft\");\n\nvar $gdBbN = parcelRequire(\"gdBbN\");\n\nvar $dm065 = parcelRequire(\"dm065\");\n\n});\nparcelRegister(\"1vYb3\", function(module, exports) {\nmodule.exports = new URL(\"CD-LUG.5d9dea2f.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"6FCPq\", function(module, exports) {\nmodule.exports = new URL(\"Covariant Script.6b878a1e.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"63fF8\", function(module, exports) {\nmodule.exports = new URL(\"Deepin.ae36ed8d.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"6zQdD\", function(module, exports) {\nmodule.exports = new URL(\"Fun loading.6e397c0c.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"gUMbH\", function(module, exports) {\nmodule.exports = new URL(\"H5DS.e8bb5317.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"8Os7Q\", function(module, exports) {\nmodule.exports = new URL(\"KaiYuanShe.da310f52.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"lK3VL\", function(module, exports) {\nmodule.exports = new URL(\"PI6.1bc18258.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"aS2H3\", function(module, exports) {\nmodule.exports = new URL(\"React Admin.6c9f1934.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"30Oft\", function(module, exports) {\nmodule.exports = new URL(\"UKylin.71e361fb.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"gdBbN\", function(module, exports) {\nmodule.exports = new URL(\"Vena Network.a2781646.png\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"dm065\", function(module, exports) {\nmodule.exports = new URL(\"WebCell.48070487.png\", import.meta.url).toString();\n\n});\n\n\n\nparcelRegister(\"1PSFd\", function(module, exports) {\n\n$parcel$export(module.exports, \"default\", () => $1564f4f7532c0117$export$2e2bcd8739ae039);\n\nvar $aeQZH = parcelRequire(\"aeQZH\");\n\nvar $hXWPJ = parcelRequire(\"hXWPJ\");\n\nvar $5dDsr = parcelRequire(\"5dDsr\");\n\nvar $iW3qR = parcelRequire(\"iW3qR\");\n\nvar $87N2j = parcelRequire(\"87N2j\");\n\nvar $a8nfF = parcelRequire(\"a8nfF\");\n\nvar $50hrK = parcelRequire(\"50hrK\");\n\nvar $8fcJL = parcelRequire(\"8fcJL\");\n\nvar $9Ojwv = parcelRequire(\"9Ojwv\");\nvar $1564f4f7532c0117$export$2e2bcd8739ae039 = [\n    (0, (/*@__PURE__*/$parcel$interopDefault($aeQZH))),\n    (0, (/*@__PURE__*/$parcel$interopDefault($hXWPJ))),\n    (0, (/*@__PURE__*/$parcel$interopDefault($5dDsr))),\n    (0, (/*@__PURE__*/$parcel$interopDefault($iW3qR))),\n    (0, (/*@__PURE__*/$parcel$interopDefault($87N2j))),\n    (0, (/*@__PURE__*/$parcel$interopDefault($a8nfF))),\n    (0, (/*@__PURE__*/$parcel$interopDefault($50hrK))),\n    (0, (/*@__PURE__*/$parcel$interopDefault($8fcJL))),\n    (0, (/*@__PURE__*/$parcel$interopDefault($9Ojwv)))\n];\n\n});\nparcelRegister(\"aeQZH\", function(module, exports) {\nmodule.exports = new URL(\"1.bcd16fd1.jpg\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"hXWPJ\", function(module, exports) {\nmodule.exports = new URL(\"2.09e20710.jpg\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"5dDsr\", function(module, exports) {\nmodule.exports = new URL(\"3.244a440c.jpg\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"iW3qR\", function(module, exports) {\nmodule.exports = new URL(\"4.c55a5098.jpg\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"87N2j\", function(module, exports) {\nmodule.exports = new URL(\"5.656cea07.jpg\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"a8nfF\", function(module, exports) {\nmodule.exports = new URL(\"6.da397600.jpg\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"50hrK\", function(module, exports) {\nmodule.exports = new URL(\"7.f4500b56.jpg\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"8fcJL\", function(module, exports) {\nmodule.exports = new URL(\"8.42f8e777.jpg\", import.meta.url).toString();\n\n});\n\nparcelRegister(\"9Ojwv\", function(module, exports) {\nmodule.exports = new URL(\"9.f9c67304.jpg\", import.meta.url).toString();\n\n});\n\n\nparcelRegister(\"h58g0\", function(module, exports) {\n\n$parcel$export(module.exports, \"root\", () => $c6f94efb3529b7b9$export$e8e78c978b129247, (v) => $c6f94efb3529b7b9$export$e8e78c978b129247 = v);\n$parcel$export(module.exports, \"poster\", () => $c6f94efb3529b7b9$export$b840e55573b2d2e7, (v) => $c6f94efb3529b7b9$export$b840e55573b2d2e7 = v);\n$parcel$export(module.exports, \"avatar\", () => $c6f94efb3529b7b9$export$345c5736c8054f22, (v) => $c6f94efb3529b7b9$export$345c5736c8054f22 = v);\n$parcel$export(module.exports, \"avatar-sm\", () => $c6f94efb3529b7b9$export$8b0699a3bcbc6095, (v) => $c6f94efb3529b7b9$export$8b0699a3bcbc6095 = v);\n$parcel$export(module.exports, \"sparked\", () => $c6f94efb3529b7b9$export$85fc6f6fd6332263, (v) => $c6f94efb3529b7b9$export$85fc6f6fd6332263 = v);\n$parcel$export(module.exports, \"lecture\", () => $c6f94efb3529b7b9$export$a51de3b6c04f794d, (v) => $c6f94efb3529b7b9$export$a51de3b6c04f794d = v);\n$parcel$export(module.exports, \"subjects\", () => $c6f94efb3529b7b9$export$783166601a642219, (v) => $c6f94efb3529b7b9$export$783166601a642219 = v);\n$parcel$export(module.exports, \"photos\", () => $c6f94efb3529b7b9$export$3b2217e45a573556, (v) => $c6f94efb3529b7b9$export$3b2217e45a573556 = v);\n$parcel$export(module.exports, \"companies\", () => $c6f94efb3529b7b9$export$d9f4fb13de619c2b, (v) => $c6f94efb3529b7b9$export$d9f4fb13de619c2b = v);\n$parcel$export(module.exports, \"contributorGroup\", () => $c6f94efb3529b7b9$export$b48fe2737b0f5681, (v) => $c6f94efb3529b7b9$export$b48fe2737b0f5681 = v);\nvar $c6f94efb3529b7b9$export$e8e78c978b129247;\nvar $c6f94efb3529b7b9$export$beee475260967c93;\nvar $c6f94efb3529b7b9$export$b840e55573b2d2e7;\nvar $c6f94efb3529b7b9$export$cc0e318fd32289c2;\nvar $c6f94efb3529b7b9$export$58733aaf927c3bbe;\nvar $c6f94efb3529b7b9$export$947d3d934fcd56c1;\nvar $c6f94efb3529b7b9$export$b15c49b0cb93f01e;\nvar $c6f94efb3529b7b9$export$bbae454ff46c69a0;\nvar $c6f94efb3529b7b9$export$345c5736c8054f22;\nvar $c6f94efb3529b7b9$export$8b0699a3bcbc6095;\nvar $c6f94efb3529b7b9$export$85fc6f6fd6332263;\nvar $c6f94efb3529b7b9$export$a51de3b6c04f794d;\nvar $c6f94efb3529b7b9$export$a52d855af68a1bf;\nvar $c6f94efb3529b7b9$export$346d138ee9c3fa56;\nvar $c6f94efb3529b7b9$export$783166601a642219;\nvar $c6f94efb3529b7b9$export$3b2217e45a573556;\nvar $c6f94efb3529b7b9$export$d9f4fb13de619c2b;\nvar $c6f94efb3529b7b9$export$b48fe2737b0f5681;\nvar $c6f94efb3529b7b9$export$adb608be33961c98;\nvar $c6f94efb3529b7b9$export$5f3279733515fed0;\n$c6f94efb3529b7b9$export$e8e78c978b129247 = \"root_bb4793\";\n$c6f94efb3529b7b9$export$beee475260967c93 = \"btn-primary_bb4793\";\n$c6f94efb3529b7b9$export$b840e55573b2d2e7 = \"poster_bb4793\";\n$c6f94efb3529b7b9$export$cc0e318fd32289c2 = \"navbar-toggler_bb4793\";\n$c6f94efb3529b7b9$export$58733aaf927c3bbe = \"navbar_bb4793\";\n$c6f94efb3529b7b9$export$947d3d934fcd56c1 = \"navbar-nav_bb4793\";\n$c6f94efb3529b7b9$export$b15c49b0cb93f01e = \"navbar-light_bb4793\";\n$c6f94efb3529b7b9$export$bbae454ff46c69a0 = \"nav-link_bb4793\";\n$c6f94efb3529b7b9$export$345c5736c8054f22 = \"avatar_bb4793\";\n$c6f94efb3529b7b9$export$8b0699a3bcbc6095 = \"avatar-sm_bb4793\";\n$c6f94efb3529b7b9$export$85fc6f6fd6332263 = \"sparked_bb4793\";\n$c6f94efb3529b7b9$export$a51de3b6c04f794d = \"lecture_bb4793\";\n$c6f94efb3529b7b9$export$a52d855af68a1bf = \"lecture-name_bb4793\";\n$c6f94efb3529b7b9$export$346d138ee9c3fa56 = \"lecture-intro_bb4793\";\n$c6f94efb3529b7b9$export$783166601a642219 = \"subjects_bb4793\";\n$c6f94efb3529b7b9$export$3b2217e45a573556 = \"photos_bb4793\";\n$c6f94efb3529b7b9$export$d9f4fb13de619c2b = \"companies_bb4793\";\n$c6f94efb3529b7b9$export$b48fe2737b0f5681 = \"contributorGroup_bb4793\";\n$c6f94efb3529b7b9$export$adb608be33961c98 = \"footer_bb4793\";\n$c6f94efb3529b7b9$export$5f3279733515fed0 = \"qrcode_bb4793\";\n\n});\n\nparcelRegister(\"g3Ku0\", function(module, exports) {\n\n$parcel$export(module.exports, \"LogoList\", () => $bb10fbb2bebf156f$export$d43206f0b9719a5e);\n\nvar $b603G = parcelRequire(\"b603G\");\nconst $bb10fbb2bebf156f$export$d43206f0b9719a5e = ({ member: member })=>(0, $b603G.jsx)(\"div\", {\n        className: \"d-flex justify-content-around align-content-center flex-wrap\",\n        children: member.map(({ URL: URL, name: name, path: path })=>(0, $b603G.jsx)(\"a\", {\n                target: \"_blank\",\n                href: URL,\n                children: (0, $b603G.jsx)(\"img\", {\n                    className: \"py-3 px-1 flex-grow-0 flex-shrink-0\",\n                    title: name,\n                    src: path,\n                    style: {\n                        width: \"210px\"\n                    }\n                })\n            }, path))\n    });\n\n});\n\n\n\n//# sourceMappingURL=2018.69007646.js.map\n","import { Container, Ratio, Table } from 'boot-cell';\nimport { Button, Image, Nav, NavLink } from 'boot-cell';\nimport { Card, CardBody, CardImg, CardTitle } from 'boot-cell';\nimport { marked } from 'marked';\nimport { observer } from 'web-cell';\n\nimport { TopNavBar } from '../../component/TopNavBar';\nimport { t } from '../../i18n';\nimport {\n    companies,\n    hosts,\n    lecturers,\n    partners,\n    projects,\n    review,\n    schedule,\n    sections,\n    sponsors,\n    title,\n    topics\n} from './data';\nimport { poster, undraw_01, undraw_04 } from './image';\nimport photos from './image/photos';\nimport * as style from './index.module.less';\nimport { LogoList } from './LogoList';\n\nexport default observer(() => (\n    <main className={style.root}>\n        <TopNavBar\n            brand={title()}\n            expand=\"lg\"\n            variant=\"light\"\n            menu={sections()}\n        />\n        <div className={style.poster}>\n            <Image src={poster} fluid />\n        </div>\n        <section id=\"Introduction\">\n            <h2 className=\"text-center mb-5\">{t('conference_introduction')}</h2>\n            <Container>\n                <div className=\"row\">\n                    <div className=\"col-md-7\">\n                        <p>{t('conference_description')}</p>\n                        <div className=\"p-4 text-center\">\n                            <Button\n                                variant=\"primary\"\n                                size=\"lg\"\n                                target=\"_blank\"\n                                href=\"http://fcc-chengdu.mikecrm.com/tFM8Rk8\"\n                            >\n                                {t('register_now')}\n                            </Button>\n                        </div>\n                    </div>\n                    <div className=\"col-md-5\">\n                        <Image fluid src={undraw_01} />\n                    </div>\n                </div>\n            </Container>\n        </section>\n        <section id=\"Lecturer\" className={style.sparked}>\n            <h2 className=\"mb-5\">{t('guest_lecturers')}</h2>\n            <Container>\n                <div className=\"row lecture-list\">\n                    {lecturers().map(({ avatar, name, detail }) => (\n                        <div key={name} className=\"col-md-3 p-2\">\n                            <div className={style.lecture}>\n                                <img\n                                    src={avatar}\n                                    className={style.avatar}\n                                    alt={name}\n                                />\n                                <p className=\"lecture-name\">{name}</p>\n                                <p\n                                    className=\"lecture-intro text-left\"\n                                    innerHTML={marked(detail) as string}\n                                />\n                            </div>\n                        </div>\n                    ))}\n                </div>\n            </Container>\n        </section>\n        <section id=\"Topic\">\n            <h2 className=\"text-center mb-5\">{t('topics')}</h2>\n            <Container>\n                <ol\n                    className={`${style.subjects} overflow-hidden list-unstyled position-relative`}\n                >\n                    {topics().map(({ lecturer, title, detail }) => (\n                        <li key={title} className={title}>\n                            <div className=\"text-center\">\n                                <h6>{lecturer.name}</h6>\n                                <img\n                                    className={style['avatar-sm']}\n                                    src={lecturer.avatar}\n                                />\n                            </div>\n                            <div>\n                                <h5>{title}</h5>\n                                <p innerHTML={marked(detail) as string} />\n                            </div>\n                        </li>\n                    ))}\n                </ol>\n            </Container>\n        </section>\n        <section className={style.sparked}>\n            <Container>\n                <div id=\"Bazaar\" className=\"mb-4\">\n                    <h2 className=\"text-center mb-5\">\n                        {t('open_source_bazaar')}\n                    </h2>\n\n                    <div className=\"row row-cols-1 row-cols-md-3 g-3\">\n                        {projects().map(\n                            ({ type, URL, title, detail, logo }) => (\n                                <div key={title} className=\"col\">\n                                    <Card className=\"overflow-hidden\">\n                                        <CardImg src={logo} />\n                                        <CardBody>\n                                            <CardTitle>\n                                                <a\n                                                    className=\"stretched-link text-primary\"\n                                                    target=\"_blank\"\n                                                    href={URL}\n                                                    rel=\"noreferrer\"\n                                                >\n                                                    {title}\n                                                </a>\n                                            </CardTitle>\n                                            <div\n                                                className={`cr cr-top cr-right cr-${\n                                                    type ? 'red' : 'blue'\n                                                }`}\n                                            >\n                                                {type\n                                                    ? t('club')\n                                                    : t('project')}\n                                            </div>\n\n                                            {detail}\n                                        </CardBody>\n                                    </Card>\n                                </div>\n                            )\n                        )}\n                    </div>\n                </div>\n                <div id=\"Enterprise\" className=\"text-center\">\n                    <h2 className=\"text-center mb-5\">\n                        {t('participating_companies')}\n                    </h2>\n                    <p className=\"text-muted\">\n                        {t(\n                            'enterprises_open_onsite_recruitment_welcome_talents'\n                        )}\n                    </p>\n                    <p className=\"text-muted\">{t('no_particular_order')}</p>\n                    <div className=\"row\">\n                        <div className=\"col-md-7\">\n                            <ul className={`${style.companies} list-inline`}>\n                                {companies.map(name => (\n                                    <li\n                                        key={name}\n                                        className=\"list-inline-item py-1 px-3 m-1 bg-white rounded\"\n                                    >\n                                        {name}\n                                    </li>\n                                ))}\n                            </ul>\n                        </div>\n                        <div className=\"col-md-5\">\n                            <Image fluid src={undraw_04} />\n                        </div>\n                    </div>\n                </div>\n            </Container>\n        </section>\n        <section id=\"Schedule\">\n            <h2 className=\"text-center mb-5\">{t('schedule')}</h2>\n            <Container>\n                <Table className=\"text-center\" striped hover>\n                    <thead>\n                        <tr>\n                            <th scope=\"col\" className=\"d-none d-md-block\">\n                                #\n                            </th>\n                            <th scope=\"col\">{t('time')}</th>\n                            <th scope=\"col\">{t('event')}</th>\n                            <th scope=\"col\">{t('main_guest')}</th>\n                        </tr>\n                    </thead>\n                    <tbody>\n                        {schedule().map(({ time, title, topic }) => (\n                            <tr key={time}>\n                                <td className=\"d-none d-md-block\" />\n                                <td className=\"text-nowrap\">{time}</td>\n                                <td>{title || `《${topic?.title}》`}</td>\n                                <td>{topic?.lecturer.name}</td>\n                            </tr>\n                        ))}\n                    </tbody>\n                </Table>\n            </Container>\n        </section>\n        <section id=\"Review\" className={style.sparked}>\n            <h2 className=\"text-center mb-5\">{t('past_highlights_review')}</h2>\n            <Container>\n                <div className={`row ${style.photos}`}>\n                    {review.map(({ title }, index) => (\n                        <div key={title} className=\"col-md-4\">\n                            <Image fluid title={title} src={photos[index]} />\n                        </div>\n                    ))}\n                </div>\n            </Container>\n        </section>\n\n        <section id=\"Address\" className=\"text-center\">\n            <h2 className=\"text-center mb-5\">{t('address')}</h2>\n            <Container>\n                <p className=\"text-muted\">\n                    {t('tianfu_ifc_building4_conference_room')}\n                </p>\n                <Ratio aspectRatio=\"21x9\">\n                    <iframe\n                        loading=\"lazy\"\n                        src={`//uri.amap.com/marker?src=fcc-cdc&callnative=1&position=104.065789,30.582013&name=${title()}`}\n                    />\n                </Ratio>\n            </Container>\n        </section>\n        <section id=\"Contributor\" className=\"text-center\">\n            <h2>{t('co_creation_partners')}</h2>\n            <Container>\n                {hosts().map(({ title, member }) => (\n                    <div\n                        key={title}\n                        className={`${style.contributorGroup} my-4`}\n                    >\n                        <h5 className=\"py-3\">\n                            {title}\n                            {t('organizer')}\n                        </h5>\n                        <LogoList member={member} />\n                    </div>\n                ))}\n            </Container>\n            <Container>\n                <div className={`${style.contributorGroup} my-4`}>\n                    {sponsors().map(({ title, member }) => (\n                        <section key={title}>\n                            <h5 className=\"py-3\">\n                                {title}\n                                {t('sponsor')}\n                            </h5>\n                            <LogoList member={member} />\n                        </section>\n                    ))}\n                </div>\n            </Container>\n            <Container>\n                <div className={`${style.contributorGroup} my-4`}>\n                    <h5 className=\"py-3\">{t('business_partner')}</h5>\n                    <LogoList member={partners} />\n                </div>\n            </Container>\n        </section>\n        <section id=\"CallInAction\" className={style.sparked}>\n            <Container className=\"text-center\">\n                <Button\n                    variant=\"primary\"\n                    size=\"lg\"\n                    target=\"_blank\"\n                    href=\"http://fcc-chengdu.mikecrm.com/tFM8Rk8\"\n                >\n                    {t('register_now')}\n                </Button>\n            </Container>\n        </section>\n        <footer className=\"pt-4 pb-3 clearfix\">\n            <Container>\n                <div className=\"d-none d-md-block\">\n                    <Nav>\n                        {sections().map(({ href, title }) => (\n                            <NavLink key={title} href={href}>\n                                {title}\n                            </NavLink>\n                        ))}\n                    </Nav>\n                </div>\n            </Container>\n        </footer>\n    </main>\n));\n","/**\n * marked v14.1.4 - a markdown parser\n * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.marked = {}));\n})(this, (function (exports) { 'use strict';\n\n    /**\n     * Gets the original marked default options.\n     */\n    function _getDefaults() {\n        return {\n            async: false,\n            breaks: false,\n            extensions: null,\n            gfm: true,\n            hooks: null,\n            pedantic: false,\n            renderer: null,\n            silent: false,\n            tokenizer: null,\n            walkTokens: null,\n        };\n    }\n    exports.defaults = _getDefaults();\n    function changeDefaults(newDefaults) {\n        exports.defaults = newDefaults;\n    }\n\n    /**\n     * Helpers\n     */\n    const escapeTest = /[&<>\"']/;\n    const escapeReplace = new RegExp(escapeTest.source, 'g');\n    const escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\n    const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');\n    const escapeReplacements = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#39;',\n    };\n    const getEscapeReplacement = (ch) => escapeReplacements[ch];\n    function escape$1(html, encode) {\n        if (encode) {\n            if (escapeTest.test(html)) {\n                return html.replace(escapeReplace, getEscapeReplacement);\n            }\n        }\n        else {\n            if (escapeTestNoEncode.test(html)) {\n                return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n            }\n        }\n        return html;\n    }\n    const caret = /(^|[^\\[])\\^/g;\n    function edit(regex, opt) {\n        let source = typeof regex === 'string' ? regex : regex.source;\n        opt = opt || '';\n        const obj = {\n            replace: (name, val) => {\n                let valSource = typeof val === 'string' ? val : val.source;\n                valSource = valSource.replace(caret, '$1');\n                source = source.replace(name, valSource);\n                return obj;\n            },\n            getRegex: () => {\n                return new RegExp(source, opt);\n            },\n        };\n        return obj;\n    }\n    function cleanUrl(href) {\n        try {\n            href = encodeURI(href).replace(/%25/g, '%');\n        }\n        catch {\n            return null;\n        }\n        return href;\n    }\n    const noopTest = { exec: () => null };\n    function splitCells(tableRow, count) {\n        // ensure that every cell-delimiting pipe has a space\n        // before it to distinguish it from an escaped pipe\n        const row = tableRow.replace(/\\|/g, (match, offset, str) => {\n            let escaped = false;\n            let curr = offset;\n            while (--curr >= 0 && str[curr] === '\\\\')\n                escaped = !escaped;\n            if (escaped) {\n                // odd number of slashes means | is escaped\n                // so we leave it alone\n                return '|';\n            }\n            else {\n                // add space before unescaped |\n                return ' |';\n            }\n        }), cells = row.split(/ \\|/);\n        let i = 0;\n        // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n        if (!cells[0].trim()) {\n            cells.shift();\n        }\n        if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n            cells.pop();\n        }\n        if (count) {\n            if (cells.length > count) {\n                cells.splice(count);\n            }\n            else {\n                while (cells.length < count)\n                    cells.push('');\n            }\n        }\n        for (; i < cells.length; i++) {\n            // leading or trailing whitespace is ignored per the gfm spec\n            cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n        }\n        return cells;\n    }\n    /**\n     * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n     * /c*$/ is vulnerable to REDOS.\n     *\n     * @param str\n     * @param c\n     * @param invert Remove suffix of non-c chars instead. Default falsey.\n     */\n    function rtrim(str, c, invert) {\n        const l = str.length;\n        if (l === 0) {\n            return '';\n        }\n        // Length of suffix matching the invert condition.\n        let suffLen = 0;\n        // Step left until we fail to match the invert condition.\n        while (suffLen < l) {\n            const currChar = str.charAt(l - suffLen - 1);\n            if (currChar === c && !invert) {\n                suffLen++;\n            }\n            else if (currChar !== c && invert) {\n                suffLen++;\n            }\n            else {\n                break;\n            }\n        }\n        return str.slice(0, l - suffLen);\n    }\n    function findClosingBracket(str, b) {\n        if (str.indexOf(b[1]) === -1) {\n            return -1;\n        }\n        let level = 0;\n        for (let i = 0; i < str.length; i++) {\n            if (str[i] === '\\\\') {\n                i++;\n            }\n            else if (str[i] === b[0]) {\n                level++;\n            }\n            else if (str[i] === b[1]) {\n                level--;\n                if (level < 0) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    function outputLink(cap, link, raw, lexer) {\n        const href = link.href;\n        const title = link.title ? escape$1(link.title) : null;\n        const text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n        if (cap[0].charAt(0) !== '!') {\n            lexer.state.inLink = true;\n            const token = {\n                type: 'link',\n                raw,\n                href,\n                title,\n                text,\n                tokens: lexer.inlineTokens(text),\n            };\n            lexer.state.inLink = false;\n            return token;\n        }\n        return {\n            type: 'image',\n            raw,\n            href,\n            title,\n            text: escape$1(text),\n        };\n    }\n    function indentCodeCompensation(raw, text) {\n        const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n        if (matchIndentToCode === null) {\n            return text;\n        }\n        const indentToCode = matchIndentToCode[1];\n        return text\n            .split('\\n')\n            .map(node => {\n            const matchIndentInNode = node.match(/^\\s+/);\n            if (matchIndentInNode === null) {\n                return node;\n            }\n            const [indentInNode] = matchIndentInNode;\n            if (indentInNode.length >= indentToCode.length) {\n                return node.slice(indentToCode.length);\n            }\n            return node;\n        })\n            .join('\\n');\n    }\n    /**\n     * Tokenizer\n     */\n    class _Tokenizer {\n        options;\n        rules; // set by the lexer\n        lexer; // set by the lexer\n        constructor(options) {\n            this.options = options || exports.defaults;\n        }\n        space(src) {\n            const cap = this.rules.block.newline.exec(src);\n            if (cap && cap[0].length > 0) {\n                return {\n                    type: 'space',\n                    raw: cap[0],\n                };\n            }\n        }\n        code(src) {\n            const cap = this.rules.block.code.exec(src);\n            if (cap) {\n                const text = cap[0].replace(/^(?: {1,4}| {0,3}\\t)/gm, '');\n                return {\n                    type: 'code',\n                    raw: cap[0],\n                    codeBlockStyle: 'indented',\n                    text: !this.options.pedantic\n                        ? rtrim(text, '\\n')\n                        : text,\n                };\n            }\n        }\n        fences(src) {\n            const cap = this.rules.block.fences.exec(src);\n            if (cap) {\n                const raw = cap[0];\n                const text = indentCodeCompensation(raw, cap[3] || '');\n                return {\n                    type: 'code',\n                    raw,\n                    lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n                    text,\n                };\n            }\n        }\n        heading(src) {\n            const cap = this.rules.block.heading.exec(src);\n            if (cap) {\n                let text = cap[2].trim();\n                // remove trailing #s\n                if (/#$/.test(text)) {\n                    const trimmed = rtrim(text, '#');\n                    if (this.options.pedantic) {\n                        text = trimmed.trim();\n                    }\n                    else if (!trimmed || / $/.test(trimmed)) {\n                        // CommonMark requires space before trailing #s\n                        text = trimmed.trim();\n                    }\n                }\n                return {\n                    type: 'heading',\n                    raw: cap[0],\n                    depth: cap[1].length,\n                    text,\n                    tokens: this.lexer.inline(text),\n                };\n            }\n        }\n        hr(src) {\n            const cap = this.rules.block.hr.exec(src);\n            if (cap) {\n                return {\n                    type: 'hr',\n                    raw: rtrim(cap[0], '\\n'),\n                };\n            }\n        }\n        blockquote(src) {\n            const cap = this.rules.block.blockquote.exec(src);\n            if (cap) {\n                let lines = rtrim(cap[0], '\\n').split('\\n');\n                let raw = '';\n                let text = '';\n                const tokens = [];\n                while (lines.length > 0) {\n                    let inBlockquote = false;\n                    const currentLines = [];\n                    let i;\n                    for (i = 0; i < lines.length; i++) {\n                        // get lines up to a continuation\n                        if (/^ {0,3}>/.test(lines[i])) {\n                            currentLines.push(lines[i]);\n                            inBlockquote = true;\n                        }\n                        else if (!inBlockquote) {\n                            currentLines.push(lines[i]);\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    lines = lines.slice(i);\n                    const currentRaw = currentLines.join('\\n');\n                    const currentText = currentRaw\n                        // precede setext continuation with 4 spaces so it isn't a setext\n                        .replace(/\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g, '\\n    $1')\n                        .replace(/^ {0,3}>[ \\t]?/gm, '');\n                    raw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n                    text = text ? `${text}\\n${currentText}` : currentText;\n                    // parse blockquote lines as top level tokens\n                    // merge paragraphs if this is a continuation\n                    const top = this.lexer.state.top;\n                    this.lexer.state.top = true;\n                    this.lexer.blockTokens(currentText, tokens, true);\n                    this.lexer.state.top = top;\n                    // if there is no continuation then we are done\n                    if (lines.length === 0) {\n                        break;\n                    }\n                    const lastToken = tokens[tokens.length - 1];\n                    if (lastToken?.type === 'code') {\n                        // blockquote continuation cannot be preceded by a code block\n                        break;\n                    }\n                    else if (lastToken?.type === 'blockquote') {\n                        // include continuation in nested blockquote\n                        const oldToken = lastToken;\n                        const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                        const newToken = this.blockquote(newText);\n                        tokens[tokens.length - 1] = newToken;\n                        raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n                        text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n                        break;\n                    }\n                    else if (lastToken?.type === 'list') {\n                        // include continuation in nested list\n                        const oldToken = lastToken;\n                        const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                        const newToken = this.list(newText);\n                        tokens[tokens.length - 1] = newToken;\n                        raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n                        text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n                        lines = newText.substring(tokens[tokens.length - 1].raw.length).split('\\n');\n                        continue;\n                    }\n                }\n                return {\n                    type: 'blockquote',\n                    raw,\n                    tokens,\n                    text,\n                };\n            }\n        }\n        list(src) {\n            let cap = this.rules.block.list.exec(src);\n            if (cap) {\n                let bull = cap[1].trim();\n                const isordered = bull.length > 1;\n                const list = {\n                    type: 'list',\n                    raw: '',\n                    ordered: isordered,\n                    start: isordered ? +bull.slice(0, -1) : '',\n                    loose: false,\n                    items: [],\n                };\n                bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n                if (this.options.pedantic) {\n                    bull = isordered ? bull : '[*+-]';\n                }\n                // Get next list item\n                const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n                let endsWithBlankLine = false;\n                // Check if current bullet point can start a new List Item\n                while (src) {\n                    let endEarly = false;\n                    let raw = '';\n                    let itemContents = '';\n                    if (!(cap = itemRegex.exec(src))) {\n                        break;\n                    }\n                    if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n                        break;\n                    }\n                    raw = cap[0];\n                    src = src.substring(raw.length);\n                    let line = cap[2].split('\\n', 1)[0].replace(/^\\t+/, (t) => ' '.repeat(3 * t.length));\n                    let nextLine = src.split('\\n', 1)[0];\n                    let blankLine = !line.trim();\n                    let indent = 0;\n                    if (this.options.pedantic) {\n                        indent = 2;\n                        itemContents = line.trimStart();\n                    }\n                    else if (blankLine) {\n                        indent = cap[1].length + 1;\n                    }\n                    else {\n                        indent = cap[2].search(/[^ ]/); // Find first non-space char\n                        indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                        itemContents = line.slice(indent);\n                        indent += cap[1].length;\n                    }\n                    if (blankLine && /^[ \\t]*$/.test(nextLine)) { // Items begin with at most one blank line\n                        raw += nextLine + '\\n';\n                        src = src.substring(nextLine.length + 1);\n                        endEarly = true;\n                    }\n                    if (!endEarly) {\n                        const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n                        const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                        const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                        const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n                        const htmlBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, 'i');\n                        // Check if following lines should be included in List Item\n                        while (src) {\n                            const rawLine = src.split('\\n', 1)[0];\n                            let nextLineWithoutTabs;\n                            nextLine = rawLine;\n                            // Re-align to follow commonmark nesting rules\n                            if (this.options.pedantic) {\n                                nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n                                nextLineWithoutTabs = nextLine;\n                            }\n                            else {\n                                nextLineWithoutTabs = nextLine.replace(/\\t/g, '    ');\n                            }\n                            // End list item if found code fences\n                            if (fencesBeginRegex.test(nextLine)) {\n                                break;\n                            }\n                            // End list item if found start of new heading\n                            if (headingBeginRegex.test(nextLine)) {\n                                break;\n                            }\n                            // End list item if found start of html block\n                            if (htmlBeginRegex.test(nextLine)) {\n                                break;\n                            }\n                            // End list item if found start of new bullet\n                            if (nextBulletRegex.test(nextLine)) {\n                                break;\n                            }\n                            // Horizontal rule found\n                            if (hrRegex.test(nextLine)) {\n                                break;\n                            }\n                            if (nextLineWithoutTabs.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible\n                                itemContents += '\\n' + nextLineWithoutTabs.slice(indent);\n                            }\n                            else {\n                                // not enough indentation\n                                if (blankLine) {\n                                    break;\n                                }\n                                // paragraph continuation unless last line was a different block level element\n                                if (line.replace(/\\t/g, '    ').search(/[^ ]/) >= 4) { // indented code block\n                                    break;\n                                }\n                                if (fencesBeginRegex.test(line)) {\n                                    break;\n                                }\n                                if (headingBeginRegex.test(line)) {\n                                    break;\n                                }\n                                if (hrRegex.test(line)) {\n                                    break;\n                                }\n                                itemContents += '\\n' + nextLine;\n                            }\n                            if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n                                blankLine = true;\n                            }\n                            raw += rawLine + '\\n';\n                            src = src.substring(rawLine.length + 1);\n                            line = nextLineWithoutTabs.slice(indent);\n                        }\n                    }\n                    if (!list.loose) {\n                        // If the previous item ended with a blank line, the list is loose\n                        if (endsWithBlankLine) {\n                            list.loose = true;\n                        }\n                        else if (/\\n[ \\t]*\\n[ \\t]*$/.test(raw)) {\n                            endsWithBlankLine = true;\n                        }\n                    }\n                    let istask = null;\n                    let ischecked;\n                    // Check for task list items\n                    if (this.options.gfm) {\n                        istask = /^\\[[ xX]\\] /.exec(itemContents);\n                        if (istask) {\n                            ischecked = istask[0] !== '[ ] ';\n                            itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n                        }\n                    }\n                    list.items.push({\n                        type: 'list_item',\n                        raw,\n                        task: !!istask,\n                        checked: ischecked,\n                        loose: false,\n                        text: itemContents,\n                        tokens: [],\n                    });\n                    list.raw += raw;\n                }\n                // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n                list.items[list.items.length - 1].raw = list.items[list.items.length - 1].raw.trimEnd();\n                list.items[list.items.length - 1].text = list.items[list.items.length - 1].text.trimEnd();\n                list.raw = list.raw.trimEnd();\n                // Item child tokens handled here at end because we needed to have the final item to trim it first\n                for (let i = 0; i < list.items.length; i++) {\n                    this.lexer.state.top = false;\n                    list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                    if (!list.loose) {\n                        // Check if list should be loose\n                        const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n                        const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\\n.*\\n/.test(t.raw));\n                        list.loose = hasMultipleLineBreaks;\n                    }\n                }\n                // Set all items to loose if list is loose\n                if (list.loose) {\n                    for (let i = 0; i < list.items.length; i++) {\n                        list.items[i].loose = true;\n                    }\n                }\n                return list;\n            }\n        }\n        html(src) {\n            const cap = this.rules.block.html.exec(src);\n            if (cap) {\n                const token = {\n                    type: 'html',\n                    block: true,\n                    raw: cap[0],\n                    pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n                    text: cap[0],\n                };\n                return token;\n            }\n        }\n        def(src) {\n            const cap = this.rules.block.def.exec(src);\n            if (cap) {\n                const tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n                const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n                const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n                return {\n                    type: 'def',\n                    tag,\n                    raw: cap[0],\n                    href,\n                    title,\n                };\n            }\n        }\n        table(src) {\n            const cap = this.rules.block.table.exec(src);\n            if (!cap) {\n                return;\n            }\n            if (!/[:|]/.test(cap[2])) {\n                // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n                return;\n            }\n            const headers = splitCells(cap[1]);\n            const aligns = cap[2].replace(/^\\||\\| *$/g, '').split('|');\n            const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, '').split('\\n') : [];\n            const item = {\n                type: 'table',\n                raw: cap[0],\n                header: [],\n                align: [],\n                rows: [],\n            };\n            if (headers.length !== aligns.length) {\n                // header and align columns must be equal, rows can be different.\n                return;\n            }\n            for (const align of aligns) {\n                if (/^ *-+: *$/.test(align)) {\n                    item.align.push('right');\n                }\n                else if (/^ *:-+: *$/.test(align)) {\n                    item.align.push('center');\n                }\n                else if (/^ *:-+ *$/.test(align)) {\n                    item.align.push('left');\n                }\n                else {\n                    item.align.push(null);\n                }\n            }\n            for (let i = 0; i < headers.length; i++) {\n                item.header.push({\n                    text: headers[i],\n                    tokens: this.lexer.inline(headers[i]),\n                    header: true,\n                    align: item.align[i],\n                });\n            }\n            for (const row of rows) {\n                item.rows.push(splitCells(row, item.header.length).map((cell, i) => {\n                    return {\n                        text: cell,\n                        tokens: this.lexer.inline(cell),\n                        header: false,\n                        align: item.align[i],\n                    };\n                }));\n            }\n            return item;\n        }\n        lheading(src) {\n            const cap = this.rules.block.lheading.exec(src);\n            if (cap) {\n                return {\n                    type: 'heading',\n                    raw: cap[0],\n                    depth: cap[2].charAt(0) === '=' ? 1 : 2,\n                    text: cap[1],\n                    tokens: this.lexer.inline(cap[1]),\n                };\n            }\n        }\n        paragraph(src) {\n            const cap = this.rules.block.paragraph.exec(src);\n            if (cap) {\n                const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n                    ? cap[1].slice(0, -1)\n                    : cap[1];\n                return {\n                    type: 'paragraph',\n                    raw: cap[0],\n                    text,\n                    tokens: this.lexer.inline(text),\n                };\n            }\n        }\n        text(src) {\n            const cap = this.rules.block.text.exec(src);\n            if (cap) {\n                return {\n                    type: 'text',\n                    raw: cap[0],\n                    text: cap[0],\n                    tokens: this.lexer.inline(cap[0]),\n                };\n            }\n        }\n        escape(src) {\n            const cap = this.rules.inline.escape.exec(src);\n            if (cap) {\n                return {\n                    type: 'escape',\n                    raw: cap[0],\n                    text: escape$1(cap[1]),\n                };\n            }\n        }\n        tag(src) {\n            const cap = this.rules.inline.tag.exec(src);\n            if (cap) {\n                if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n                    this.lexer.state.inLink = true;\n                }\n                else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n                    this.lexer.state.inLink = false;\n                }\n                if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                    this.lexer.state.inRawBlock = true;\n                }\n                else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                    this.lexer.state.inRawBlock = false;\n                }\n                return {\n                    type: 'html',\n                    raw: cap[0],\n                    inLink: this.lexer.state.inLink,\n                    inRawBlock: this.lexer.state.inRawBlock,\n                    block: false,\n                    text: cap[0],\n                };\n            }\n        }\n        link(src) {\n            const cap = this.rules.inline.link.exec(src);\n            if (cap) {\n                const trimmedUrl = cap[2].trim();\n                if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                    // commonmark requires matching angle brackets\n                    if (!(/>$/.test(trimmedUrl))) {\n                        return;\n                    }\n                    // ending angle bracket cannot be escaped\n                    const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n                    if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                        return;\n                    }\n                }\n                else {\n                    // find closing parenthesis\n                    const lastParenIndex = findClosingBracket(cap[2], '()');\n                    if (lastParenIndex > -1) {\n                        const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n                        const linkLen = start + cap[1].length + lastParenIndex;\n                        cap[2] = cap[2].substring(0, lastParenIndex);\n                        cap[0] = cap[0].substring(0, linkLen).trim();\n                        cap[3] = '';\n                    }\n                }\n                let href = cap[2];\n                let title = '';\n                if (this.options.pedantic) {\n                    // split pedantic href and title\n                    const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n                    if (link) {\n                        href = link[1];\n                        title = link[3];\n                    }\n                }\n                else {\n                    title = cap[3] ? cap[3].slice(1, -1) : '';\n                }\n                href = href.trim();\n                if (/^</.test(href)) {\n                    if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {\n                        // pedantic allows starting angle bracket without ending angle bracket\n                        href = href.slice(1);\n                    }\n                    else {\n                        href = href.slice(1, -1);\n                    }\n                }\n                return outputLink(cap, {\n                    href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n                    title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,\n                }, cap[0], this.lexer);\n            }\n        }\n        reflink(src, links) {\n            let cap;\n            if ((cap = this.rules.inline.reflink.exec(src))\n                || (cap = this.rules.inline.nolink.exec(src))) {\n                const linkString = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n                const link = links[linkString.toLowerCase()];\n                if (!link) {\n                    const text = cap[0].charAt(0);\n                    return {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    };\n                }\n                return outputLink(cap, link, cap[0], this.lexer);\n            }\n        }\n        emStrong(src, maskedSrc, prevChar = '') {\n            let match = this.rules.inline.emStrongLDelim.exec(src);\n            if (!match)\n                return;\n            // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n            if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u))\n                return;\n            const nextChar = match[1] || match[2] || '';\n            if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n                // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n                const lLength = [...match[0]].length - 1;\n                let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n                const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n                endReg.lastIndex = 0;\n                // Clip maskedSrc to same section of string as src (move to lexer?)\n                maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n                while ((match = endReg.exec(maskedSrc)) != null) {\n                    rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                    if (!rDelim)\n                        continue; // skip single * in __abc*abc__\n                    rLength = [...rDelim].length;\n                    if (match[3] || match[4]) { // found another Left Delim\n                        delimTotal += rLength;\n                        continue;\n                    }\n                    else if (match[5] || match[6]) { // either Left or Right Delim\n                        if (lLength % 3 && !((lLength + rLength) % 3)) {\n                            midDelimTotal += rLength;\n                            continue; // CommonMark Emphasis Rules 9-10\n                        }\n                    }\n                    delimTotal -= rLength;\n                    if (delimTotal > 0)\n                        continue; // Haven't found enough closing delimiters\n                    // Remove extra characters. *a*** -> *a*\n                    rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                    // char length can be >1 for unicode characters;\n                    const lastCharLength = [...match[0]][0].length;\n                    const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                    // Create `em` if smallest delimiter has odd char count. *a***\n                    if (Math.min(lLength, rLength) % 2) {\n                        const text = raw.slice(1, -1);\n                        return {\n                            type: 'em',\n                            raw,\n                            text,\n                            tokens: this.lexer.inlineTokens(text),\n                        };\n                    }\n                    // Create 'strong' if smallest delimiter has even char count. **a***\n                    const text = raw.slice(2, -2);\n                    return {\n                        type: 'strong',\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text),\n                    };\n                }\n            }\n        }\n        codespan(src) {\n            const cap = this.rules.inline.code.exec(src);\n            if (cap) {\n                let text = cap[2].replace(/\\n/g, ' ');\n                const hasNonSpaceChars = /[^ ]/.test(text);\n                const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n                if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                    text = text.substring(1, text.length - 1);\n                }\n                text = escape$1(text, true);\n                return {\n                    type: 'codespan',\n                    raw: cap[0],\n                    text,\n                };\n            }\n        }\n        br(src) {\n            const cap = this.rules.inline.br.exec(src);\n            if (cap) {\n                return {\n                    type: 'br',\n                    raw: cap[0],\n                };\n            }\n        }\n        del(src) {\n            const cap = this.rules.inline.del.exec(src);\n            if (cap) {\n                return {\n                    type: 'del',\n                    raw: cap[0],\n                    text: cap[2],\n                    tokens: this.lexer.inlineTokens(cap[2]),\n                };\n            }\n        }\n        autolink(src) {\n            const cap = this.rules.inline.autolink.exec(src);\n            if (cap) {\n                let text, href;\n                if (cap[2] === '@') {\n                    text = escape$1(cap[1]);\n                    href = 'mailto:' + text;\n                }\n                else {\n                    text = escape$1(cap[1]);\n                    href = text;\n                }\n                return {\n                    type: 'link',\n                    raw: cap[0],\n                    text,\n                    href,\n                    tokens: [\n                        {\n                            type: 'text',\n                            raw: text,\n                            text,\n                        },\n                    ],\n                };\n            }\n        }\n        url(src) {\n            let cap;\n            if (cap = this.rules.inline.url.exec(src)) {\n                let text, href;\n                if (cap[2] === '@') {\n                    text = escape$1(cap[0]);\n                    href = 'mailto:' + text;\n                }\n                else {\n                    // do extended autolink path validation\n                    let prevCapZero;\n                    do {\n                        prevCapZero = cap[0];\n                        cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n                    } while (prevCapZero !== cap[0]);\n                    text = escape$1(cap[0]);\n                    if (cap[1] === 'www.') {\n                        href = 'http://' + cap[0];\n                    }\n                    else {\n                        href = cap[0];\n                    }\n                }\n                return {\n                    type: 'link',\n                    raw: cap[0],\n                    text,\n                    href,\n                    tokens: [\n                        {\n                            type: 'text',\n                            raw: text,\n                            text,\n                        },\n                    ],\n                };\n            }\n        }\n        inlineText(src) {\n            const cap = this.rules.inline.text.exec(src);\n            if (cap) {\n                let text;\n                if (this.lexer.state.inRawBlock) {\n                    text = cap[0];\n                }\n                else {\n                    text = escape$1(cap[0]);\n                }\n                return {\n                    type: 'text',\n                    raw: cap[0],\n                    text,\n                };\n            }\n        }\n    }\n\n    /**\n     * Block-Level Grammar\n     */\n    const newline = /^(?:[ \\t]*(?:\\n|$))+/;\n    const blockCode = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/;\n    const fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\n    const hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\n    const heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\n    const bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n    const lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/)\n        .replace(/bull/g, bullet) // lists can interrupt\n        .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n        .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n        .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n        .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n        .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n        .getRegex();\n    const _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\n    const blockText = /^[^\\n]+/;\n    const _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\n    const def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/)\n        .replace('label', _blockLabel)\n        .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n        .getRegex();\n    const list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n        .replace(/bull/g, bullet)\n        .getRegex();\n    const _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n        + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n        + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n        + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n        + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n        + '|tr|track|ul';\n    const _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\n    const html = edit('^ {0,3}(?:' // optional indentation\n        + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n        + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n        + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n        + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n        + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n        + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (6)\n        + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) open tag\n        + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) closing tag\n        + ')', 'i')\n        .replace('comment', _comment)\n        .replace('tag', _tag)\n        .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n        .getRegex();\n    const paragraph = edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n        .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n        .replace('|table', '')\n        .replace('blockquote', ' {0,3}>')\n        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n        .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n        .getRegex();\n    const blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n        .replace('paragraph', paragraph)\n        .getRegex();\n    /**\n     * Normal Block Grammar\n     */\n    const blockNormal = {\n        blockquote,\n        code: blockCode,\n        def,\n        fences,\n        heading,\n        hr,\n        html,\n        lheading,\n        list,\n        newline,\n        paragraph,\n        table: noopTest,\n        text: blockText,\n    };\n    /**\n     * GFM Block Grammar\n     */\n    const gfmTable = edit('^ *([^\\\\n ].*)\\\\n' // Header\n        + ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n        + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n        .replace('hr', hr)\n        .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n        .replace('blockquote', ' {0,3}>')\n        .replace('code', '(?: {4}| {0,3}\\t)[^\\\\n]')\n        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n        .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n        .getRegex();\n    const blockGfm = {\n        ...blockNormal,\n        table: gfmTable,\n        paragraph: edit(_paragraph)\n            .replace('hr', hr)\n            .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n            .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n            .replace('table', gfmTable) // interrupt paragraphs with table\n            .replace('blockquote', ' {0,3}>')\n            .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n            .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n            .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n            .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n            .getRegex(),\n    };\n    /**\n     * Pedantic grammar (original John Gruber's loose markdown specification)\n     */\n    const blockPedantic = {\n        ...blockNormal,\n        html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)'\n            + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n            + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n            .replace('comment', _comment)\n            .replace(/tag/g, '(?!(?:'\n            + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n            + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n            + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n            .getRegex(),\n        def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n        heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n        fences: noopTest, // fences not supported\n        lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n        paragraph: edit(_paragraph)\n            .replace('hr', hr)\n            .replace('heading', ' *#{1,6} *[^\\n]')\n            .replace('lheading', lheading)\n            .replace('|table', '')\n            .replace('blockquote', ' {0,3}>')\n            .replace('|fences', '')\n            .replace('|list', '')\n            .replace('|html', '')\n            .replace('|tag', '')\n            .getRegex(),\n    };\n    /**\n     * Inline-Level Grammar\n     */\n    const escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\n    const inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\n    const br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\n    const inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n    // list of unicode punctuation marks, plus any missing characters from CommonMark spec\n    const _punctuation = '\\\\p{P}\\\\p{S}';\n    const punctuation = edit(/^((?![*_])[\\spunctuation])/, 'u')\n        .replace(/punctuation/g, _punctuation).getRegex();\n    // sequences em should skip over [title](link), `code`, <html>\n    const blockSkip = /\\[[^[\\]]*?\\]\\((?:\\\\.|[^\\\\\\(\\)]|\\((?:\\\\.|[^\\\\\\(\\)])*\\))*\\)|`[^`]*?`|<[^<>]*?>/g;\n    const emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, 'u')\n        .replace(/punct/g, _punctuation)\n        .getRegex();\n    const emStrongRDelimAst = edit('^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n        + '|[^*]+(?=[^*])' // Consume to delim\n        + '|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n        + '|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)' // (2) a***#, a*** can only be a Right Delimiter\n        + '|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])' // (3) #***a, ***a can only be Left Delimiter\n        + '|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])' // (4) ***# can only be Left Delimiter\n        + '|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])' // (5) #***# can be either Left or Right Delimiter\n        + '|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])', 'gu') // (6) a***a can be either Left or Right Delimiter\n        .replace(/punct/g, _punctuation)\n        .getRegex();\n    // (6) Not allowed for _\n    const emStrongRDelimUnd = edit('^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n        + '|[^_]+(?=[^_])' // Consume to delim\n        + '|(?!_)[punct](_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n        + '|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)' // (2) a___#, a___ can only be a Right Delimiter\n        + '|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])' // (3) #___a, ___a can only be Left Delimiter\n        + '|[\\\\s](_+)(?!_)(?=[punct])' // (4) ___# can only be Left Delimiter\n        + '|(?!_)[punct](_+)(?!_)(?=[punct])', 'gu') // (5) #___# can be either Left or Right Delimiter\n        .replace(/punct/g, _punctuation)\n        .getRegex();\n    const anyPunctuation = edit(/\\\\([punct])/, 'gu')\n        .replace(/punct/g, _punctuation)\n        .getRegex();\n    const autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n        .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n        .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n        .getRegex();\n    const _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\n    const tag = edit('^comment'\n        + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n        + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n        + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n        + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n        + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n        .replace('comment', _inlineComment)\n        .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n        .getRegex();\n    const _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n    const link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/)\n        .replace('label', _inlineLabel)\n        .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/)\n        .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n        .getRegex();\n    const reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n        .replace('label', _inlineLabel)\n        .replace('ref', _blockLabel)\n        .getRegex();\n    const nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n        .replace('ref', _blockLabel)\n        .getRegex();\n    const reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n        .replace('reflink', reflink)\n        .replace('nolink', nolink)\n        .getRegex();\n    /**\n     * Normal Inline Grammar\n     */\n    const inlineNormal = {\n        _backpedal: noopTest, // only used for GFM url\n        anyPunctuation,\n        autolink,\n        blockSkip,\n        br,\n        code: inlineCode,\n        del: noopTest,\n        emStrongLDelim,\n        emStrongRDelimAst,\n        emStrongRDelimUnd,\n        escape,\n        link,\n        nolink,\n        punctuation,\n        reflink,\n        reflinkSearch,\n        tag,\n        text: inlineText,\n        url: noopTest,\n    };\n    /**\n     * Pedantic Inline Grammar\n     */\n    const inlinePedantic = {\n        ...inlineNormal,\n        link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n            .replace('label', _inlineLabel)\n            .getRegex(),\n        reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n            .replace('label', _inlineLabel)\n            .getRegex(),\n    };\n    /**\n     * GFM Inline Grammar\n     */\n    const inlineGfm = {\n        ...inlineNormal,\n        escape: edit(escape).replace('])', '~|])').getRegex(),\n        url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i')\n            .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n            .getRegex(),\n        _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n        del: /^(~~?)(?=[^\\s~])((?:\\\\.|[^\\\\])*?(?:\\\\.|[^\\s~\\\\]))\\1(?=[^~]|$)/,\n        text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/,\n    };\n    /**\n     * GFM + Line Breaks Inline Grammar\n     */\n    const inlineBreaks = {\n        ...inlineGfm,\n        br: edit(br).replace('{2,}', '*').getRegex(),\n        text: edit(inlineGfm.text)\n            .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n            .replace(/\\{2,\\}/g, '*')\n            .getRegex(),\n    };\n    /**\n     * exports\n     */\n    const block = {\n        normal: blockNormal,\n        gfm: blockGfm,\n        pedantic: blockPedantic,\n    };\n    const inline = {\n        normal: inlineNormal,\n        gfm: inlineGfm,\n        breaks: inlineBreaks,\n        pedantic: inlinePedantic,\n    };\n\n    /**\n     * Block Lexer\n     */\n    class _Lexer {\n        tokens;\n        options;\n        state;\n        tokenizer;\n        inlineQueue;\n        constructor(options) {\n            // TokenList cannot be created in one go\n            this.tokens = [];\n            this.tokens.links = Object.create(null);\n            this.options = options || exports.defaults;\n            this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n            this.tokenizer = this.options.tokenizer;\n            this.tokenizer.options = this.options;\n            this.tokenizer.lexer = this;\n            this.inlineQueue = [];\n            this.state = {\n                inLink: false,\n                inRawBlock: false,\n                top: true,\n            };\n            const rules = {\n                block: block.normal,\n                inline: inline.normal,\n            };\n            if (this.options.pedantic) {\n                rules.block = block.pedantic;\n                rules.inline = inline.pedantic;\n            }\n            else if (this.options.gfm) {\n                rules.block = block.gfm;\n                if (this.options.breaks) {\n                    rules.inline = inline.breaks;\n                }\n                else {\n                    rules.inline = inline.gfm;\n                }\n            }\n            this.tokenizer.rules = rules;\n        }\n        /**\n         * Expose Rules\n         */\n        static get rules() {\n            return {\n                block,\n                inline,\n            };\n        }\n        /**\n         * Static Lex Method\n         */\n        static lex(src, options) {\n            const lexer = new _Lexer(options);\n            return lexer.lex(src);\n        }\n        /**\n         * Static Lex Inline Method\n         */\n        static lexInline(src, options) {\n            const lexer = new _Lexer(options);\n            return lexer.inlineTokens(src);\n        }\n        /**\n         * Preprocessing\n         */\n        lex(src) {\n            src = src\n                .replace(/\\r\\n|\\r/g, '\\n');\n            this.blockTokens(src, this.tokens);\n            for (let i = 0; i < this.inlineQueue.length; i++) {\n                const next = this.inlineQueue[i];\n                this.inlineTokens(next.src, next.tokens);\n            }\n            this.inlineQueue = [];\n            return this.tokens;\n        }\n        blockTokens(src, tokens = [], lastParagraphClipped = false) {\n            if (this.options.pedantic) {\n                src = src.replace(/\\t/g, '    ').replace(/^ +$/gm, '');\n            }\n            let token;\n            let lastToken;\n            let cutSrc;\n            while (src) {\n                if (this.options.extensions\n                    && this.options.extensions.block\n                    && this.options.extensions.block.some((extTokenizer) => {\n                        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                            src = src.substring(token.raw.length);\n                            tokens.push(token);\n                            return true;\n                        }\n                        return false;\n                    })) {\n                    continue;\n                }\n                // newline\n                if (token = this.tokenizer.space(src)) {\n                    src = src.substring(token.raw.length);\n                    if (token.raw.length === 1 && tokens.length > 0) {\n                        // if there's a single \\n as a spacer, it's terminating the last line,\n                        // so move it there so that we don't get unnecessary paragraph tags\n                        tokens[tokens.length - 1].raw += '\\n';\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                // code\n                if (token = this.tokenizer.code(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    // An indented code block cannot interrupt a paragraph.\n                    if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                        lastToken.raw += '\\n' + token.raw;\n                        lastToken.text += '\\n' + token.text;\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                // fences\n                if (token = this.tokenizer.fences(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // heading\n                if (token = this.tokenizer.heading(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // hr\n                if (token = this.tokenizer.hr(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // blockquote\n                if (token = this.tokenizer.blockquote(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // list\n                if (token = this.tokenizer.list(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // html\n                if (token = this.tokenizer.html(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // def\n                if (token = this.tokenizer.def(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                        lastToken.raw += '\\n' + token.raw;\n                        lastToken.text += '\\n' + token.raw;\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    }\n                    else if (!this.tokens.links[token.tag]) {\n                        this.tokens.links[token.tag] = {\n                            href: token.href,\n                            title: token.title,\n                        };\n                    }\n                    continue;\n                }\n                // table (gfm)\n                if (token = this.tokenizer.table(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // lheading\n                if (token = this.tokenizer.lheading(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // top-level paragraph\n                // prevent paragraph consuming extensions by clipping 'src' to extension start\n                cutSrc = src;\n                if (this.options.extensions && this.options.extensions.startBlock) {\n                    let startIndex = Infinity;\n                    const tempSrc = src.slice(1);\n                    let tempStart;\n                    this.options.extensions.startBlock.forEach((getStartIndex) => {\n                        tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                        if (typeof tempStart === 'number' && tempStart >= 0) {\n                            startIndex = Math.min(startIndex, tempStart);\n                        }\n                    });\n                    if (startIndex < Infinity && startIndex >= 0) {\n                        cutSrc = src.substring(0, startIndex + 1);\n                    }\n                }\n                if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastParagraphClipped && lastToken?.type === 'paragraph') {\n                        lastToken.raw += '\\n' + token.raw;\n                        lastToken.text += '\\n' + token.text;\n                        this.inlineQueue.pop();\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    lastParagraphClipped = (cutSrc.length !== src.length);\n                    src = src.substring(token.raw.length);\n                    continue;\n                }\n                // text\n                if (token = this.tokenizer.text(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && lastToken.type === 'text') {\n                        lastToken.raw += '\\n' + token.raw;\n                        lastToken.text += '\\n' + token.text;\n                        this.inlineQueue.pop();\n                        this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                if (src) {\n                    const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        break;\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n            this.state.top = true;\n            return tokens;\n        }\n        inline(src, tokens = []) {\n            this.inlineQueue.push({ src, tokens });\n            return tokens;\n        }\n        /**\n         * Lexing/Compiling\n         */\n        inlineTokens(src, tokens = []) {\n            let token, lastToken, cutSrc;\n            // String with links masked to avoid interference with em and strong\n            let maskedSrc = src;\n            let match;\n            let keepPrevChar, prevChar;\n            // Mask out reflinks\n            if (this.tokens.links) {\n                const links = Object.keys(this.tokens.links);\n                if (links.length > 0) {\n                    while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n                        if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n                            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                        }\n                    }\n                }\n            }\n            // Mask out other blocks\n            while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n                maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n            }\n            // Mask out escaped characters\n            while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n                maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n            }\n            while (src) {\n                if (!keepPrevChar) {\n                    prevChar = '';\n                }\n                keepPrevChar = false;\n                // extensions\n                if (this.options.extensions\n                    && this.options.extensions.inline\n                    && this.options.extensions.inline.some((extTokenizer) => {\n                        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                            src = src.substring(token.raw.length);\n                            tokens.push(token);\n                            return true;\n                        }\n                        return false;\n                    })) {\n                    continue;\n                }\n                // escape\n                if (token = this.tokenizer.escape(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // tag\n                if (token = this.tokenizer.tag(src)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                // link\n                if (token = this.tokenizer.link(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // reflink, nolink\n                if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                    src = src.substring(token.raw.length);\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                // em & strong\n                if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // code\n                if (token = this.tokenizer.codespan(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // br\n                if (token = this.tokenizer.br(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // del (gfm)\n                if (token = this.tokenizer.del(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // autolink\n                if (token = this.tokenizer.autolink(src)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // url (gfm)\n                if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    continue;\n                }\n                // text\n                // prevent inlineText consuming extensions by clipping 'src' to extension start\n                cutSrc = src;\n                if (this.options.extensions && this.options.extensions.startInline) {\n                    let startIndex = Infinity;\n                    const tempSrc = src.slice(1);\n                    let tempStart;\n                    this.options.extensions.startInline.forEach((getStartIndex) => {\n                        tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                        if (typeof tempStart === 'number' && tempStart >= 0) {\n                            startIndex = Math.min(startIndex, tempStart);\n                        }\n                    });\n                    if (startIndex < Infinity && startIndex >= 0) {\n                        cutSrc = src.substring(0, startIndex + 1);\n                    }\n                }\n                if (token = this.tokenizer.inlineText(cutSrc)) {\n                    src = src.substring(token.raw.length);\n                    if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n                        prevChar = token.raw.slice(-1);\n                    }\n                    keepPrevChar = true;\n                    lastToken = tokens[tokens.length - 1];\n                    if (lastToken && lastToken.type === 'text') {\n                        lastToken.raw += token.raw;\n                        lastToken.text += token.text;\n                    }\n                    else {\n                        tokens.push(token);\n                    }\n                    continue;\n                }\n                if (src) {\n                    const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        break;\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n            return tokens;\n        }\n    }\n\n    /**\n     * Renderer\n     */\n    class _Renderer {\n        options;\n        parser; // set by the parser\n        constructor(options) {\n            this.options = options || exports.defaults;\n        }\n        space(token) {\n            return '';\n        }\n        code({ text, lang, escaped }) {\n            const langString = (lang || '').match(/^\\S*/)?.[0];\n            const code = text.replace(/\\n$/, '') + '\\n';\n            if (!langString) {\n                return '<pre><code>'\n                    + (escaped ? code : escape$1(code, true))\n                    + '</code></pre>\\n';\n            }\n            return '<pre><code class=\"language-'\n                + escape$1(langString)\n                + '\">'\n                + (escaped ? code : escape$1(code, true))\n                + '</code></pre>\\n';\n        }\n        blockquote({ tokens }) {\n            const body = this.parser.parse(tokens);\n            return `<blockquote>\\n${body}</blockquote>\\n`;\n        }\n        html({ text }) {\n            return text;\n        }\n        heading({ tokens, depth }) {\n            return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n`;\n        }\n        hr(token) {\n            return '<hr>\\n';\n        }\n        list(token) {\n            const ordered = token.ordered;\n            const start = token.start;\n            let body = '';\n            for (let j = 0; j < token.items.length; j++) {\n                const item = token.items[j];\n                body += this.listitem(item);\n            }\n            const type = ordered ? 'ol' : 'ul';\n            const startAttr = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n            return '<' + type + startAttr + '>\\n' + body + '</' + type + '>\\n';\n        }\n        listitem(item) {\n            let itemBody = '';\n            if (item.task) {\n                const checkbox = this.checkbox({ checked: !!item.checked });\n                if (item.loose) {\n                    if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n                        item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                            item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                        }\n                    }\n                    else {\n                        item.tokens.unshift({\n                            type: 'text',\n                            raw: checkbox + ' ',\n                            text: checkbox + ' ',\n                        });\n                    }\n                }\n                else {\n                    itemBody += checkbox + ' ';\n                }\n            }\n            itemBody += this.parser.parse(item.tokens, !!item.loose);\n            return `<li>${itemBody}</li>\\n`;\n        }\n        checkbox({ checked }) {\n            return '<input '\n                + (checked ? 'checked=\"\" ' : '')\n                + 'disabled=\"\" type=\"checkbox\">';\n        }\n        paragraph({ tokens }) {\n            return `<p>${this.parser.parseInline(tokens)}</p>\\n`;\n        }\n        table(token) {\n            let header = '';\n            // header\n            let cell = '';\n            for (let j = 0; j < token.header.length; j++) {\n                cell += this.tablecell(token.header[j]);\n            }\n            header += this.tablerow({ text: cell });\n            let body = '';\n            for (let j = 0; j < token.rows.length; j++) {\n                const row = token.rows[j];\n                cell = '';\n                for (let k = 0; k < row.length; k++) {\n                    cell += this.tablecell(row[k]);\n                }\n                body += this.tablerow({ text: cell });\n            }\n            if (body)\n                body = `<tbody>${body}</tbody>`;\n            return '<table>\\n'\n                + '<thead>\\n'\n                + header\n                + '</thead>\\n'\n                + body\n                + '</table>\\n';\n        }\n        tablerow({ text }) {\n            return `<tr>\\n${text}</tr>\\n`;\n        }\n        tablecell(token) {\n            const content = this.parser.parseInline(token.tokens);\n            const type = token.header ? 'th' : 'td';\n            const tag = token.align\n                ? `<${type} align=\"${token.align}\">`\n                : `<${type}>`;\n            return tag + content + `</${type}>\\n`;\n        }\n        /**\n         * span level renderer\n         */\n        strong({ tokens }) {\n            return `<strong>${this.parser.parseInline(tokens)}</strong>`;\n        }\n        em({ tokens }) {\n            return `<em>${this.parser.parseInline(tokens)}</em>`;\n        }\n        codespan({ text }) {\n            return `<code>${text}</code>`;\n        }\n        br(token) {\n            return '<br>';\n        }\n        del({ tokens }) {\n            return `<del>${this.parser.parseInline(tokens)}</del>`;\n        }\n        link({ href, title, tokens }) {\n            const text = this.parser.parseInline(tokens);\n            const cleanHref = cleanUrl(href);\n            if (cleanHref === null) {\n                return text;\n            }\n            href = cleanHref;\n            let out = '<a href=\"' + href + '\"';\n            if (title) {\n                out += ' title=\"' + title + '\"';\n            }\n            out += '>' + text + '</a>';\n            return out;\n        }\n        image({ href, title, text }) {\n            const cleanHref = cleanUrl(href);\n            if (cleanHref === null) {\n                return text;\n            }\n            href = cleanHref;\n            let out = `<img src=\"${href}\" alt=\"${text}\"`;\n            if (title) {\n                out += ` title=\"${title}\"`;\n            }\n            out += '>';\n            return out;\n        }\n        text(token) {\n            return 'tokens' in token && token.tokens ? this.parser.parseInline(token.tokens) : token.text;\n        }\n    }\n\n    /**\n     * TextRenderer\n     * returns only the textual part of the token\n     */\n    class _TextRenderer {\n        // no need for block level renderers\n        strong({ text }) {\n            return text;\n        }\n        em({ text }) {\n            return text;\n        }\n        codespan({ text }) {\n            return text;\n        }\n        del({ text }) {\n            return text;\n        }\n        html({ text }) {\n            return text;\n        }\n        text({ text }) {\n            return text;\n        }\n        link({ text }) {\n            return '' + text;\n        }\n        image({ text }) {\n            return '' + text;\n        }\n        br() {\n            return '';\n        }\n    }\n\n    /**\n     * Parsing & Compiling\n     */\n    class _Parser {\n        options;\n        renderer;\n        textRenderer;\n        constructor(options) {\n            this.options = options || exports.defaults;\n            this.options.renderer = this.options.renderer || new _Renderer();\n            this.renderer = this.options.renderer;\n            this.renderer.options = this.options;\n            this.renderer.parser = this;\n            this.textRenderer = new _TextRenderer();\n        }\n        /**\n         * Static Parse Method\n         */\n        static parse(tokens, options) {\n            const parser = new _Parser(options);\n            return parser.parse(tokens);\n        }\n        /**\n         * Static Parse Inline Method\n         */\n        static parseInline(tokens, options) {\n            const parser = new _Parser(options);\n            return parser.parseInline(tokens);\n        }\n        /**\n         * Parse Loop\n         */\n        parse(tokens, top = true) {\n            let out = '';\n            for (let i = 0; i < tokens.length; i++) {\n                const anyToken = tokens[i];\n                // Run any renderer extensions\n                if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {\n                    const genericToken = anyToken;\n                    const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n                    if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {\n                        out += ret || '';\n                        continue;\n                    }\n                }\n                const token = anyToken;\n                switch (token.type) {\n                    case 'space': {\n                        out += this.renderer.space(token);\n                        continue;\n                    }\n                    case 'hr': {\n                        out += this.renderer.hr(token);\n                        continue;\n                    }\n                    case 'heading': {\n                        out += this.renderer.heading(token);\n                        continue;\n                    }\n                    case 'code': {\n                        out += this.renderer.code(token);\n                        continue;\n                    }\n                    case 'table': {\n                        out += this.renderer.table(token);\n                        continue;\n                    }\n                    case 'blockquote': {\n                        out += this.renderer.blockquote(token);\n                        continue;\n                    }\n                    case 'list': {\n                        out += this.renderer.list(token);\n                        continue;\n                    }\n                    case 'html': {\n                        out += this.renderer.html(token);\n                        continue;\n                    }\n                    case 'paragraph': {\n                        out += this.renderer.paragraph(token);\n                        continue;\n                    }\n                    case 'text': {\n                        let textToken = token;\n                        let body = this.renderer.text(textToken);\n                        while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n                            textToken = tokens[++i];\n                            body += '\\n' + this.renderer.text(textToken);\n                        }\n                        if (top) {\n                            out += this.renderer.paragraph({\n                                type: 'paragraph',\n                                raw: body,\n                                text: body,\n                                tokens: [{ type: 'text', raw: body, text: body }],\n                            });\n                        }\n                        else {\n                            out += body;\n                        }\n                        continue;\n                    }\n                    default: {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return '';\n                        }\n                        else {\n                            throw new Error(errMsg);\n                        }\n                    }\n                }\n            }\n            return out;\n        }\n        /**\n         * Parse Inline Tokens\n         */\n        parseInline(tokens, renderer) {\n            renderer = renderer || this.renderer;\n            let out = '';\n            for (let i = 0; i < tokens.length; i++) {\n                const anyToken = tokens[i];\n                // Run any renderer extensions\n                if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {\n                    const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);\n                    if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {\n                        out += ret || '';\n                        continue;\n                    }\n                }\n                const token = anyToken;\n                switch (token.type) {\n                    case 'escape': {\n                        out += renderer.text(token);\n                        break;\n                    }\n                    case 'html': {\n                        out += renderer.html(token);\n                        break;\n                    }\n                    case 'link': {\n                        out += renderer.link(token);\n                        break;\n                    }\n                    case 'image': {\n                        out += renderer.image(token);\n                        break;\n                    }\n                    case 'strong': {\n                        out += renderer.strong(token);\n                        break;\n                    }\n                    case 'em': {\n                        out += renderer.em(token);\n                        break;\n                    }\n                    case 'codespan': {\n                        out += renderer.codespan(token);\n                        break;\n                    }\n                    case 'br': {\n                        out += renderer.br(token);\n                        break;\n                    }\n                    case 'del': {\n                        out += renderer.del(token);\n                        break;\n                    }\n                    case 'text': {\n                        out += renderer.text(token);\n                        break;\n                    }\n                    default: {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return '';\n                        }\n                        else {\n                            throw new Error(errMsg);\n                        }\n                    }\n                }\n            }\n            return out;\n        }\n    }\n\n    class _Hooks {\n        options;\n        block;\n        constructor(options) {\n            this.options = options || exports.defaults;\n        }\n        static passThroughHooks = new Set([\n            'preprocess',\n            'postprocess',\n            'processAllTokens',\n        ]);\n        /**\n         * Process markdown before marked\n         */\n        preprocess(markdown) {\n            return markdown;\n        }\n        /**\n         * Process HTML after marked is finished\n         */\n        postprocess(html) {\n            return html;\n        }\n        /**\n         * Process all tokens before walk tokens\n         */\n        processAllTokens(tokens) {\n            return tokens;\n        }\n        /**\n         * Provide function to tokenize markdown\n         */\n        provideLexer() {\n            return this.block ? _Lexer.lex : _Lexer.lexInline;\n        }\n        /**\n         * Provide function to parse tokens\n         */\n        provideParser() {\n            return this.block ? _Parser.parse : _Parser.parseInline;\n        }\n    }\n\n    class Marked {\n        defaults = _getDefaults();\n        options = this.setOptions;\n        parse = this.parseMarkdown(true);\n        parseInline = this.parseMarkdown(false);\n        Parser = _Parser;\n        Renderer = _Renderer;\n        TextRenderer = _TextRenderer;\n        Lexer = _Lexer;\n        Tokenizer = _Tokenizer;\n        Hooks = _Hooks;\n        constructor(...args) {\n            this.use(...args);\n        }\n        /**\n         * Run callback for every token\n         */\n        walkTokens(tokens, callback) {\n            let values = [];\n            for (const token of tokens) {\n                values = values.concat(callback.call(this, token));\n                switch (token.type) {\n                    case 'table': {\n                        const tableToken = token;\n                        for (const cell of tableToken.header) {\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                        for (const row of tableToken.rows) {\n                            for (const cell of row) {\n                                values = values.concat(this.walkTokens(cell.tokens, callback));\n                            }\n                        }\n                        break;\n                    }\n                    case 'list': {\n                        const listToken = token;\n                        values = values.concat(this.walkTokens(listToken.items, callback));\n                        break;\n                    }\n                    default: {\n                        const genericToken = token;\n                        if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n                                const tokens = genericToken[childTokens].flat(Infinity);\n                                values = values.concat(this.walkTokens(tokens, callback));\n                            });\n                        }\n                        else if (genericToken.tokens) {\n                            values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                        }\n                    }\n                }\n            }\n            return values;\n        }\n        use(...args) {\n            const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };\n            args.forEach((pack) => {\n                // copy options to new object\n                const opts = { ...pack };\n                // set async to true if it was set to true before\n                opts.async = this.defaults.async || opts.async || false;\n                // ==-- Parse \"addon\" extensions --== //\n                if (pack.extensions) {\n                    pack.extensions.forEach((ext) => {\n                        if (!ext.name) {\n                            throw new Error('extension name required');\n                        }\n                        if ('renderer' in ext) { // Renderer extensions\n                            const prevRenderer = extensions.renderers[ext.name];\n                            if (prevRenderer) {\n                                // Replace extension with func to run new extension but fall back if false\n                                extensions.renderers[ext.name] = function (...args) {\n                                    let ret = ext.renderer.apply(this, args);\n                                    if (ret === false) {\n                                        ret = prevRenderer.apply(this, args);\n                                    }\n                                    return ret;\n                                };\n                            }\n                            else {\n                                extensions.renderers[ext.name] = ext.renderer;\n                            }\n                        }\n                        if ('tokenizer' in ext) { // Tokenizer Extensions\n                            if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n                                throw new Error(\"extension level must be 'block' or 'inline'\");\n                            }\n                            const extLevel = extensions[ext.level];\n                            if (extLevel) {\n                                extLevel.unshift(ext.tokenizer);\n                            }\n                            else {\n                                extensions[ext.level] = [ext.tokenizer];\n                            }\n                            if (ext.start) { // Function to check for start of token\n                                if (ext.level === 'block') {\n                                    if (extensions.startBlock) {\n                                        extensions.startBlock.push(ext.start);\n                                    }\n                                    else {\n                                        extensions.startBlock = [ext.start];\n                                    }\n                                }\n                                else if (ext.level === 'inline') {\n                                    if (extensions.startInline) {\n                                        extensions.startInline.push(ext.start);\n                                    }\n                                    else {\n                                        extensions.startInline = [ext.start];\n                                    }\n                                }\n                            }\n                        }\n                        if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n                            extensions.childTokens[ext.name] = ext.childTokens;\n                        }\n                    });\n                    opts.extensions = extensions;\n                }\n                // ==-- Parse \"overwrite\" extensions --== //\n                if (pack.renderer) {\n                    const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                    for (const prop in pack.renderer) {\n                        if (!(prop in renderer)) {\n                            throw new Error(`renderer '${prop}' does not exist`);\n                        }\n                        if (['options', 'parser'].includes(prop)) {\n                            // ignore options property\n                            continue;\n                        }\n                        const rendererProp = prop;\n                        const rendererFunc = pack.renderer[rendererProp];\n                        const prevRenderer = renderer[rendererProp];\n                        // Replace renderer with func to run extension, but fall back if false\n                        renderer[rendererProp] = (...args) => {\n                            let ret = rendererFunc.apply(renderer, args);\n                            if (ret === false) {\n                                ret = prevRenderer.apply(renderer, args);\n                            }\n                            return ret || '';\n                        };\n                    }\n                    opts.renderer = renderer;\n                }\n                if (pack.tokenizer) {\n                    const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                    for (const prop in pack.tokenizer) {\n                        if (!(prop in tokenizer)) {\n                            throw new Error(`tokenizer '${prop}' does not exist`);\n                        }\n                        if (['options', 'rules', 'lexer'].includes(prop)) {\n                            // ignore options, rules, and lexer properties\n                            continue;\n                        }\n                        const tokenizerProp = prop;\n                        const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                        const prevTokenizer = tokenizer[tokenizerProp];\n                        // Replace tokenizer with func to run extension, but fall back if false\n                        // @ts-expect-error cannot type tokenizer function dynamically\n                        tokenizer[tokenizerProp] = (...args) => {\n                            let ret = tokenizerFunc.apply(tokenizer, args);\n                            if (ret === false) {\n                                ret = prevTokenizer.apply(tokenizer, args);\n                            }\n                            return ret;\n                        };\n                    }\n                    opts.tokenizer = tokenizer;\n                }\n                // ==-- Parse Hooks extensions --== //\n                if (pack.hooks) {\n                    const hooks = this.defaults.hooks || new _Hooks();\n                    for (const prop in pack.hooks) {\n                        if (!(prop in hooks)) {\n                            throw new Error(`hook '${prop}' does not exist`);\n                        }\n                        if (['options', 'block'].includes(prop)) {\n                            // ignore options and block properties\n                            continue;\n                        }\n                        const hooksProp = prop;\n                        const hooksFunc = pack.hooks[hooksProp];\n                        const prevHook = hooks[hooksProp];\n                        if (_Hooks.passThroughHooks.has(prop)) {\n                            // @ts-expect-error cannot type hook function dynamically\n                            hooks[hooksProp] = (arg) => {\n                                if (this.defaults.async) {\n                                    return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {\n                                        return prevHook.call(hooks, ret);\n                                    });\n                                }\n                                const ret = hooksFunc.call(hooks, arg);\n                                return prevHook.call(hooks, ret);\n                            };\n                        }\n                        else {\n                            // @ts-expect-error cannot type hook function dynamically\n                            hooks[hooksProp] = (...args) => {\n                                let ret = hooksFunc.apply(hooks, args);\n                                if (ret === false) {\n                                    ret = prevHook.apply(hooks, args);\n                                }\n                                return ret;\n                            };\n                        }\n                    }\n                    opts.hooks = hooks;\n                }\n                // ==-- Parse WalkTokens extensions --== //\n                if (pack.walkTokens) {\n                    const walkTokens = this.defaults.walkTokens;\n                    const packWalktokens = pack.walkTokens;\n                    opts.walkTokens = function (token) {\n                        let values = [];\n                        values.push(packWalktokens.call(this, token));\n                        if (walkTokens) {\n                            values = values.concat(walkTokens.call(this, token));\n                        }\n                        return values;\n                    };\n                }\n                this.defaults = { ...this.defaults, ...opts };\n            });\n            return this;\n        }\n        setOptions(opt) {\n            this.defaults = { ...this.defaults, ...opt };\n            return this;\n        }\n        lexer(src, options) {\n            return _Lexer.lex(src, options ?? this.defaults);\n        }\n        parser(tokens, options) {\n            return _Parser.parse(tokens, options ?? this.defaults);\n        }\n        parseMarkdown(blockType) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const parse = (src, options) => {\n                const origOpt = { ...options };\n                const opt = { ...this.defaults, ...origOpt };\n                const throwError = this.onError(!!opt.silent, !!opt.async);\n                // throw error if an extension set async to true but parse was called with async: false\n                if (this.defaults.async === true && origOpt.async === false) {\n                    return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));\n                }\n                // throw error in case of non string input\n                if (typeof src === 'undefined' || src === null) {\n                    return throwError(new Error('marked(): input parameter is undefined or null'));\n                }\n                if (typeof src !== 'string') {\n                    return throwError(new Error('marked(): input parameter is of type '\n                        + Object.prototype.toString.call(src) + ', string expected'));\n                }\n                if (opt.hooks) {\n                    opt.hooks.options = opt;\n                    opt.hooks.block = blockType;\n                }\n                const lexer = opt.hooks ? opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);\n                const parser = opt.hooks ? opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);\n                if (opt.async) {\n                    return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n                        .then(src => lexer(src, opt))\n                        .then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)\n                        .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)\n                        .then(tokens => parser(tokens, opt))\n                        .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n                        .catch(throwError);\n                }\n                try {\n                    if (opt.hooks) {\n                        src = opt.hooks.preprocess(src);\n                    }\n                    let tokens = lexer(src, opt);\n                    if (opt.hooks) {\n                        tokens = opt.hooks.processAllTokens(tokens);\n                    }\n                    if (opt.walkTokens) {\n                        this.walkTokens(tokens, opt.walkTokens);\n                    }\n                    let html = parser(tokens, opt);\n                    if (opt.hooks) {\n                        html = opt.hooks.postprocess(html);\n                    }\n                    return html;\n                }\n                catch (e) {\n                    return throwError(e);\n                }\n            };\n            return parse;\n        }\n        onError(silent, async) {\n            return (e) => {\n                e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n                if (silent) {\n                    const msg = '<p>An error occurred:</p><pre>'\n                        + escape$1(e.message + '', true)\n                        + '</pre>';\n                    if (async) {\n                        return Promise.resolve(msg);\n                    }\n                    return msg;\n                }\n                if (async) {\n                    return Promise.reject(e);\n                }\n                throw e;\n            };\n        }\n    }\n\n    const markedInstance = new Marked();\n    function marked(src, opt) {\n        return markedInstance.parse(src, opt);\n    }\n    /**\n     * Sets the default options.\n     *\n     * @param options Hash of options\n     */\n    marked.options =\n        marked.setOptions = function (options) {\n            markedInstance.setOptions(options);\n            marked.defaults = markedInstance.defaults;\n            changeDefaults(marked.defaults);\n            return marked;\n        };\n    /**\n     * Gets the original marked default options.\n     */\n    marked.getDefaults = _getDefaults;\n    marked.defaults = exports.defaults;\n    /**\n     * Use Extension\n     */\n    marked.use = function (...args) {\n        markedInstance.use(...args);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n    /**\n     * Run callback for every token\n     */\n    marked.walkTokens = function (tokens, callback) {\n        return markedInstance.walkTokens(tokens, callback);\n    };\n    /**\n     * Compiles markdown to HTML without enclosing `p` tag.\n     *\n     * @param src String of markdown source to be compiled\n     * @param options Hash of options\n     * @return String of compiled HTML\n     */\n    marked.parseInline = markedInstance.parseInline;\n    /**\n     * Expose\n     */\n    marked.Parser = _Parser;\n    marked.parser = _Parser.parse;\n    marked.Renderer = _Renderer;\n    marked.TextRenderer = _TextRenderer;\n    marked.Lexer = _Lexer;\n    marked.lexer = _Lexer.lex;\n    marked.Tokenizer = _Tokenizer;\n    marked.Hooks = _Hooks;\n    marked.parse = marked;\n    const options = marked.options;\n    const setOptions = marked.setOptions;\n    const use = marked.use;\n    const walkTokens = marked.walkTokens;\n    const parseInline = marked.parseInline;\n    const parse = marked;\n    const parser = _Parser.parse;\n    const lexer = _Lexer.lex;\n\n    exports.Hooks = _Hooks;\n    exports.Lexer = _Lexer;\n    exports.Marked = Marked;\n    exports.Parser = _Parser;\n    exports.Renderer = _Renderer;\n    exports.TextRenderer = _TextRenderer;\n    exports.Tokenizer = _Tokenizer;\n    exports.getDefaults = _getDefaults;\n    exports.lexer = lexer;\n    exports.marked = marked;\n    exports.options = options;\n    exports.parse = parse;\n    exports.parseInline = parseInline;\n    exports.parser = parser;\n    exports.setOptions = setOptions;\n    exports.use = use;\n    exports.walkTokens = walkTokens;\n\n}));\n//# sourceMappingURL=marked.umd.js.map\n","/**\n * Gets the original marked default options.\n */\nexport function _getDefaults() {\n    return {\n        async: false,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        hooks: null,\n        pedantic: false,\n        renderer: null,\n        silent: false,\n        tokenizer: null,\n        walkTokens: null,\n    };\n}\nexport let _defaults = _getDefaults();\nexport function changeDefaults(newDefaults) {\n    _defaults = newDefaults;\n}\n","/**\n * Helpers\n */\nconst escapeTest = /[&<>\"']/;\nconst escapeReplace = new RegExp(escapeTest.source, 'g');\nconst escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\nconst escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');\nconst escapeReplacements = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n};\nconst getEscapeReplacement = (ch) => escapeReplacements[ch];\nexport function escape(html, encode) {\n    if (encode) {\n        if (escapeTest.test(html)) {\n            return html.replace(escapeReplace, getEscapeReplacement);\n        }\n    }\n    else {\n        if (escapeTestNoEncode.test(html)) {\n            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html;\n}\nconst unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\nexport function unescape(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, (_, n) => {\n        n = n.toLowerCase();\n        if (n === 'colon')\n            return ':';\n        if (n.charAt(0) === '#') {\n            return n.charAt(1) === 'x'\n                ? String.fromCharCode(parseInt(n.substring(2), 16))\n                : String.fromCharCode(+n.substring(1));\n        }\n        return '';\n    });\n}\nconst caret = /(^|[^\\[])\\^/g;\nexport function edit(regex, opt) {\n    let source = typeof regex === 'string' ? regex : regex.source;\n    opt = opt || '';\n    const obj = {\n        replace: (name, val) => {\n            let valSource = typeof val === 'string' ? val : val.source;\n            valSource = valSource.replace(caret, '$1');\n            source = source.replace(name, valSource);\n            return obj;\n        },\n        getRegex: () => {\n            return new RegExp(source, opt);\n        },\n    };\n    return obj;\n}\nexport function cleanUrl(href) {\n    try {\n        href = encodeURI(href).replace(/%25/g, '%');\n    }\n    catch {\n        return null;\n    }\n    return href;\n}\nexport const noopTest = { exec: () => null };\nexport function splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    const row = tableRow.replace(/\\|/g, (match, offset, str) => {\n        let escaped = false;\n        let curr = offset;\n        while (--curr >= 0 && str[curr] === '\\\\')\n            escaped = !escaped;\n        if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return '|';\n        }\n        else {\n            // add space before unescaped |\n            return ' |';\n        }\n    }), cells = row.split(/ \\|/);\n    let i = 0;\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n        cells.pop();\n    }\n    if (count) {\n        if (cells.length > count) {\n            cells.splice(count);\n        }\n        else {\n            while (cells.length < count)\n                cells.push('');\n        }\n    }\n    for (; i < cells.length; i++) {\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n    }\n    return cells;\n}\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */\nexport function rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n        return '';\n    }\n    // Length of suffix matching the invert condition.\n    let suffLen = 0;\n    // Step left until we fail to match the invert condition.\n    while (suffLen < l) {\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && !invert) {\n            suffLen++;\n        }\n        else if (currChar !== c && invert) {\n            suffLen++;\n        }\n        else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nexport function findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    let level = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] === '\\\\') {\n            i++;\n        }\n        else if (str[i] === b[0]) {\n            level++;\n        }\n        else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n","import { _defaults } from './defaults.ts';\nimport { rtrim, splitCells, escape, findClosingBracket, } from './helpers.ts';\nfunction outputLink(cap, link, raw, lexer) {\n    const href = link.href;\n    const title = link.title ? escape(link.title) : null;\n    const text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n    if (cap[0].charAt(0) !== '!') {\n        lexer.state.inLink = true;\n        const token = {\n            type: 'link',\n            raw,\n            href,\n            title,\n            text,\n            tokens: lexer.inlineTokens(text),\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: 'image',\n        raw,\n        href,\n        title,\n        text: escape(text),\n    };\n}\nfunction indentCodeCompensation(raw, text) {\n    const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text\n        .split('\\n')\n        .map(node => {\n        const matchIndentInNode = node.match(/^\\s+/);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        const [indentInNode] = matchIndentInNode;\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    })\n        .join('\\n');\n}\n/**\n * Tokenizer\n */\nexport class _Tokenizer {\n    options;\n    rules; // set by the lexer\n    lexer; // set by the lexer\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    space(src) {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: 'space',\n                raw: cap[0],\n            };\n        }\n    }\n    code(src) {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(/^(?: {1,4}| {0,3}\\t)/gm, '');\n            return {\n                type: 'code',\n                raw: cap[0],\n                codeBlockStyle: 'indented',\n                text: !this.options.pedantic\n                    ? rtrim(text, '\\n')\n                    : text,\n            };\n        }\n    }\n    fences(src) {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || '');\n            return {\n                type: 'code',\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n                text,\n            };\n        }\n    }\n    heading(src) {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n            // remove trailing #s\n            if (/#$/.test(text)) {\n                const trimmed = rtrim(text, '#');\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                }\n                else if (!trimmed || / $/.test(trimmed)) {\n                    // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text),\n            };\n        }\n    }\n    hr(src) {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: 'hr',\n                raw: rtrim(cap[0], '\\n'),\n            };\n        }\n    }\n    blockquote(src) {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            let lines = rtrim(cap[0], '\\n').split('\\n');\n            let raw = '';\n            let text = '';\n            const tokens = [];\n            while (lines.length > 0) {\n                let inBlockquote = false;\n                const currentLines = [];\n                let i;\n                for (i = 0; i < lines.length; i++) {\n                    // get lines up to a continuation\n                    if (/^ {0,3}>/.test(lines[i])) {\n                        currentLines.push(lines[i]);\n                        inBlockquote = true;\n                    }\n                    else if (!inBlockquote) {\n                        currentLines.push(lines[i]);\n                    }\n                    else {\n                        break;\n                    }\n                }\n                lines = lines.slice(i);\n                const currentRaw = currentLines.join('\\n');\n                const currentText = currentRaw\n                    // precede setext continuation with 4 spaces so it isn't a setext\n                    .replace(/\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g, '\\n    $1')\n                    .replace(/^ {0,3}>[ \\t]?/gm, '');\n                raw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n                text = text ? `${text}\\n${currentText}` : currentText;\n                // parse blockquote lines as top level tokens\n                // merge paragraphs if this is a continuation\n                const top = this.lexer.state.top;\n                this.lexer.state.top = true;\n                this.lexer.blockTokens(currentText, tokens, true);\n                this.lexer.state.top = top;\n                // if there is no continuation then we are done\n                if (lines.length === 0) {\n                    break;\n                }\n                const lastToken = tokens[tokens.length - 1];\n                if (lastToken?.type === 'code') {\n                    // blockquote continuation cannot be preceded by a code block\n                    break;\n                }\n                else if (lastToken?.type === 'blockquote') {\n                    // include continuation in nested blockquote\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                    const newToken = this.blockquote(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n                    break;\n                }\n                else if (lastToken?.type === 'list') {\n                    // include continuation in nested list\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                    const newToken = this.list(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n                    lines = newText.substring(tokens[tokens.length - 1].raw.length).split('\\n');\n                    continue;\n                }\n            }\n            return {\n                type: 'blockquote',\n                raw,\n                tokens,\n                text,\n            };\n        }\n    }\n    list(src) {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list = {\n                type: 'list',\n                raw: '',\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : '',\n                loose: false,\n                items: [],\n            };\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n            if (this.options.pedantic) {\n                bull = isordered ? bull : '[*+-]';\n            }\n            // Get next list item\n            const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n            let endsWithBlankLine = false;\n            // Check if current bullet point can start a new List Item\n            while (src) {\n                let endEarly = false;\n                let raw = '';\n                let itemContents = '';\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                let line = cap[2].split('\\n', 1)[0].replace(/^\\t+/, (t) => ' '.repeat(3 * t.length));\n                let nextLine = src.split('\\n', 1)[0];\n                let blankLine = !line.trim();\n                let indent = 0;\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimStart();\n                }\n                else if (blankLine) {\n                    indent = cap[1].length + 1;\n                }\n                else {\n                    indent = cap[2].search(/[^ ]/); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                if (blankLine && /^[ \\t]*$/.test(nextLine)) { // Items begin with at most one blank line\n                    raw += nextLine + '\\n';\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n                    const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                    const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                    const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n                    const htmlBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, 'i');\n                    // Check if following lines should be included in List Item\n                    while (src) {\n                        const rawLine = src.split('\\n', 1)[0];\n                        let nextLineWithoutTabs;\n                        nextLine = rawLine;\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n                            nextLineWithoutTabs = nextLine;\n                        }\n                        else {\n                            nextLineWithoutTabs = nextLine.replace(/\\t/g, '    ');\n                        }\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of html block\n                        if (htmlBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        // Horizontal rule found\n                        if (hrRegex.test(nextLine)) {\n                            break;\n                        }\n                        if (nextLineWithoutTabs.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible\n                            itemContents += '\\n' + nextLineWithoutTabs.slice(indent);\n                        }\n                        else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.replace(/\\t/g, '    ').search(/[^ ]/) >= 4) { // indented code block\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += '\\n' + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n                            blankLine = true;\n                        }\n                        raw += rawLine + '\\n';\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLineWithoutTabs.slice(indent);\n                    }\n                }\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    }\n                    else if (/\\n[ \\t]*\\n[ \\t]*$/.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                let istask = null;\n                let ischecked;\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = /^\\[[ xX]\\] /.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== '[ ] ';\n                        itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n                    }\n                }\n                list.items.push({\n                    type: 'list_item',\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents,\n                    tokens: [],\n                });\n                list.raw += raw;\n            }\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n            list.items[list.items.length - 1].raw = list.items[list.items.length - 1].raw.trimEnd();\n            list.items[list.items.length - 1].text = list.items[list.items.length - 1].text.trimEnd();\n            list.raw = list.raw.trimEnd();\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for (let i = 0; i < list.items.length; i++) {\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                if (!list.loose) {\n                    // Check if list should be loose\n                    const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\\n.*\\n/.test(t.raw));\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for (let i = 0; i < list.items.length; i++) {\n                    list.items[i].loose = true;\n                }\n            }\n            return list;\n        }\n    }\n    html(src) {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token = {\n                type: 'html',\n                block: true,\n                raw: cap[0],\n                pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n                text: cap[0],\n            };\n            return token;\n        }\n    }\n    def(src) {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n            const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n            return {\n                type: 'def',\n                tag,\n                raw: cap[0],\n                href,\n                title,\n            };\n        }\n    }\n    table(src) {\n        const cap = this.rules.block.table.exec(src);\n        if (!cap) {\n            return;\n        }\n        if (!/[:|]/.test(cap[2])) {\n            // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n            return;\n        }\n        const headers = splitCells(cap[1]);\n        const aligns = cap[2].replace(/^\\||\\| *$/g, '').split('|');\n        const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, '').split('\\n') : [];\n        const item = {\n            type: 'table',\n            raw: cap[0],\n            header: [],\n            align: [],\n            rows: [],\n        };\n        if (headers.length !== aligns.length) {\n            // header and align columns must be equal, rows can be different.\n            return;\n        }\n        for (const align of aligns) {\n            if (/^ *-+: *$/.test(align)) {\n                item.align.push('right');\n            }\n            else if (/^ *:-+: *$/.test(align)) {\n                item.align.push('center');\n            }\n            else if (/^ *:-+ *$/.test(align)) {\n                item.align.push('left');\n            }\n            else {\n                item.align.push(null);\n            }\n        }\n        for (let i = 0; i < headers.length; i++) {\n            item.header.push({\n                text: headers[i],\n                tokens: this.lexer.inline(headers[i]),\n                header: true,\n                align: item.align[i],\n            });\n        }\n        for (const row of rows) {\n            item.rows.push(splitCells(row, item.header.length).map((cell, i) => {\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell),\n                    header: false,\n                    align: item.align[i],\n                };\n            }));\n        }\n        return item;\n    }\n    lheading(src) {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[2].charAt(0) === '=' ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1]),\n            };\n        }\n    }\n    paragraph(src) {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n                ? cap[1].slice(0, -1)\n                : cap[1];\n            return {\n                type: 'paragraph',\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text),\n            };\n        }\n    }\n    text(src) {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: 'text',\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0]),\n            };\n        }\n    }\n    escape(src) {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: 'escape',\n                raw: cap[0],\n                text: escape(cap[1]),\n            };\n        }\n    }\n    tag(src) {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            }\n            else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            }\n            else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: 'html',\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: cap[0],\n            };\n        }\n    }\n    link(src) {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!(/>$/.test(trimmedUrl))) {\n                    return;\n                }\n                // ending angle bracket cannot be escaped\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            }\n            else {\n                // find closing parenthesis\n                const lastParenIndex = findClosingBracket(cap[2], '()');\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = '';\n                }\n            }\n            let href = cap[2];\n            let title = '';\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            }\n            else {\n                title = cap[3] ? cap[3].slice(1, -1) : '';\n            }\n            href = href.trim();\n            if (/^</.test(href)) {\n                if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                }\n                else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n                title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,\n            }, cap[0], this.lexer);\n        }\n    }\n    reflink(src, links) {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src))\n            || (cap = this.rules.inline.nolink.exec(src))) {\n            const linkString = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n            const link = links[linkString.toLowerCase()];\n            if (!link) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: 'text',\n                    raw: text,\n                    text,\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer);\n        }\n    }\n    emStrong(src, maskedSrc, prevChar = '') {\n        let match = this.rules.inline.emStrongLDelim.exec(src);\n        if (!match)\n            return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u))\n            return;\n        const nextChar = match[1] || match[2] || '';\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n            const lLength = [...match[0]].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n            endReg.lastIndex = 0;\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while ((match = endReg.exec(maskedSrc)) != null) {\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim)\n                    continue; // skip single * in __abc*abc__\n                rLength = [...rDelim].length;\n                if (match[3] || match[4]) { // found another Left Delim\n                    delimTotal += rLength;\n                    continue;\n                }\n                else if (match[5] || match[6]) { // either Left or Right Delim\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue; // CommonMark Emphasis Rules 9-10\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0)\n                    continue; // Haven't found enough closing delimiters\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                // char length can be >1 for unicode characters;\n                const lastCharLength = [...match[0]][0].length;\n                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    const text = raw.slice(1, -1);\n                    return {\n                        type: 'em',\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text),\n                    };\n                }\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                const text = raw.slice(2, -2);\n                return {\n                    type: 'strong',\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text),\n                };\n            }\n        }\n    }\n    codespan(src) {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(/\\n/g, ' ');\n            const hasNonSpaceChars = /[^ ]/.test(text);\n            const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            text = escape(text, true);\n            return {\n                type: 'codespan',\n                raw: cap[0],\n                text,\n            };\n        }\n    }\n    br(src) {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: 'br',\n                raw: cap[0],\n            };\n        }\n    }\n    del(src) {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: 'del',\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2]),\n            };\n        }\n    }\n    autolink(src) {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = escape(cap[1]);\n                href = 'mailto:' + text;\n            }\n            else {\n                text = escape(cap[1]);\n                href = text;\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    },\n                ],\n            };\n        }\n    }\n    url(src) {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = escape(cap[0]);\n                href = 'mailto:' + text;\n            }\n            else {\n                // do extended autolink path validation\n                let prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n                } while (prevCapZero !== cap[0]);\n                text = escape(cap[0]);\n                if (cap[1] === 'www.') {\n                    href = 'http://' + cap[0];\n                }\n                else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    },\n                ],\n            };\n        }\n    }\n    inlineText(src) {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            let text;\n            if (this.lexer.state.inRawBlock) {\n                text = cap[0];\n            }\n            else {\n                text = escape(cap[0]);\n            }\n            return {\n                type: 'text',\n                raw: cap[0],\n                text,\n            };\n        }\n    }\n}\n","import { edit, noopTest, } from './helpers.ts';\n/**\n * Block-Level Grammar\n */\nconst newline = /^(?:[ \\t]*(?:\\n|$))+/;\nconst blockCode = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheading = edit(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/)\n    .replace(/bull/g, bullet) // lists can interrupt\n    .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n    .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n    .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n    .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n    .getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/)\n    .replace('label', _blockLabel)\n    .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n    .getRegex();\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n    .replace(/bull/g, bullet)\n    .getRegex();\nconst _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n    + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n    + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n    + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n    + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n    + '|tr|track|ul';\nconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\nconst html = edit('^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) closing tag\n    + ')', 'i')\n    .replace('comment', _comment)\n    .replace('tag', _tag)\n    .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n    .getRegex();\nconst paragraph = edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n    .replace('|table', '')\n    .replace('blockquote', ' {0,3}>')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex();\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n    .replace('paragraph', paragraph)\n    .getRegex();\n/**\n * Normal Block Grammar\n */\nconst blockNormal = {\n    blockquote,\n    code: blockCode,\n    def,\n    fences,\n    heading,\n    hr,\n    html,\n    lheading,\n    list,\n    newline,\n    paragraph,\n    table: noopTest,\n    text: blockText,\n};\n/**\n * GFM Block Grammar\n */\nconst gfmTable = edit('^ *([^\\\\n ].*)\\\\n' // Header\n    + ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('blockquote', ' {0,3}>')\n    .replace('code', '(?: {4}| {0,3}\\t)[^\\\\n]')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n    .getRegex();\nconst blockGfm = {\n    ...blockNormal,\n    table: gfmTable,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n        .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n        .replace('table', gfmTable) // interrupt paragraphs with table\n        .replace('blockquote', ' {0,3}>')\n        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n        .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n        .getRegex(),\n};\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\nconst blockPedantic = {\n    ...blockNormal,\n    html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)'\n        + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n        + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n        .replace('comment', _comment)\n        .replace(/tag/g, '(?!(?:'\n        + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n        + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n        + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n        .getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest, // fences not supported\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' *#{1,6} *[^\\n]')\n        .replace('lheading', lheading)\n        .replace('|table', '')\n        .replace('blockquote', ' {0,3}>')\n        .replace('|fences', '')\n        .replace('|list', '')\n        .replace('|html', '')\n        .replace('|tag', '')\n        .getRegex(),\n};\n/**\n * Inline-Level Grammar\n */\nconst escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = '\\\\p{P}\\\\p{S}';\nconst punctuation = edit(/^((?![*_])[\\spunctuation])/, 'u')\n    .replace(/punctuation/g, _punctuation).getRegex();\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = /\\[[^[\\]]*?\\]\\((?:\\\\.|[^\\\\\\(\\)]|\\((?:\\\\.|[^\\\\\\(\\)])*\\))*\\)|`[^`]*?`|<[^<>]*?>/g;\nconst emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, 'u')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst emStrongRDelimAst = edit('^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n    + '|[^*]+(?=[^*])' // Consume to delim\n    + '|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n    + '|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)' // (2) a***#, a*** can only be a Right Delimiter\n    + '|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])' // (3) #***a, ***a can only be Left Delimiter\n    + '|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])' // (4) ***# can only be Left Delimiter\n    + '|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])' // (5) #***# can be either Left or Right Delimiter\n    + '|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])', 'gu') // (6) a***a can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation)\n    .getRegex();\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit('^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n    + '|[^_]+(?=[^_])' // Consume to delim\n    + '|(?!_)[punct](_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n    + '|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)' // (2) a___#, a___ can only be a Right Delimiter\n    + '|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])' // (3) #___a, ___a can only be Left Delimiter\n    + '|[\\\\s](_+)(?!_)(?=[punct])' // (4) ___# can only be Left Delimiter\n    + '|(?!_)[punct](_+)(?!_)(?=[punct])', 'gu') // (5) #___# can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst anyPunctuation = edit(/\\\\([punct])/, 'gu')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n    .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n    .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n    .getRegex();\nconst _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\nconst tag = edit('^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n    .replace('comment', _inlineComment)\n    .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n    .getRegex();\nconst _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/)\n    .replace('label', _inlineLabel)\n    .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/)\n    .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n    .getRegex();\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n    .replace('label', _inlineLabel)\n    .replace('ref', _blockLabel)\n    .getRegex();\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n    .replace('ref', _blockLabel)\n    .getRegex();\nconst reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n    .replace('reflink', reflink)\n    .replace('nolink', nolink)\n    .getRegex();\n/**\n * Normal Inline Grammar\n */\nconst inlineNormal = {\n    _backpedal: noopTest, // only used for GFM url\n    anyPunctuation,\n    autolink,\n    blockSkip,\n    br,\n    code: inlineCode,\n    del: noopTest,\n    emStrongLDelim,\n    emStrongRDelimAst,\n    emStrongRDelimUnd,\n    escape,\n    link,\n    nolink,\n    punctuation,\n    reflink,\n    reflinkSearch,\n    tag,\n    text: inlineText,\n    url: noopTest,\n};\n/**\n * Pedantic Inline Grammar\n */\nconst inlinePedantic = {\n    ...inlineNormal,\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n};\n/**\n * GFM Inline Grammar\n */\nconst inlineGfm = {\n    ...inlineNormal,\n    escape: edit(escape).replace('])', '~|])').getRegex(),\n    url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i')\n        .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n        .getRegex(),\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])((?:\\\\.|[^\\\\])*?(?:\\\\.|[^\\s~\\\\]))\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/,\n};\n/**\n * GFM + Line Breaks Inline Grammar\n */\nconst inlineBreaks = {\n    ...inlineGfm,\n    br: edit(br).replace('{2,}', '*').getRegex(),\n    text: edit(inlineGfm.text)\n        .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n        .replace(/\\{2,\\}/g, '*')\n        .getRegex(),\n};\n/**\n * exports\n */\nexport const block = {\n    normal: blockNormal,\n    gfm: blockGfm,\n    pedantic: blockPedantic,\n};\nexport const inline = {\n    normal: inlineNormal,\n    gfm: inlineGfm,\n    breaks: inlineBreaks,\n    pedantic: inlinePedantic,\n};\n","import { _Tokenizer } from './Tokenizer.ts';\nimport { _defaults } from './defaults.ts';\nimport { block, inline } from './rules.ts';\n/**\n * Block Lexer\n */\nexport class _Lexer {\n    tokens;\n    options;\n    state;\n    tokenizer;\n    inlineQueue;\n    constructor(options) {\n        // TokenList cannot be created in one go\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || _defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true,\n        };\n        const rules = {\n            block: block.normal,\n            inline: inline.normal,\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        }\n        else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            }\n            else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */\n    static get rules() {\n        return {\n            block,\n            inline,\n        };\n    }\n    /**\n     * Static Lex Method\n     */\n    static lex(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */\n    static lexInline(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */\n    lex(src) {\n        src = src\n            .replace(/\\r\\n|\\r/g, '\\n');\n        this.blockTokens(src, this.tokens);\n        for (let i = 0; i < this.inlineQueue.length; i++) {\n            const next = this.inlineQueue[i];\n            this.inlineTokens(next.src, next.tokens);\n        }\n        this.inlineQueue = [];\n        return this.tokens;\n    }\n    blockTokens(src, tokens = [], lastParagraphClipped = false) {\n        if (this.options.pedantic) {\n            src = src.replace(/\\t/g, '    ').replace(/^ +$/gm, '');\n        }\n        let token;\n        let lastToken;\n        let cutSrc;\n        while (src) {\n            if (this.options.extensions\n                && this.options.extensions.block\n                && this.options.extensions.block.some((extTokenizer) => {\n                    if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) {\n                continue;\n            }\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.length === 1 && tokens.length > 0) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    tokens[tokens.length - 1].raw += '\\n';\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.raw;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title,\n                    };\n                }\n                continue;\n            }\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                lastToken = tokens[tokens.length - 1];\n                if (lastParagraphClipped && lastToken?.type === 'paragraph') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = (cutSrc.length !== src.length);\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === 'text') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                }\n                else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    }\n    inline(src, tokens = []) {\n        this.inlineQueue.push({ src, tokens });\n        return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */\n    inlineTokens(src, tokens = []) {\n        let token, lastToken, cutSrc;\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match;\n        let keepPrevChar, prevChar;\n        // Mask out reflinks\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n                    if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out other blocks\n        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        // Mask out escaped characters\n        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n        while (src) {\n            if (!keepPrevChar) {\n                prevChar = '';\n            }\n            keepPrevChar = false;\n            // extensions\n            if (this.options.extensions\n                && this.options.extensions.inline\n                && this.options.extensions.inline.some((extTokenizer) => {\n                    if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) {\n                continue;\n            }\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // autolink\n            if (token = this.tokenizer.autolink(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                }\n                else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    }\n}\n","import { _defaults } from './defaults.ts';\nimport { cleanUrl, escape, } from './helpers.ts';\n/**\n * Renderer\n */\nexport class _Renderer {\n    options;\n    parser; // set by the parser\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    space(token) {\n        return '';\n    }\n    code({ text, lang, escaped }) {\n        const langString = (lang || '').match(/^\\S*/)?.[0];\n        const code = text.replace(/\\n$/, '') + '\\n';\n        if (!langString) {\n            return '<pre><code>'\n                + (escaped ? code : escape(code, true))\n                + '</code></pre>\\n';\n        }\n        return '<pre><code class=\"language-'\n            + escape(langString)\n            + '\">'\n            + (escaped ? code : escape(code, true))\n            + '</code></pre>\\n';\n    }\n    blockquote({ tokens }) {\n        const body = this.parser.parse(tokens);\n        return `<blockquote>\\n${body}</blockquote>\\n`;\n    }\n    html({ text }) {\n        return text;\n    }\n    heading({ tokens, depth }) {\n        return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n`;\n    }\n    hr(token) {\n        return '<hr>\\n';\n    }\n    list(token) {\n        const ordered = token.ordered;\n        const start = token.start;\n        let body = '';\n        for (let j = 0; j < token.items.length; j++) {\n            const item = token.items[j];\n            body += this.listitem(item);\n        }\n        const type = ordered ? 'ol' : 'ul';\n        const startAttr = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n        return '<' + type + startAttr + '>\\n' + body + '</' + type + '>\\n';\n    }\n    listitem(item) {\n        let itemBody = '';\n        if (item.task) {\n            const checkbox = this.checkbox({ checked: !!item.checked });\n            if (item.loose) {\n                if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n                    item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                    }\n                }\n                else {\n                    item.tokens.unshift({\n                        type: 'text',\n                        raw: checkbox + ' ',\n                        text: checkbox + ' ',\n                    });\n                }\n            }\n            else {\n                itemBody += checkbox + ' ';\n            }\n        }\n        itemBody += this.parser.parse(item.tokens, !!item.loose);\n        return `<li>${itemBody}</li>\\n`;\n    }\n    checkbox({ checked }) {\n        return '<input '\n            + (checked ? 'checked=\"\" ' : '')\n            + 'disabled=\"\" type=\"checkbox\">';\n    }\n    paragraph({ tokens }) {\n        return `<p>${this.parser.parseInline(tokens)}</p>\\n`;\n    }\n    table(token) {\n        let header = '';\n        // header\n        let cell = '';\n        for (let j = 0; j < token.header.length; j++) {\n            cell += this.tablecell(token.header[j]);\n        }\n        header += this.tablerow({ text: cell });\n        let body = '';\n        for (let j = 0; j < token.rows.length; j++) {\n            const row = token.rows[j];\n            cell = '';\n            for (let k = 0; k < row.length; k++) {\n                cell += this.tablecell(row[k]);\n            }\n            body += this.tablerow({ text: cell });\n        }\n        if (body)\n            body = `<tbody>${body}</tbody>`;\n        return '<table>\\n'\n            + '<thead>\\n'\n            + header\n            + '</thead>\\n'\n            + body\n            + '</table>\\n';\n    }\n    tablerow({ text }) {\n        return `<tr>\\n${text}</tr>\\n`;\n    }\n    tablecell(token) {\n        const content = this.parser.parseInline(token.tokens);\n        const type = token.header ? 'th' : 'td';\n        const tag = token.align\n            ? `<${type} align=\"${token.align}\">`\n            : `<${type}>`;\n        return tag + content + `</${type}>\\n`;\n    }\n    /**\n     * span level renderer\n     */\n    strong({ tokens }) {\n        return `<strong>${this.parser.parseInline(tokens)}</strong>`;\n    }\n    em({ tokens }) {\n        return `<em>${this.parser.parseInline(tokens)}</em>`;\n    }\n    codespan({ text }) {\n        return `<code>${text}</code>`;\n    }\n    br(token) {\n        return '<br>';\n    }\n    del({ tokens }) {\n        return `<del>${this.parser.parseInline(tokens)}</del>`;\n    }\n    link({ href, title, tokens }) {\n        const text = this.parser.parseInline(tokens);\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + title + '\"';\n        }\n        out += '>' + text + '</a>';\n        return out;\n    }\n    image({ href, title, text }) {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = `<img src=\"${href}\" alt=\"${text}\"`;\n        if (title) {\n            out += ` title=\"${title}\"`;\n        }\n        out += '>';\n        return out;\n    }\n    text(token) {\n        return 'tokens' in token && token.tokens ? this.parser.parseInline(token.tokens) : token.text;\n    }\n}\n","/**\n * TextRenderer\n * returns only the textual part of the token\n */\nexport class _TextRenderer {\n    // no need for block level renderers\n    strong({ text }) {\n        return text;\n    }\n    em({ text }) {\n        return text;\n    }\n    codespan({ text }) {\n        return text;\n    }\n    del({ text }) {\n        return text;\n    }\n    html({ text }) {\n        return text;\n    }\n    text({ text }) {\n        return text;\n    }\n    link({ text }) {\n        return '' + text;\n    }\n    image({ text }) {\n        return '' + text;\n    }\n    br() {\n        return '';\n    }\n}\n","import { _Renderer } from './Renderer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { _defaults } from './defaults.ts';\n/**\n * Parsing & Compiling\n */\nexport class _Parser {\n    options;\n    renderer;\n    textRenderer;\n    constructor(options) {\n        this.options = options || _defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.renderer.parser = this;\n        this.textRenderer = new _TextRenderer();\n    }\n    /**\n     * Static Parse Method\n     */\n    static parse(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */\n    static parseInline(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */\n    parse(tokens, top = true) {\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n            const anyToken = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {\n                const genericToken = anyToken;\n                const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n                if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch (token.type) {\n                case 'space': {\n                    out += this.renderer.space(token);\n                    continue;\n                }\n                case 'hr': {\n                    out += this.renderer.hr(token);\n                    continue;\n                }\n                case 'heading': {\n                    out += this.renderer.heading(token);\n                    continue;\n                }\n                case 'code': {\n                    out += this.renderer.code(token);\n                    continue;\n                }\n                case 'table': {\n                    out += this.renderer.table(token);\n                    continue;\n                }\n                case 'blockquote': {\n                    out += this.renderer.blockquote(token);\n                    continue;\n                }\n                case 'list': {\n                    out += this.renderer.list(token);\n                    continue;\n                }\n                case 'html': {\n                    out += this.renderer.html(token);\n                    continue;\n                }\n                case 'paragraph': {\n                    out += this.renderer.paragraph(token);\n                    continue;\n                }\n                case 'text': {\n                    let textToken = token;\n                    let body = this.renderer.text(textToken);\n                    while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n                        textToken = tokens[++i];\n                        body += '\\n' + this.renderer.text(textToken);\n                    }\n                    if (top) {\n                        out += this.renderer.paragraph({\n                            type: 'paragraph',\n                            raw: body,\n                            text: body,\n                            tokens: [{ type: 'text', raw: body, text: body }],\n                        });\n                    }\n                    else {\n                        out += body;\n                    }\n                    continue;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */\n    parseInline(tokens, renderer) {\n        renderer = renderer || this.renderer;\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n            const anyToken = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[anyToken.type]) {\n                const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);\n                if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch (token.type) {\n                case 'escape': {\n                    out += renderer.text(token);\n                    break;\n                }\n                case 'html': {\n                    out += renderer.html(token);\n                    break;\n                }\n                case 'link': {\n                    out += renderer.link(token);\n                    break;\n                }\n                case 'image': {\n                    out += renderer.image(token);\n                    break;\n                }\n                case 'strong': {\n                    out += renderer.strong(token);\n                    break;\n                }\n                case 'em': {\n                    out += renderer.em(token);\n                    break;\n                }\n                case 'codespan': {\n                    out += renderer.codespan(token);\n                    break;\n                }\n                case 'br': {\n                    out += renderer.br(token);\n                    break;\n                }\n                case 'del': {\n                    out += renderer.del(token);\n                    break;\n                }\n                case 'text': {\n                    out += renderer.text(token);\n                    break;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n}\n","import { _defaults } from './defaults.ts';\nimport { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nexport class _Hooks {\n    options;\n    block;\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    static passThroughHooks = new Set([\n        'preprocess',\n        'postprocess',\n        'processAllTokens',\n    ]);\n    /**\n     * Process markdown before marked\n     */\n    preprocess(markdown) {\n        return markdown;\n    }\n    /**\n     * Process HTML after marked is finished\n     */\n    postprocess(html) {\n        return html;\n    }\n    /**\n     * Process all tokens before walk tokens\n     */\n    processAllTokens(tokens) {\n        return tokens;\n    }\n    /**\n     * Provide function to tokenize markdown\n     */\n    provideLexer() {\n        return this.block ? _Lexer.lex : _Lexer.lexInline;\n    }\n    /**\n     * Provide function to parse tokens\n     */\n    provideParser() {\n        return this.block ? _Parser.parse : _Parser.parseInline;\n    }\n}\n","import { _getDefaults } from './defaults.ts';\nimport { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport { _Hooks } from './Hooks.ts';\nimport { _Renderer } from './Renderer.ts';\nimport { _Tokenizer } from './Tokenizer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { escape } from './helpers.ts';\nexport class Marked {\n    defaults = _getDefaults();\n    options = this.setOptions;\n    parse = this.parseMarkdown(true);\n    parseInline = this.parseMarkdown(false);\n    Parser = _Parser;\n    Renderer = _Renderer;\n    TextRenderer = _TextRenderer;\n    Lexer = _Lexer;\n    Tokenizer = _Tokenizer;\n    Hooks = _Hooks;\n    constructor(...args) {\n        this.use(...args);\n    }\n    /**\n     * Run callback for every token\n     */\n    walkTokens(tokens, callback) {\n        let values = [];\n        for (const token of tokens) {\n            values = values.concat(callback.call(this, token));\n            switch (token.type) {\n                case 'table': {\n                    const tableToken = token;\n                    for (const cell of tableToken.header) {\n                        values = values.concat(this.walkTokens(cell.tokens, callback));\n                    }\n                    for (const row of tableToken.rows) {\n                        for (const cell of row) {\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                    }\n                    break;\n                }\n                case 'list': {\n                    const listToken = token;\n                    values = values.concat(this.walkTokens(listToken.items, callback));\n                    break;\n                }\n                default: {\n                    const genericToken = token;\n                    if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                        this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n                            const tokens = genericToken[childTokens].flat(Infinity);\n                            values = values.concat(this.walkTokens(tokens, callback));\n                        });\n                    }\n                    else if (genericToken.tokens) {\n                        values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                    }\n                }\n            }\n        }\n        return values;\n    }\n    use(...args) {\n        const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };\n        args.forEach((pack) => {\n            // copy options to new object\n            const opts = { ...pack };\n            // set async to true if it was set to true before\n            opts.async = this.defaults.async || opts.async || false;\n            // ==-- Parse \"addon\" extensions --== //\n            if (pack.extensions) {\n                pack.extensions.forEach((ext) => {\n                    if (!ext.name) {\n                        throw new Error('extension name required');\n                    }\n                    if ('renderer' in ext) { // Renderer extensions\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function (...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args);\n                                }\n                                return ret;\n                            };\n                        }\n                        else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if ('tokenizer' in ext) { // Tokenizer Extensions\n                        if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n                            throw new Error(\"extension level must be 'block' or 'inline'\");\n                        }\n                        const extLevel = extensions[ext.level];\n                        if (extLevel) {\n                            extLevel.unshift(ext.tokenizer);\n                        }\n                        else {\n                            extensions[ext.level] = [ext.tokenizer];\n                        }\n                        if (ext.start) { // Function to check for start of token\n                            if (ext.level === 'block') {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                }\n                                else {\n                                    extensions.startBlock = [ext.start];\n                                }\n                            }\n                            else if (ext.level === 'inline') {\n                                if (extensions.startInline) {\n                                    extensions.startInline.push(ext.start);\n                                }\n                                else {\n                                    extensions.startInline = [ext.start];\n                                }\n                            }\n                        }\n                    }\n                    if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n            // ==-- Parse \"overwrite\" extensions --== //\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                for (const prop in pack.renderer) {\n                    if (!(prop in renderer)) {\n                        throw new Error(`renderer '${prop}' does not exist`);\n                    }\n                    if (['options', 'parser'].includes(prop)) {\n                        // ignore options property\n                        continue;\n                    }\n                    const rendererProp = prop;\n                    const rendererFunc = pack.renderer[rendererProp];\n                    const prevRenderer = renderer[rendererProp];\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[rendererProp] = (...args) => {\n                        let ret = rendererFunc.apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret || '';\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                for (const prop in pack.tokenizer) {\n                    if (!(prop in tokenizer)) {\n                        throw new Error(`tokenizer '${prop}' does not exist`);\n                    }\n                    if (['options', 'rules', 'lexer'].includes(prop)) {\n                        // ignore options, rules, and lexer properties\n                        continue;\n                    }\n                    const tokenizerProp = prop;\n                    const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                    const prevTokenizer = tokenizer[tokenizerProp];\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    // @ts-expect-error cannot type tokenizer function dynamically\n                    tokenizer[tokenizerProp] = (...args) => {\n                        let ret = tokenizerFunc.apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n            // ==-- Parse Hooks extensions --== //\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new _Hooks();\n                for (const prop in pack.hooks) {\n                    if (!(prop in hooks)) {\n                        throw new Error(`hook '${prop}' does not exist`);\n                    }\n                    if (['options', 'block'].includes(prop)) {\n                        // ignore options and block properties\n                        continue;\n                    }\n                    const hooksProp = prop;\n                    const hooksFunc = pack.hooks[hooksProp];\n                    const prevHook = hooks[hooksProp];\n                    if (_Hooks.passThroughHooks.has(prop)) {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (arg) => {\n                            if (this.defaults.async) {\n                                return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    }\n                    else {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (...args) => {\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n            // ==-- Parse WalkTokens extensions --== //\n            if (pack.walkTokens) {\n                const walkTokens = this.defaults.walkTokens;\n                const packWalktokens = pack.walkTokens;\n                opts.walkTokens = function (token) {\n                    let values = [];\n                    values.push(packWalktokens.call(this, token));\n                    if (walkTokens) {\n                        values = values.concat(walkTokens.call(this, token));\n                    }\n                    return values;\n                };\n            }\n            this.defaults = { ...this.defaults, ...opts };\n        });\n        return this;\n    }\n    setOptions(opt) {\n        this.defaults = { ...this.defaults, ...opt };\n        return this;\n    }\n    lexer(src, options) {\n        return _Lexer.lex(src, options ?? this.defaults);\n    }\n    parser(tokens, options) {\n        return _Parser.parse(tokens, options ?? this.defaults);\n    }\n    parseMarkdown(blockType) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const parse = (src, options) => {\n            const origOpt = { ...options };\n            const opt = { ...this.defaults, ...origOpt };\n            const throwError = this.onError(!!opt.silent, !!opt.async);\n            // throw error if an extension set async to true but parse was called with async: false\n            if (this.defaults.async === true && origOpt.async === false) {\n                return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));\n            }\n            // throw error in case of non string input\n            if (typeof src === 'undefined' || src === null) {\n                return throwError(new Error('marked(): input parameter is undefined or null'));\n            }\n            if (typeof src !== 'string') {\n                return throwError(new Error('marked(): input parameter is of type '\n                    + Object.prototype.toString.call(src) + ', string expected'));\n            }\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n                opt.hooks.block = blockType;\n            }\n            const lexer = opt.hooks ? opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);\n            const parser = opt.hooks ? opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n                    .then(src => lexer(src, opt))\n                    .then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)\n                    .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)\n                    .then(tokens => parser(tokens, opt))\n                    .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n                    .catch(throwError);\n            }\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                let tokens = lexer(src, opt);\n                if (opt.hooks) {\n                    tokens = opt.hooks.processAllTokens(tokens);\n                }\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html = parser(tokens, opt);\n                if (opt.hooks) {\n                    html = opt.hooks.postprocess(html);\n                }\n                return html;\n            }\n            catch (e) {\n                return throwError(e);\n            }\n        };\n        return parse;\n    }\n    onError(silent, async) {\n        return (e) => {\n            e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n            if (silent) {\n                const msg = '<p>An error occurred:</p><pre>'\n                    + escape(e.message + '', true)\n                    + '</pre>';\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                return msg;\n            }\n            if (async) {\n                return Promise.reject(e);\n            }\n            throw e;\n        };\n    }\n}\n","import { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport { _Tokenizer } from './Tokenizer.ts';\nimport { _Renderer } from './Renderer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { _Hooks } from './Hooks.ts';\nimport { Marked } from './Instance.ts';\nimport { _getDefaults, changeDefaults, _defaults, } from './defaults.ts';\nconst markedInstance = new Marked();\nexport function marked(src, opt) {\n    return markedInstance.parse(src, opt);\n}\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */\nmarked.options =\n    marked.setOptions = function (options) {\n        markedInstance.setOptions(options);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n/**\n * Gets the original marked default options.\n */\nmarked.getDefaults = _getDefaults;\nmarked.defaults = _defaults;\n/**\n * Use Extension\n */\nmarked.use = function (...args) {\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Run callback for every token\n */\nmarked.walkTokens = function (tokens, callback) {\n    return markedInstance.walkTokens(tokens, callback);\n};\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */\nmarked.parseInline = markedInstance.parseInline;\n/**\n * Expose\n */\nmarked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\nexport const options = marked.options;\nexport const setOptions = marked.setOptions;\nexport const use = marked.use;\nexport const walkTokens = marked.walkTokens;\nexport const parseInline = marked.parseInline;\nexport const parse = marked;\nexport const parser = _Parser.parse;\nexport const lexer = _Lexer.lex;\nexport { _defaults as defaults, _getDefaults as getDefaults } from './defaults.ts';\nexport { _Lexer as Lexer } from './Lexer.ts';\nexport { _Parser as Parser } from './Parser.ts';\nexport { _Tokenizer as Tokenizer } from './Tokenizer.ts';\nexport { _Renderer as Renderer } from './Renderer.ts';\nexport { _TextRenderer as TextRenderer } from './TextRenderer.ts';\nexport { _Hooks as Hooks } from './Hooks.ts';\nexport { Marked } from './Instance.ts';\n","import {\n    NavLink,\n    NavLinkProps,\n    OffcanvasNavbar,\n    OffcanvasNavbarProps\n} from 'boot-cell';\nimport { FC, observer } from 'web-cell';\n\nimport { i18n, LanguageName, t } from '../i18n';\n\nexport interface TopNavBarProps extends OffcanvasNavbarProps {\n    menu?: NavLinkProps[];\n}\n\nconst OriginalURLPattern = /^(https?|#)/;\n\nexport const TopNavBar: FC<TopNavBarProps> = observer(\n    ({ menu = [], ...rest }) => (\n        <OffcanvasNavbar\n            variant=\"dark\"\n            expand=\"md\"\n            sticky=\"top\"\n            brand={\n                <a className=\"text-light text-decoration-none\" href=\"#\">\n                    {t('chengdu_web_developer_summit')}\n                </a>\n            }\n            {...rest}\n        >\n            {menu?.map(({ title, href, ...restLinkProps }) => (\n                <NavLink\n                    className=\"m-3 my-md-0 mx-md-3 align-self-center\"\n                    {...restLinkProps}\n                    href={OriginalURLPattern.test(href) ? href : `#${href}`}\n                    active={globalThis.location?.hash\n                        ?.slice(1)\n                        .startsWith(href + '')}\n                >\n                    {title}\n                </NavLink>\n            ))}\n            <select\n                className=\"form-control w-auto ms-auto\"\n                value={i18n.currentLanguage}\n                onChange={({ currentTarget }) =>\n                    i18n.changeLanguage(\n                        (currentTarget as HTMLSelectElement)\n                            .value as typeof i18n.currentLanguage\n                    )\n                }\n            >\n                {Object.entries(LanguageName).map(([code, name]) => (\n                    <option key={code} value={code}>\n                        {name}\n                    </option>\n                ))}\n            </select>\n        </OffcanvasNavbar>\n    )\n);\n","import { t } from '../../i18n';\nimport { BW, JueJin, OSChina, SF, SYL } from '../2017/image/logos';\nimport { FCC_CDC } from './image';\nimport {\n    Guo_DaFeng,\n    Guo_LinShuo,\n    Huang_Yi,\n    Quincy_Larson,\n    Si_Yue,\n    Xiong_Jie,\n    Yu_Che\n} from './image/lecturer';\nimport {\n    epubit,\n    fezaoduke,\n    mikecrm,\n    turing,\n    young\n} from './image/logo/partner';\nimport { BaiCiZhan, baozun, cocoet, sxl } from './image/logo/sponsor';\nimport {\n    CD_LUG,\n    Covariant_Script,\n    Deepin,\n    Fun_loading,\n    H5DS,\n    KaiYuanShe,\n    PI6,\n    React_Admin,\n    UKylin,\n    Vena_Network,\n    WebCell\n} from './image/project';\n\nexport const title = () => t('chengdu_web_frontend_conference_2018');\n\nexport const sections = () => [\n    {\n        title: t('conference_introduction'),\n        href: '#Introduction'\n    },\n    {\n        title: t('guest_lecturers'),\n        href: '#Lecturer'\n    },\n    {\n        title: t('topics'),\n        href: '#Topic'\n    },\n    {\n        title: t('open_source_bazaar'),\n        href: '#Bazaar'\n    },\n    {\n        title: t('participating_companies'),\n        href: '#Enterprise'\n    },\n    {\n        title: t('schedule'),\n        href: '#Schedule'\n    },\n    {\n        title: t('address'),\n        href: '#Address'\n    },\n    {\n        title: t('past_highlights_review'),\n        href: '#Review'\n    },\n    {\n        title: t('photo_live'),\n        href: 'http://www.pailixiang.com/album_ia172238913.html'\n    },\n    {\n        title: t('co_creation_partners'),\n        href: '#Contributor'\n    }\n];\n\nexport const lecturers = () => [\n    {\n        name: t('quincy_larson'),\n        avatar: Quincy_Larson,\n        detail: t('quincy_larson_freecodecamp_founder')\n    },\n    {\n        name: t('xiong_jie'),\n        avatar: Xiong_Jie,\n        detail: t('xiong_jie_introduce')\n    },\n    {\n        name: t('huang_yi'),\n        avatar: Huang_Yi,\n        detail: t('huang_yi_introduce')\n    },\n    {\n        name: t('si_yue'),\n        avatar: Si_Yue,\n        detail: t('si_yue_introduce')\n    },\n    {\n        name: t('yu_che'),\n        avatar: Yu_Che,\n        detail: t('yu_che_introduce')\n    },\n    {\n        name: t('guo_lin_shuo'),\n        avatar: Guo_LinShuo,\n        detail: t('guo_linshuo_introduce')\n    },\n    {\n        name: t('guo_da_feng'),\n        avatar: Guo_DaFeng,\n        detail: t('guo_dafeng_introduce')\n    }\n];\n\nexport const topics = () => [\n    {\n        title: t('freecodecamp_from_0_to_290k_stars'),\n        lecturer: lecturers()[0],\n        detail: t('quincy_larson_career_journey')\n    },\n    {\n        title: t('empower_nodejs_with_cpp_wings'),\n        lecturer: lecturers()[3],\n        detail: t('nodejs_cpp_usage_topic')\n    },\n    {\n        title: t('open_source_project_maintenance'),\n        lecturer: lecturers()[4],\n        detail: t('open_source_guide')\n    },\n    {\n        title: t('history_of_agile_in_china'),\n        lecturer: lecturers()[1],\n        detail: t('history_of_agile_in_china_detail')\n    },\n    {\n        title: t('efficient_h5_animation_development_method'),\n        lecturer: lecturers()[5],\n        detail: t('efficient_h5_animation_development_method_detail')\n    },\n    {\n        title: t('highly_available_react_server_side_rendering'),\n        lecturer: lecturers()[6],\n        detail: t('highly_available_react_ssr_enterprise_application_practice')\n    },\n    {\n        title: t('building_vue_component_library'),\n        lecturer: lecturers()[2],\n        detail: t('building_vue_component_library_detail')\n    }\n];\n\nexport const schedule = () => [\n    {\n        title: t('check_in_and_visit_bazaar'),\n        time: '09:00 ~ 09:30'\n    },\n    {\n        topic: topics()[0],\n        time: '09:30 ~ 10:20'\n    },\n    {\n        topic: topics()[1],\n        time: '10:20 ~ 11:10'\n    },\n    {\n        topic: topics()[2],\n        time: '11:10 ~ 12:00'\n    },\n    {\n        title: t('lunch_and_visit_bazaar'),\n        time: '12:00 ~ 13:55'\n    },\n    {\n        title: t('lucky_draw_session'),\n        time: '13:55 ~ 14:00'\n    },\n    {\n        topic: topics()[3],\n        time: '14:00 ~ 14:50'\n    },\n    {\n        topic: topics()[4],\n        time: '14:50 ~ 15:40'\n    },\n    {\n        title: t('tea_break_visit_bazaar_fun_programming_contest'),\n        time: '15:40 ~ 16:10'\n    },\n    {\n        topic: topics()[5],\n        time: '16:10 ~ 17:00'\n    },\n    {\n        topic: topics()[6],\n        time: '17:00 ~ 17:50'\n    },\n    {\n        title: t('lucky_draw_session'),\n        time: '17:50 ~ 17:55'\n    }\n];\n\nexport const projects = () => [\n    {\n        title: '深度操作系统',\n        name: 'Deepin',\n        type: 0,\n        URL: 'https://www.deepin.org',\n        detail: t('global_influence_chinese_linux_distribution'),\n        logo: Deepin\n    },\n    {\n        title: 'WebCell',\n        name: 'WebCell',\n        type: 0,\n        URL: 'https://web-cell.dev/',\n        detail: t('lightweight_web_componentization_engine_detail'),\n        logo: WebCell\n    },\n    {\n        title: 'HTML 5 design software',\n        name: 'H5DS',\n        type: 0,\n        URL: 'http://www.h5ds.com',\n        detail: t('h5ds_html5_design_software_detail'),\n        logo: H5DS\n    },\n    {\n        title: 'Fun loading',\n        name: 'Fun loading',\n        type: 0,\n        URL: 'https://fanerge.github.io/fun-loading/dist/',\n        detail: t('react_loading_component_library'),\n        logo: Fun_loading\n    },\n    {\n        title: 'Ubuntu Kylin',\n        name: 'UKylin',\n        type: 0,\n        URL: 'http://www.ubuntukylin.com',\n        detail: t('ubuntu_kylin_detail'),\n        logo: UKylin\n    },\n    {\n        title: 'Covariant Script',\n        name: 'Covariant Script',\n        type: 0,\n        URL: 'http://covscript.org',\n        detail: t('covariant_script_detail'),\n        logo: Covariant_Script\n    },\n    {\n        title: 'PI6',\n        name: 'PI6',\n        type: 0,\n        URL: 'http://github.com/visi-pivi-sivi/PI6',\n        detail: 'PI6 is a bash shell based framework, allow author to add comments in the script, and provides a good interactive experience for user, who needs to know what will be done in the next, while running the script in step by step mode.',\n        logo: PI6\n    },\n    {\n        title: 'React Admin',\n        name: 'React Admin',\n        type: 0,\n        URL: 'https://github.com/yezihaohao/react-admin',\n        detail: t('react_antd_backend_management_solution'),\n        logo: React_Admin\n    },\n    {\n        title: '开源社',\n        name: 'KaiYuanShe',\n        type: 1,\n        URL: 'http://www.kaiyuanshe.cn/',\n        detail: t('kaiyuanshe_open_source_alliance_description'),\n        logo: KaiYuanShe\n    },\n    {\n        title: '洛书协议',\n        name: 'Vena Network',\n        type: 0,\n        URL: 'https://github.com/venanetwork',\n        detail: t('luoshu_protocol_asset_securitization_tokenization'),\n        logo: Vena_Network\n    },\n    {\n        title: '成都 Linux 用户组',\n        name: 'CD-LUG',\n        type: 1,\n        URL: 'https://cdlug.org/',\n        detail: t('chengdu_gnu_linux_community_description'),\n        logo: CD_LUG\n    }\n];\n\nexport const review = [\n    {\n        title: 'React 技术演讲'\n    },\n    {\n        title: 'React 技术提问'\n    },\n    {\n        title: 'React 技术讲师'\n    },\n    {\n        title: 'React 大会观众'\n    },\n    {\n        title: 'React 大会招聘'\n    },\n    {\n        title: 'Code for City 黑客松茶歇'\n    },\n    {\n        title: 'Code for City 黑客松 FCC 合影'\n    },\n    {\n        title: '茶歇一览'\n    },\n    {\n        title: 'React 大会招聘'\n    }\n];\n\nexport const hosts = () => [\n    {\n        title: t('principal'),\n        member: [\n            {\n                name: 'FCC 成都',\n                path: FCC_CDC,\n                URL: 'https://freecodecamp-chengdu.github.io/'\n            }\n        ]\n    },\n    {\n        title: t('supporting'),\n        member: [\n            {\n                name: ' 掘金',\n                path: JueJin,\n                URL: 'https://juejin.im/'\n            }\n        ]\n    }\n];\n\nexport const sponsors = () => [\n    {\n        title: t('gold'),\n        member: [\n            {\n                name: '上线了',\n                path: sxl,\n                URL: 'https://www.sxl.cn/'\n            }\n        ]\n    },\n    {\n        title: t('silver'),\n        member: [\n            {\n                name: '宝尊电商',\n                path: baozun,\n                URL: 'https://www.baozun.com/cn/'\n            }\n        ]\n    },\n    {\n        title: t('bronze'),\n        member: [\n            {\n                name: '可好玩乐',\n                path: cocoet,\n                URL: 'https://cocoet.cn/'\n            },\n            {\n                name: '百词斩',\n                path: BaiCiZhan,\n                URL: 'http://www.baicizhan.com/'\n            }\n        ]\n    }\n];\n\nexport const partners = [\n    {\n        name: '博文视点',\n        path: BW,\n        URL: 'http://www.broadview.com.cn/'\n    },\n    {\n        name: '开源中国',\n        path: OSChina,\n        URL: 'https://www.oschina.net/'\n    },\n    {\n        name: '麦克',\n        path: mikecrm,\n        URL: 'https://www.mikecrm.com/'\n    },\n    {\n        name: '前端早读课',\n        path: fezaoduke,\n        URL: 'https://zdk.f2er.net/'\n    },\n    {\n        name: '实验楼',\n        path: SYL,\n        URL: 'https://www.shiyanlou.com/'\n    },\n    {\n        name: '图灵社区',\n        path: turing,\n        URL: 'http://www.ituring.com.cn/'\n    },\n    {\n        name: '异步社区',\n        path: epubit,\n        URL: 'https://www.epubit.com/'\n    },\n    {\n        name: 'SegmentFault',\n        path: SF,\n        URL: 'https://segmentfault.com/'\n    },\n    {\n        name: '小样青年社区',\n        path: young,\n        URL: 'http://www.xypark.com/'\n    }\n];\n\nexport const companies = [\n    '上线了',\n    '宝尊电商',\n    '企鹅医生',\n    '新蛋',\n    '乐车邦',\n    'tap4fun',\n    'ThoughtWorks',\n    '麦麦养老',\n    'BBD',\n    '美团',\n    '腾讯',\n    '知道创宇',\n    '陌陌成都',\n    '孔明科技',\n    '知乎',\n    '去哪儿',\n    '医联',\n    '极米科技',\n    '今日头条',\n    '点融网',\n    '客如云',\n    '街电',\n    '华为云',\n    'Camera360',\n    '鱼说科技',\n    '折800',\n    'TestBird',\n    '汇通天下',\n    '科大讯飞',\n    '咕咚',\n    '西瓜创客',\n    '实验楼',\n    '四方伟业',\n    '猪八戒',\n    '陌陌',\n    '货车邦',\n    '活跃网络',\n    '蚂蚁金服'\n];\n","export { default as _3W } from './3W.png';\nexport { default as BBD } from './BBD.png';\nexport { default as BW } from './BW.png';\nexport { default as DevEco } from './DevEco.jpg';\nexport { default as DKS } from './DKS.png';\nexport { default as FCC_CDG } from './FCC-CDG.png';\nexport { default as GDG } from './GDG.png';\nexport { default as GT } from './GT.png';\nexport { default as HCXY } from './HCXY.png';\nexport { default as MZ } from './MZ.png';\nexport { default as OS } from './OS.png';\nexport { default as QE } from './QE.png';\nexport { default as QRGJ } from './QRGJ.png';\nexport { default as SF } from './SF.png';\nexport { default as SYL } from './SYL.png';\nexport { default as TH } from './TH.png';\nexport { default as TW } from './TW.png';\nexport { default as WORK } from './WORK.png';\nexport { default as ZDK } from './ZDK.png';\n\nexport const JueJin =\n    'https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg';\nexport const OSChina =\n    'https://static.oschina.net/new-osc/img/logo_osc_new.svg';\n","module.exports = new __parcel__URL__(\"3W.343e9c06.png\").toString();","module.exports = new __parcel__URL__(\"BBD.ed89ee43.png\").toString();","module.exports = new __parcel__URL__(\"BW.0f2c33fb.png\").toString();","module.exports = new __parcel__URL__(\"DevEco.5b51c8ac.jpg\").toString();","module.exports = new __parcel__URL__(\"DKS.1c567b7f.png\").toString();","module.exports = new __parcel__URL__(\"FCC-CDG.bf36daee.png\").toString();","module.exports = new __parcel__URL__(\"GDG.ca994c53.png\").toString();","module.exports = new __parcel__URL__(\"GT.27a90685.png\").toString();","module.exports = new __parcel__URL__(\"HCXY.6f490d1a.png\").toString();","module.exports = new __parcel__URL__(\"MZ.d0765924.png\").toString();","module.exports = new __parcel__URL__(\"OS.58b63fb9.png\").toString();","module.exports = new __parcel__URL__(\"QE.be8c3b0d.png\").toString();","module.exports = new __parcel__URL__(\"QRGJ.14ffed50.png\").toString();","module.exports = new __parcel__URL__(\"SF.c6f8e6e7.png\").toString();","module.exports = new __parcel__URL__(\"SYL.da34d90b.png\").toString();","module.exports = new __parcel__URL__(\"TH.1178f233.png\").toString();","module.exports = new __parcel__URL__(\"TW.0498d9bc.png\").toString();","module.exports = new __parcel__URL__(\"WORK.90e8ce09.png\").toString();","module.exports = new __parcel__URL__(\"ZDK.fb7a5ccd.png\").toString();","export { default as poster } from './poster.png';\nexport { default as undraw_01 } from './undraw_01.png';\nexport { default as undraw_04 } from './undraw_04.png';\n\nexport const FCC_CDC = 'https://fcc-cd.dev/images/FCC-CDC-v1-0.png';\n","module.exports = new __parcel__URL__(\"poster.367bcd76.png\").toString();","module.exports = new __parcel__URL__(\"undraw_01.18599e8b.png\").toString();","module.exports = new __parcel__URL__(\"undraw_04.d9b38312.png\").toString();","export { default as Guo_DaFeng } from './Guo DaFeng.png';\nexport { default as Guo_LinShuo } from './Guo LinShuo.png';\nexport { default as Huang_Yi } from './Huang Yi.png';\nexport { default as OpenSource } from './OpenSource.png';\nexport { default as Quincy_Larson } from './Quincy Larson.png';\nexport { default as Si_Yue } from './Si Yue.png';\nexport { default as Xiong_Jie } from './Xiong Jie.png';\nexport { default as Yu_Che } from './Yu Che.png';\n","module.exports = new __parcel__URL__(\"Guo DaFeng.6d7546f5.png\").toString();","module.exports = new __parcel__URL__(\"Guo LinShuo.12cd3b39.png\").toString();","module.exports = new __parcel__URL__(\"Huang Yi.a58655d7.png\").toString();","module.exports = new __parcel__URL__(\"OpenSource.1df18182.png\").toString();","module.exports = new __parcel__URL__(\"Quincy Larson.caaecba1.png\").toString();","module.exports = new __parcel__URL__(\"Si Yue.fba3c144.png\").toString();","module.exports = new __parcel__URL__(\"Xiong Jie.6367f3c4.png\").toString();","module.exports = new __parcel__URL__(\"Yu Che.f3526e5b.png\").toString();","export { default as epubit } from './epubit.png';\nexport { default as fezaoduke } from './fezaoduke.png';\nexport { default as mikecrm } from './mikecrm.png';\nexport { default as young } from './young.png';\n\nexport const turing = 'http://tp1.sinaimg.cn/1752543513/180/1.jpg';\n","module.exports = new __parcel__URL__(\"epubit.c1d8c5b0.png\").toString();","module.exports = new __parcel__URL__(\"fezaoduke.fb7a5ccd.png\").toString();","module.exports = new __parcel__URL__(\"mikecrm.0a457542.png\").toString();","module.exports = new __parcel__URL__(\"young.5f5cc2c5.png\").toString();","export { default as BaiCiZhan } from './BaiCiZhan.png';\nexport { default as baozun } from './baozun.jpg';\nexport { default as cocoet } from './cocoet.png';\nexport { default as sxl } from './sxl.jpg';\n","module.exports = new __parcel__URL__(\"BaiCiZhan.259fa4d1.png\").toString();","module.exports = new __parcel__URL__(\"baozun.75f58188.jpg\").toString();","module.exports = new __parcel__URL__(\"cocoet.da319e74.png\").toString();","module.exports = new __parcel__URL__(\"sxl.dd9a9c0f.jpg\").toString();","export { default as CD_LUG } from './CD-LUG.png';\nexport { default as Covariant_Script } from './Covariant Script.png';\nexport { default as Deepin } from './Deepin.png';\nexport { default as Fun_loading } from './Fun loading.png';\nexport { default as H5DS } from './H5DS.png';\nexport { default as KaiYuanShe } from './KaiYuanShe.png';\nexport { default as PI6 } from './PI6.png';\nexport { default as React_Admin } from './React Admin.png';\nexport { default as UKylin } from './UKylin.png';\nexport { default as Vena_Network } from './Vena Network.png';\nexport { default as WebCell } from './WebCell.png';\n","module.exports = new __parcel__URL__(\"CD-LUG.5d9dea2f.png\").toString();","module.exports = new __parcel__URL__(\"Covariant Script.6b878a1e.png\").toString();","module.exports = new __parcel__URL__(\"Deepin.ae36ed8d.png\").toString();","module.exports = new __parcel__URL__(\"Fun loading.6e397c0c.png\").toString();","module.exports = new __parcel__URL__(\"H5DS.e8bb5317.png\").toString();","module.exports = new __parcel__URL__(\"KaiYuanShe.da310f52.png\").toString();","module.exports = new __parcel__URL__(\"PI6.1bc18258.png\").toString();","module.exports = new __parcel__URL__(\"React Admin.6c9f1934.png\").toString();","module.exports = new __parcel__URL__(\"UKylin.71e361fb.png\").toString();","module.exports = new __parcel__URL__(\"Vena Network.a2781646.png\").toString();","module.exports = new __parcel__URL__(\"WebCell.48070487.png\").toString();","import _1 from './1.jpg';\nimport _2 from './2.jpg';\nimport _3 from './3.jpg';\nimport _4 from './4.jpg';\nimport _5 from './5.jpg';\nimport _6 from './6.jpg';\nimport _7 from './7.jpg';\nimport _8 from './8.jpg';\nimport _9 from './9.jpg';\n\nexport default [_1, _2, _3, _4, _5, _6, _7, _8, _9];\n","module.exports = new __parcel__URL__(\"1.bcd16fd1.jpg\").toString();","module.exports = new __parcel__URL__(\"2.09e20710.jpg\").toString();","module.exports = new __parcel__URL__(\"3.244a440c.jpg\").toString();","module.exports = new __parcel__URL__(\"4.c55a5098.jpg\").toString();","module.exports = new __parcel__URL__(\"5.656cea07.jpg\").toString();","module.exports = new __parcel__URL__(\"6.da397600.jpg\").toString();","module.exports = new __parcel__URL__(\"7.f4500b56.jpg\").toString();","module.exports = new __parcel__URL__(\"8.42f8e777.jpg\").toString();","module.exports = new __parcel__URL__(\"9.f9c67304.jpg\").toString();",".root {\n    font-family: 'PingFang SC', 'Lantinghei SC', 'Helvetica Neue', Helvetica,\n        Arial, 'Microsoft YaHei', 'STHeitiSC-Light', simsun, 'sans-serif';\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n    text-size-adjust: 100% !important;\n    font-weight: 400;\n    line-height: 1.8;\n    color: #333;\n\n    a,\n    a:visited {\n        color: #222;\n    }\n    a:hover {\n        color: #666;\n    }\n    a.btn-primary {\n        color: #fff;\n        background-color: #246af7;\n    }\n\n    & > section {\n        padding: 100px 0;\n        margin: 0;\n    }\n\n    tbody {\n        counter-reset: index;\n    }\n    tbody td:first-child::before {\n        counter-increment: index;\n        content: counter(index);\n    }\n}\n@media screen and (max-width: 767.98px) {\n    .root {\n        font-size: 14px;\n        line-height: 1.6;\n\n        & > section {\n            padding: 50px 0;\n        }\n    }\n}\n.poster {\n    width: 100%;\n    min-height: 600px;\n    position: relative;\n    padding: 0;\n    margin: 0;\n\n    .navbar-toggler {\n        background: #f8f9fa;\n    }\n}\n@media screen and (min-width: 767.98px) {\n    .poster .navbar {\n        background: #f8f9fa;\n    }\n}\n@media screen and (max-width: 767.98px) {\n    .poster {\n        min-height: 100px;\n\n        .navbar-nav {\n            background: #246af7;\n            padding: 10px;\n            width: 160px;\n            box-shadow: 1px 1px 10px 3px #aaa;\n        }\n        .navbar-light .navbar-nav .nav-link {\n            color: #fff;\n        }\n    }\n}\n.avatar {\n    width: 128px;\n    height: 128px;\n    border-radius: 64px;\n}\n.avatar-sm {\n    width: 88px;\n    height: 88px;\n    border-radius: 44px;\n}\n\n.sparked {\n    text-align: center;\n    background: #fff url(./image/bg.png) repeat top left;\n    border-top: 1px solid #eee;\n    border-bottom: 1px solid #eee;\n}\n.lecture {\n    height: 30rem;\n    border: 1px solid #eee;\n    padding: 25px 15px;\n    background: white;\n    overflow: hidden;\n\n    .lecture-name {\n        font-weight: bold;\n    }\n    .lecture-intro {\n        max-height: 18rem;\n        overflow: auto;\n        color: #666;\n        font-size: 14px;\n        text-align: left;\n    }\n}\n@media (max-width: 768px) {\n    .lecture {\n        height: auto;\n    }\n}\n@media screen and (max-width: 767.98px) {\n    .subjects {\n        padding-left: 0;\n        & > li {\n            padding: 15px;\n            border-bottom: 1px dotted #eee;\n            & > div {\n                &:first-child {\n                    margin-bottom: 15px;\n                    text-align: center;\n                }\n                & > h5 {\n                    text-align: center;\n                    margin: 15px 0;\n                }\n            }\n        }\n    }\n}\n@media screen and (min-width: 767.98px) {\n    .subjects {\n        &::after {\n            content: '';\n            position: absolute;\n            z-index: -1;\n            background: #fff url('image/undraw_02.png') no-repeat right center;\n            opacity: 0.3;\n            top: 0;\n            left: 0;\n            bottom: 0;\n            right: -200px;\n        }\n        & > li {\n            padding: 25px 0;\n            display: flex;\n            justify-content: flex-start;\n            & > div:first-child {\n                padding: 0 15px;\n                margin-right: 15px;\n                border-right: 1px solid #eee;\n            }\n        }\n    }\n}\n.subjects > li {\n    & > .avatar {\n        flex-grow: 0;\n        flex-shrink: 0;\n        margin-right: 15px;\n    }\n    p {\n        font-size: 14px;\n        h6 {\n            margin: 0.5rem 0;\n        }\n    }\n}\n@media screen and (min-width: 767.98px) {\n    .photos:not(:last-child) {\n        margin-bottom: 25px;\n    }\n}\n@media screen and (max-width: 767.98px) {\n    .photos > div {\n        margin-bottom: 15px;\n    }\n}\n:global {\n    @media screen and (max-width: 767.98px) {\n        td {\n            font-size: 12px;\n        }\n    }\n    #CallInAction,\n    #CallInAction > * {\n        position: relative;\n    }\n    #CallInAction::before {\n        content: '';\n        position: absolute;\n        left: 0;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        background: url(image/bg2.png) no-repeat center calc(100% + 24px);\n        background-size: 30%;\n    }\n    @media screen and (max-width: 767.98px) {\n        #CallInAction::before {\n            background: transparent;\n        }\n    }\n    #Bazaar {\n        .card-img-top {\n            padding: 1rem;\n        }\n        .card-title > * {\n            display: inline-block;\n            vertical-align: middle;\n        }\n        .card-text {\n            max-height: 15rem;\n            overflow: auto;\n            font-size: 12px;\n        }\n        .card {\n            position: relative;\n            .cr {\n                position: absolute;\n                width: 200px;\n                padding: 8px;\n                text-align: center;\n                color: #f0f0f0;\n            }\n            .cr-top {\n                top: 15px;\n            }\n            .cr-right {\n                right: -70px;\n            }\n            .cr-top.cr-right {\n                transform: rotate(45deg);\n            }\n            .cr-blue {\n                background-color: rgba(35, 107, 247, 0.8);\n            }\n            .cr-red {\n                background-color: rgba(248, 71, 89, 1);\n            }\n        }\n    }\n    @media (min-width: 577px) and (max-width: 768px) {\n        #Bazaar .card-columns {\n            column-count: 2;\n        }\n    }\n    #Review .row > * {\n        padding: 0.7rem 1rem;\n    }\n}\n.companies > li {\n    border: 1px dashed #ddd;\n    &:hover {\n        background: #fafafa;\n    }\n}\n.contributorGroup {\n    h5 {\n        color: #666;\n    }\n    img {\n        flex-flow: 0;\n    }\n    p {\n        color: #999;\n        font-size: 12px;\n    }\n}\n.footer .qrcode {\n    font-size: 12px;\n    color: #333;\n}\n@media screen and (min-width: 767.98px) {\n    .footer {\n        height: 240px;\n\n        .qrcode {\n            width: 128px;\n            height: 128px;\n            float: right;\n        }\n    }\n}\n","import { FC } from 'web-cell';\n\ntype Logo = Record<'name' | 'URL' | 'path', string>;\n\nexport const LogoList: FC<{ member: Logo[] }> = ({ member }) => (\n    <div className=\"d-flex justify-content-around align-content-center flex-wrap\">\n        {member.map(({ URL, name, path }) => (\n            <a key={path} target=\"_blank\" href={URL}>\n                <img\n                    className=\"py-3 px-1 flex-grow-0 flex-shrink-0\"\n                    title={name}\n                    src={path}\n                    style={{ width: '210px' }}\n                />\n            </a>\n        ))}\n    </div>\n);\n"],"names":["$parcel$interopDefault","a","__esModule","default","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","value","$ad72fdbf935866b0$export$2e2bcd8739ae039","$b603G","$fonQc","$4eJD6","$89MmN","$6rYRn","$6T66T","$3phDk","$7dZa5","$7qUFF","$5pWIJ","$1PSFd","$h58g0","$g3Ku0","observer","jsxs","className","root","children","jsx","TopNavBar","brand","title","expand","variant","menu","sections","poster","Image","src","fluid","id","t","Container","Button","size","target","href","sparked","lecturers","map","avatar","name","detail","lecture","alt","innerHTML","marked","subjects","topics","lecturer","projects","type","URL","logo","Card","CardImg","CardBody","CardTitle","rel","companies","Table","striped","hover","scope","schedule","time","topic","photos","review","index","Ratio","aspectRatio","loading","hosts","member","contributorGroup","LogoList","sponsors","partners","Nav","NavLink","factory","exports1","_getDefaults","async","breaks","extensions","gfm","hooks","pedantic","renderer","silent","tokenizer","walkTokens","changeDefaults","newDefaults","defaults","escapeTest","escapeReplace","RegExp","source","escapeTestNoEncode","escapeReplaceNoEncode","escapeReplacements","getEscapeReplacement","ch","escape$1","html","encode","test","replace","caret","edit","regex","opt","obj","val","valSource","getRegex","cleanUrl","encodeURI","noopTest","exec","splitCells","tableRow","count","cells","row","match","offset","str","escaped","curr","split","i","trim","shift","length","pop","splice","push","rtrim","c","invert","l","suffLen","currChar","charAt","slice","outputLink","cap","link","raw","lexer","text","state","inLink","token","tokens","inlineTokens","_Tokenizer","options","rules","constructor","space","block","newline","code","codeBlockStyle","fences","indentCodeCompensation","matchIndentToCode","indentToCode","node","matchIndentInNode","indentInNode","join","lang","inline","anyPunctuation","heading","trimmed","depth","hr","blockquote","lines","inBlockquote","currentLines","currentRaw","currentText","top","blockTokens","lastToken","newText","oldToken","newToken","substring","list","bull","isordered","ordered","start","loose","items","itemRegex","endsWithBlankLine","ischecked","endEarly","itemContents","line","repeat","nextLine","blankLine","indent","trimStart","search","nextBulletRegex","Math","min","hrRegex","fencesBeginRegex","headingBeginRegex","htmlBeginRegex","nextLineWithoutTabs","rawLine","istask","task","checked","trimEnd","spacers","filter","hasMultipleLineBreaks","some","pre","def","tag","toLowerCase","table","headers","aligns","rows","item","header","align","cell","lheading","paragraph","escape","inRawBlock","trimmedUrl","rtrimSlash","lastParenIndex","findClosingBracket","b","indexOf","level","linkLen","reflink","links","nolink","linkString","emStrong","maskedSrc","prevChar","emStrongLDelim","punctuation","lLength","rDelim","rLength","delimTotal","midDelimTotal","endReg","emStrongRDelimAst","emStrongRDelimUnd","lastIndex","lastCharLength","codespan","hasNonSpaceChars","hasSpaceCharsOnBothEnds","br","del","autolink","url","prevCapZero","_backpedal","inlineText","bullet","_paragraph","_blockLabel","_tag","_comment","blockNormal","gfmTable","blockGfm","blockPedantic","_punctuation","_inlineComment","_inlineLabel","reflinkSearch","inlineNormal","blockSkip","inlinePedantic","inlineGfm","inlineBreaks","normal","_Lexer","inlineQueue","create","lex","lexInline","next","lastParagraphClipped","cutSrc","extTokenizer","call","startBlock","tempStart","startIndex","Infinity","tempSrc","forEach","getStartIndex","errMsg","charCodeAt","console","error","Error","keepPrevChar","keys","includes","lastIndexOf","startInline","_Renderer","parser","langString","body","parse","parseInline","j","listitem","itemBody","checkbox","unshift","tablecell","tablerow","k","content","strong","em","cleanHref","out","image","_TextRenderer","_Parser","textRenderer","anyToken","renderers","ret","genericToken","textToken","_Hooks","passThroughHooks","Set","preprocess","markdown","postprocess","processAllTokens","provideLexer","provideParser","Marked","setOptions","parseMarkdown","Parser","Renderer","TextRenderer","Lexer","Tokenizer","Hooks","args","use","callback","values","concat","tableToken","listToken","childTokens","flat","pack","opts","ext","prevRenderer","apply","extLevel","prop","rendererFunc","tokenizerFunc","prevTokenizer","hooksFunc","prevHook","has","arg","Promise","resolve","then","packWalktokens","blockType","origOpt","throwError","onError","prototype","toString","all","catch","message","msg","reject","markedInstance","getDefaults","$4b24793a4b0f2663$export$febf71ca481883cc","$4b24793a4b0f2663$var$__rest","p","hasOwnProperty","getOwnPropertySymbols","propertyIsEnumerable","$4b24793a4b0f2663$var$OriginalURLPattern","_a","rest","OffcanvasNavbar","assign","sticky","_b","_c","restLinkProps","active","location","hash","startsWith","i18n","currentLanguage","onChange","currentTarget","changeLanguage","entries","LanguageName","$27b1627f4ff99c0e$export$fb184b623420d9be","$27b1627f4ff99c0e$export$5a1dbaa3e4449344","$27b1627f4ff99c0e$export$31da89627f5e6e8b","$27b1627f4ff99c0e$export$31978e77bf6e08fb","$27b1627f4ff99c0e$export$60974f670aa8d75e","$27b1627f4ff99c0e$export$39babdfab504f3da","$27b1627f4ff99c0e$export$95794f71fd1fcea8","$27b1627f4ff99c0e$export$95d17814281fb808","$27b1627f4ff99c0e$export$14e304d9e12f4092","$27b1627f4ff99c0e$export$dbe41a478099b642","$27b1627f4ff99c0e$export$d9f4fb13de619c2b","$jo7kd","$gHgq0","$5MUyt","$bIu6S","$f6NIY","$blYYo","$8d2Jc","$3GzEr","$inOb0","$cf13Y","$7koFK","$7Xxj5","$6vgs4","$8MbJ8","$hb62k","$gF6G2","$6R7SA","$jZtYj","$8rFS0","$dJG7Y","$3bQxZ","$1vYb3","$6FCPq","$63fF8","$6zQdD","$gUMbH","$8Os7Q","$lK3VL","$aS2H3","$30Oft","$gdBbN","$dm065","path","FCC_CDC","JueJin","OSChina","turing","$c27d65df7592ab6e$export$bb383df5b32c05b7","$c27d65df7592ab6e$export$7f92890d073cca8c","$affdfcc70845640a$export$e5c5c7a5558278fe","$c215a794ceb2758a$export$24f9481c6fe98ef7","$1564f4f7532c0117$export$2e2bcd8739ae039","$aeQZH","$hXWPJ","$5dDsr","$iW3qR","$87N2j","$a8nfF","$50hrK","$8fcJL","$9Ojwv","$c6f94efb3529b7b9$export$e8e78c978b129247","$c6f94efb3529b7b9$export$b840e55573b2d2e7","$c6f94efb3529b7b9$export$345c5736c8054f22","$c6f94efb3529b7b9$export$8b0699a3bcbc6095","$c6f94efb3529b7b9$export$85fc6f6fd6332263","$c6f94efb3529b7b9$export$a51de3b6c04f794d","$c6f94efb3529b7b9$export$783166601a642219","$c6f94efb3529b7b9$export$3b2217e45a573556","$c6f94efb3529b7b9$export$d9f4fb13de619c2b","$c6f94efb3529b7b9$export$b48fe2737b0f5681","$bb10fbb2bebf156f$export$d43206f0b9719a5e","style","width","_defaults"],"version":3,"file":"2018.69007646.js.map"}